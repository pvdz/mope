window.exportedCase = {"mapper":{"~/proj/zetype/bin/run.mjs":{"../src/index.mjs":"~/proj/zetype/src/index.mjs"},"~/proj/zetype/src/index.mjs":{"./phase0.mjs":"~/proj/zetype/src/phase0.mjs","./phase1.mjs":"~/proj/zetype/src/phase1.mjs","./phase2.mjs":"~/proj/zetype/src/phase2.mjs","./phase3.mjs":"~/proj/zetype/src/phase3.mjs","./lint.mjs":"~/proj/zetype/src/lint.mjs","./utils.mjs":"~/proj/zetype/src/utils.mjs","./builtins.mjs":"~/proj/zetype/src/builtins.mjs"},"~/proj/zetype/src/builtins.mjs":{"./utils.mjs":"~/proj/zetype/src/utils.mjs","./tools.mjs":"~/proj/zetype/src/tools.mjs","./actions.mjs":"~/proj/zetype/src/actions.mjs"},"~/proj/zetype/src/actions.mjs":{"./utils.mjs":"~/proj/zetype/src/utils.mjs","./tools.mjs":"~/proj/zetype/src/tools.mjs","../node_modules/tenko/build/tenko.prod.mjs":"~/proj/zetype/node_modules/tenko/build/tenko.prod.mjs"},"~/proj/zetype/src/tools.mjs":{"./utils.mjs":"~/proj/zetype/src/utils.mjs"},"~/proj/zetype/src/lint.mjs":{"./utils.mjs":"~/proj/zetype/src/utils.mjs"},"~/proj/zetype/src/phase3.mjs":{"./utils.mjs":"~/proj/zetype/src/utils.mjs","./globals.mjs":"~/proj/zetype/src/globals.mjs","./actions.mjs":"~/proj/zetype/src/actions.mjs"},"~/proj/zetype/src/phase2.mjs":{"../node_modules/tenko/build/tenko.prod.mjs":"~/proj/zetype/node_modules/tenko/build/tenko.prod.mjs","./utils.mjs":"~/proj/zetype/src/utils.mjs"},"~/proj/zetype/src/phase1.mjs":{"./walk.mjs":"~/proj/zetype/src/walk.mjs","./utils.mjs":"~/proj/zetype/src/utils.mjs","./globals.mjs":"~/proj/zetype/src/globals.mjs","../node_modules/tenko/build/tenko.prod.mjs":"~/proj/zetype/node_modules/tenko/build/tenko.prod.mjs"},"~/proj/zetype/src/phase0.mjs":{"./error_tenko.mjs":"~/proj/zetype/src/error_tenko.mjs","./utils.mjs":"~/proj/zetype/src/utils.mjs","../node_modules/tenko/build/tenko.prod.mjs":"~/proj/zetype/node_modules/tenko/build/tenko.prod.mjs"},"index":{"../src/index.mjs":"~/proj/zetype/src/index.mjs"}},"files":{"index":"// \"Self compiling\" default run. Runs mope on itself.\n\nimport main from '../src/index.mjs';\n\nmain('hello.world()');\n","~/proj/zetype/src/index.mjs":"import {phase0} from './phase0.mjs';\nimport {phase1} from './phase1.mjs';\nimport {phase2} from './phase2.mjs';\nimport {phase3} from './phase3.mjs';\nimport {createLinter} from './lint.mjs';\nimport {\n  BLUE,\n  GREEN,\n  RED,\n  RESET,\n  WHITE,\n  YELLOW,\n  BOLD,\n\n  ASSERT,\n  ASSERT_TID,\n  clearStdio,\n  dir,\n  group,\n  groupEnd,\n  log,\n  printNode,\n  setStdio,\n  tstr,\n} from './utils.mjs';\nimport {setupBuiltins} from './builtins.mjs';\n\nexport default function main(code, options = {\n  entryPoint: 'index', // filename of entry point, when resolved, imports in entry point code will be from this value\n  stdio: undefined, // override logging (doesn't disable the overhead but you can suppress it this way)\n  onParse: undefined, // callback triggered immediately after parsing, before further processing, called with the full result of Tenko (by reference) and a Map mapping col x line (like `4x7`) to its token for each token. return value ignored.\n  resolve: undefined, // callback to normalize filenames for import/export. called for every new file, every export from, and every import from\n  req: undefined, // custom resolver logic for fetching import/export paths (mostly for testing and the repl). given a path it should return a string that is the source of that path.\n}) {\n  if (options.stdio) {\n    setStdio(options.stdio);\n  } else {\n    clearStdio();\n  }\n\n  const backingStore = new Map\n  const store = {\n    uid: 0,\n    instanceId: 0,\n    superStack: [], // I think this is fine to share between files..?\n    callCache: new Map,\n    linter: createLinter(),\n    options,\n\n    resolve: options.resolve || ((filename, from) => filename),\n    req: options.req,\n\n    // Queue of files to process, in order of discovering them. Use priority map to determine next step.\n    // The queue is expanded as imports are discovered. Circular dependencies are not supported.\n    queue: [],\n    priority: new Map([[null, 1]]), // Map<filename, proprity>. Root=1, any deps get priority+1 of the file that depends on it. Or the max of multiple files depending on it. That way it should bubble the priority properly automatically.\n\n    // File specific data that can't be shared, like globals, imports, and exports\n    fileData: new Map,\n\n    // Note: this get/set is about tids, not bound idents in scope (!)\n    get(tid, trace) {\n      if (trace) log('store.get(', tstr(tid), ')');\n      let tee = backingStore.get(tid);\n      if (trace) log('- initial:', tee);\n      ASSERT(tee, 'a tid should resolve to a tee or it shouldnt exist. the store did not know this tid', ['tid:', tid, 'tee:', tee]);\n      while (tee.alias) {\n        tee = tee.alias;\n        if (trace) log('- aliased:', tee.tid);\n      }\n      return tee;\n    },\n    set(tid, tee) {\n      ASSERT(tid && tee);\n      ASSERT_TID(tee.tid); // the tee should be an actual tee, not random other stuff\n      ASSERT(!(tee instanceof Map) && !(tee instanceof Set) && !(tee instanceof Array) && typeof tee === 'object', 'tee is a tee', tee);\n\n      backingStore.set(tid, tee);\n    },\n    final(tid) {\n      // Resolve .alias redirects immediately\n      return this.get(tid).tid;\n    },\n    linkTo(oldTee, withTee) {\n      ASSERT(oldTee && withTee && typeof oldTee !== 'string' && typeof withTee !== 'string');\n      if (oldTee === withTee) return; // can happen organically\n      let tee = oldTee;\n      while (tee.alias) {\n        tee = tee.alias;\n        if (tee === withTee) return; // can happen organically\n      }\n      tee.alias = withTee\n    },\n  };\n\n  store.fileData.set('<builtin>', {\n    // The builtin file data is to refer to for stuff that happens inside builtins...\n    filename: '<builtin>',\n    stage: 0,\n    code: '',\n\n    result: 'scheduled',\n    error: undefined,\n    globalActions: undefined, // set after phase2\n    store: undefined, // set after phase3\n    tenkoOutput: undefined,\n    tokens: undefined, // Array<token>\n    tokenTable: undefined, // Map<string, token>, \"${col}x${row}\" -> token\n    implicitGlobals: new Set, // Set<string>\n\n    globalTid: undefined, // builtin, unique per file\n    globalModuleTid: undefined, // builtin, unique per file\n\n    imports: new Map, // name -> file\n    exports: new Map, // name -> tid\n  });\n\n  setupBuiltins(store);\n\n  queueFile(store, options.entryPoint || 'index', null, code)\n\n  processQueue(store); //moduleCache, sharedGlobals);\n\n  return store;\n}\n\nfunction queueFile(store, resolvedFilename, fromFilename, sourceCode = null) {\n  const prio = store.priority.get(fromFilename) + 1;\n  console.log('Queuing', resolvedFilename.replace(/^\\/home\\/[\\w\\d]+/, '~'));\n  if (store.fileData.has(resolvedFilename)) {\n    const fileState = store.fileData.get(resolvedFilename);\n    console.log('- File already imported before...');\n    if (fileState.stage <= 3) {\n      const wasPrio = store.priority.get(resolvedFilename);\n      log('- Not finished processing yet, priority was', wasPrio, ', new prio would be', prio, ', making sure it is', Math.max(wasPrio, prio));\n      if (prio > wasPrio) store.priority.set(resolvedFilename, prio);\n    } else {\n      log('- Already finished processing');\n    }\n  } else {\n    console.log('- New file, set to prio', prio);\n    store.priority.set(resolvedFilename, prio);\n    let code = sourceCode;\n    if (sourceCode) {\n      log('queueFile: No need to fetch', resolvedFilename, 'because source was passed on (probably entry point?)');\n    } else {\n      log('queueFile: Fetching', resolvedFilename, 'and processing it first');\n      if (!store.req) {\n        throw new Error('Must receive a `req` resolver function through options to load imports/exports');\n      }\n      code = store.req(resolvedFilename, fromFilename);\n    }\n\n    store.fileData.set(resolvedFilename, {\n      filename: resolvedFilename,\n      stage: 0,\n      code,\n\n      result: 'scheduled',\n      error: undefined,\n      globalActions: undefined, // set after phase2\n      store: undefined, // set after phase3\n      tenkoOutput: undefined,\n      tokens: undefined, // Array<token>\n      tokenTable: undefined, // Map<string, token>, \"${col}x${row}\" -> token\n      implicitGlobals: new Set, // Set<string>\n\n      globalTid: undefined, // builtin, unique per file\n      globalModuleTid: undefined, // builtin, unique per file\n\n      imports: new Map, // name -> file\n      exports: new Map, // name -> tid\n    });\n\n    store.queue.unshift(resolvedFilename);\n  }\n}\n\nfunction processQueue(store) {\n  while (store.queue.length) {\n\n    store.queue.sort((a ,b) => store.priority.get(b) - store.priority.get(a));\n    const filename = store.queue[0];\n\n    if (store.fileData.get(filename).stage > 3) {\n      store.queue.shift();\n    } else {\n      queueStep(store, filename);\n    }\n  }\n}\n\nfunction queueStep(store, filename) {\n  const fileState = store.fileData.get(filename);\n  console.log('Phase', fileState.stage, 'File', filename.replace(/^\\/home\\/[\\w\\d]+/, '~'));\n  switch (fileState.stage++) {\n    case 0: {\n\n      phase0(store, filename);\n\n      // group('# AST:');\n      // dir(store.fileData.get(filename).tenkoOutput.ast, {depth: null});\n      // groupEnd();\n\n      // group('\\n# code');\n      // log(state.code);\n      // groupEnd();\n\n      return true;\n    }\n\n    case 1: {\n      phase1(store, filename);\n\n      if (fileState.imports.size) {\n        log('\\nFile imported', fileState.imports.size, 'symbols. Processing their files first.');\n        const files = new Set(fileState.imports.values());\n        log('Importing from', files.size, 'distinct files');\n        log(fileState.imports, fileState.exports);\n        fileState.imports.forEach((resolvedFilename, localNameBinding) => queueFile(store, resolvedFilename, filename));\n      }\n\n      // group('\\n# AST after phase 1');\n      // log(showAst(state.tenkoOutput.ast, {}));\n      // groupEnd();\n\n      group('\\n# code');\n      log(truncCode(fileState.code));\n      groupEnd();\n\n      return true;\n    }\n\n    case 2: {\n      phase2(store, filename);\n\n      // group('\\n# AST after phase 2');\n      // log(showAst(state.tenkoOutput.ast, {}));\n      // groupEnd();\n\n      group('\\n# code');\n      log(truncCode(fileState.code));\n      groupEnd();\n\n      return true;\n    }\n\n    case 3: {\n\n      phase3(store, filename);\n      fileState.result = 'Pass';\n\n      log('- imports:', fileState.imports);\n      log('- exports:', fileState.exports);\n\n      group('\\n# code');\n      log(truncCode(fileState.code));\n      groupEnd();\n\n      return true;\n    }\n  }\n\n  ASSERT(false, 'fixme');\n  return true;\n}\n\nfunction truncCode(code) {\n  if (code.length < 1000) return code;\n  return code.slice(0, 1000) + '\\n<... rest truncated for brevity>\\n';\n}\n","~/proj/zetype/src/phase0.mjs":"import {TenkoError} from './error_tenko.mjs';\nimport {\n  BLUE,\n  GREEN,\n  RED,\n  RESET,\n  WHITE,\n  YELLOW,\n\n  ASSERT,\n  clearStdio,\n  dir,\n  group,\n  groupEnd,\n  log,\n  printNode,\n  setStdio,\n} from './utils.mjs';\nimport * as Tenko from '../node_modules/tenko/build/tenko.prod.mjs'; // This way it works in browsers and nodejs ... :/\n\nif (typeof window !== 'undefined') window.Tenko = Tenko; // Expose symbols for UI\n\nexport function phase0(store, filename) {\n  group('\\n\\n\\n##################################\\n## phase0  ::  ' + filename + '\\n##################################\\n\\n\\n');\n\n  const fileState = store.fileData.get(filename);\n  const code = fileState.code;\n\n  log('- Parsing code with Tenko...');\n\n  try {\n    fileState.tenkoOutput = Tenko.Tenko(code, {\n      exposeScopes: true,\n      astUids: true,\n      collectTokens: Tenko.COLLECT_TOKENS_ALL,\n      goalMode: Tenko.GOAL_MODULE,\n      tokenStorage: [],\n    });\n  } catch (e) {\n    throw new TenkoError(e);\n  }\n\n  log('- Finished parsing');\n\n  fileState.tokens = fileState.tenkoOutput.tokens;\n\n  // Create a lookup table, rowxcol -> token, so we can map AST nodes to their tokens. Hopefully.\n  // Also adds a property to uniquely identify the token based on its position in the token stream.\n  fileState.tokenTable = new Map(fileState.tenkoOutput.tokens.map((token, i) => {\n    token.n = i;\n    token.str = code.slice(token.start, token.stop);\n    return [token.column + 'x' + token.line, token]\n  }));\n\n\n  if (store.options.onParse) store.options.onParse(filename, fileState.tenkoOutput, fileState.tokenTable);\n\n  groupEnd();\n}\n","~/proj/zetype/src/phase1.mjs":"import walk from \"./walk.mjs\"\nimport {\n  ASSERT,\n  BLUE,\n  RESET,\n\n  dir,\n  group,\n  groupEnd,\n  log,\n} from \"./utils.mjs\"\nimport globals from './globals.mjs';\nimport * as Tenko from '../node_modules/tenko/build/tenko.prod.mjs'; // This way it works in browsers and nodejs ... :/\n\n// No merging in this phase. Just tag 'em, hoist functions, resolve scopes. No surprises.\nexport function phase1(store, filename) {\n  const fileState = store.fileData.get(filename);\n  const ast = fileState.tenkoOutput.ast;\n  const tokenTable = fileState.tokenTable;\n\n  const funcStack = [];\n  const lexScopeStack = [];\n  const funcScopeStack = [];\n  const thisStack = [];\n  const globallyUniqueNamingRegistery = new Map;\n  const imports = fileState.imports;\n  const exports = fileState.exports;\n\n  group('\\n\\n\\n##################################\\n## phase1  ::  ' + filename + '\\n##################################\\n\\n\\n');\n\n  let uid = 0;\n\n  walk(function _walker(node, before, nodeType, path) {\n\n    ASSERT(node, 'node should be truthy', node);\n    ASSERT(nodeType === node.type);\n\n    if (before) {\n      let tid = String(++uid);\n      node.$z = {\n        tid,\n        explicitReturns: '', // Set if the node is a branching type where it matters\n      };\n\n      let needleNode = node;\n      if (needleNode.type === 'TemplateElement') needleNode = path.nodes[path.nodes.length - 2];\n      const key = needleNode.loc.start.column + 'x' + needleNode.loc.start.line;\n      const token = tokenTable.get(key);\n      ASSERT(token, 'each node start should correspond to a token at that position', key, tokenTable, needleNode, path);\n      node.$z.ti = token.n; // ti = token index\n    }\n\n    group(BLUE + nodeType + ':' + (before?'before':'after'), RESET);\n\n    const key = nodeType + ':' + (before?'before':'after');\n\n    if (before && node.$scope) {\n      lexScopeStack.push(node);\n      if (['Program', 'FunctionExpression', 'ArrowFunctionExpression', 'FunctionDeclaration'].includes(node.type)) {\n        funcScopeStack.push(node);\n      }\n    }\n\n    // Assign unique names to bindings to work around lex scope shadowing `let x = 1; { let x = 'x'; }`\n    // This allows us to connect identifier binding references that belong together, indeed together, and distinct\n    // a binding from its shadow by the same name. Otherwise in the previous example, we'd never know \"which\" x is x.\n    if (before && node.$scope) {\n      node.$z.nameMapping = new Map(\n        node.type === 'Program'\n          ? [...globals.keys(), 'module'].map(k => [k, k])\n          : [['this', 'this'], ['arguments', 'arguments']]\n      ); // lex binding can look up its unique global name through this (nearest) mapping\n\n      const funcNode = funcScopeStack[funcScopeStack.length - 1];\n      if (funcNode === node) funcNode.$z.scopeBindings = new Map;\n      const scopeBindings = funcNode.$z.scopeBindings;\n      ASSERT(scopeBindings);\n\n      let s = node.$scope;\n      ASSERT(['FunctionExpression', 'FunctionDeclaration'].includes(node.type) ? s.type === Tenko.SCOPE_LAYER_FUNC_BODY : true, 'scope type is body, which we ignore (perhaps not for arrows?)', node.$scope);\n\n      do {\n        group('Checking scope...');\n        log('- type:', s.type, ', bindings?', s.names !== Tenko.HAS_NO_BINDINGS);\n        if (node.type === 'BlockStatement' && s.type === Tenko.SCOPE_LAYER_FUNC_PARAMS) {\n          log('Breaking for function header scopes in Block');\n          groupEnd();\n          break;\n        }\n\n        if (s.names === Tenko.HAS_NO_BINDINGS) {\n          log('- no bindings in this scope, parent:', s.parent && s.parent.type);\n        } else if (['FunctionExpression', 'FunctionDeclaration', 'ArrowFunctionExpression'].includes(node.type) && s.type === Tenko.SCOPE_LAYER_FUNC_BODY) {\n          log('- ignoring scope body in function node');\n        } else if (node.type === 'CatchClause' && s.type !== Tenko.SCOPE_LAYER_CATCH_HEAD && s.type !== Tenko.SCOPE_LAYER_CATCH_BODY) {\n          log('- in catch clause we only care about the two catch scopes');\n          break;\n        } else if (node.type === 'BlockStatement' && s.type === Tenko.SCOPE_LAYER_GLOBAL) {\n          log('- do not process global scope in block');\n          break;\n        } else if (node.type === 'BlockStatement' && s.type === Tenko.SCOPE_LAYER_FUNC_BODY && !['FunctionExpression', 'FunctionDeclaration', 'ArrowFunctionExpression'].includes(path.nodes[path.nodes.length - 2].type)) {\n          log('- do not process func scope in a block that is not child of a function');\n          break;\n        } else {\n          s.names.forEach((v, name) => {\n            log('-', name, ':', v);\n\n            // if (node.type === 'BlockStatement' && v === Tenko.BINDING_TYPE_FUNC_VAR) {\n            //   log('- ignoring func name in block scope');\n            //   return;\n            // }\n\n            if (v === Tenko.BINDING_TYPE_VAR && funcNode !== node) {\n              // only process `var` bindings in the scope root\n              log('  - skipping var because not scope root');\n              return;\n            }\n\n            if (v === Tenko.BINDING_TYPE_FUNC_VAR && (s.type === Tenko.SCOPE_LAYER_FUNC_PARAMS)) {\n              log('  - skipping func var in param layer or global layer');\n              return\n            }\n\n            // if (node.type === 'FunctionExpression' && v === Tenko.BINDING_TYPE_FUNC_VAR) {\n            //   log('  - skipping func var in expr block');\n            //   return\n            // }\n\n            // Create a globally unique name. Then use that name for the local scope.\n            let n = 0;\n            if (globallyUniqueNamingRegistery.has(name)) {\n              while (globallyUniqueNamingRegistery.has(name + '_' + (++n)));\n            }\n\n            log('Adding `' + name + '` to:');\n            log('- globallyUniqueNamingRegistery -->', n ? name + '_' + n : name);\n            globallyUniqueNamingRegistery.set(name + (n ? '_' + n : ''), ++uid);\n            log('- the scope binding for node at column:', funcNode.loc.start.column, ', line:', funcNode.loc.start.line);\n            scopeBindings.set(name + (n ? '_' + n : ''), uid);\n            log('- the mapping for node at column:', node.loc.start.column, ', line:', node.loc.start.line);\n            node.$z.nameMapping.set(name, name + (n ? '_' + n : ''));\n          });\n        }\n\n        // Only certain nodes have hidden scopes to process. For any other node do not process the parent.\n        if (!['FunctionExpression', 'ArrowFunctionExpression', 'ArrowFunctionExpression', 'FunctionDeclaration', 'CatchClause'].includes(node.type)) {\n          groupEnd();\n          break;\n        }\n        groupEnd();\n      } while (s.type !== Tenko.SCOPE_LAYER_GLOBAL && (s = s.parent));\n\n      // Each node should now be able to search through the lexScopeStack, and if any of them .has() the name, it will\n      // be able to .get() the unique name, which can be used in either the root scope or by the compiler in phase2.\n      log('node.$z.nameMapping:', new Map([...node.$z.nameMapping.entries()].filter(([tid]) => node.type === 'Program' ? !globals.has(tid) : !['this', 'arguments'].includes(tid))));\n      log('nearest func scope bindings:', [...scopeBindings.entries()].map(([key, value]) => key + ': ' + value).join(', '));\n      log('node loc; column:', node.loc.start.column, ', line:', node.loc.start.line);\n    }\n\n    switch (key) {\n      case 'Program:before': {\n        funcStack.push(node);\n        break;\n      }\n      case 'Program:after': {\n        funcStack.pop();\n        log('-->', node.$z.scopeBindings);\n        break;\n      }\n\n      case 'FunctionDeclaration:before':\n      case 'FunctionExpression:before':\n      case 'ArrowFunctionExpression:before': {\n        funcStack.push(node);\n        if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') {\n          node.$z.scope = {type: 'zscope', names: new Map};\n          thisStack.push(node);\n        }\n        break;\n      }\n      case 'FunctionDeclaration:after':\n      case 'FunctionExpression:after':\n      case 'ArrowFunctionExpression:after': {\n        funcStack.pop();\n        if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') {\n          thisStack.pop();\n        }\n\n        let lexes = lexScopeStack.slice(1);\n        while (lexes[0] && ['FunctionDeclaration', 'FunctionExpression', 'ArrowFunctionExpression'].includes(lexes[0].type)) lexes.shift(); // Drop global block scopes etc\n        const map = new Map;\n        lexes.forEach((node) => {\n          node.$z.nameMapping.forEach((newName, bindingName) => {\n            if (bindingName === 'this' || bindingName === 'arguments') return;\n            // Binding name may exist. We only care about the inner-most shadow.\n            map.set(bindingName, newName);\n          });\n        });\n        node.$z.reachableNames = map;\n\n        log('-->', node.$z.scopeBindings);\n        break;\n      }\n\n      case 'CatchClause:before': {\n        // Note: the catch scope is set on node.handler of the try (parent node of the catch clause)\n        break;\n      }\n\n      case 'ClassExpression:after':\n      case 'ClassDeclaration:after': {\n        break;\n      }\n\n      case 'Identifier:after': {\n        break;\n      }\n\n      case 'ImportDeclaration:before': {\n        ASSERT(node.source && typeof node.source.value === 'string', 'fixme if else', node);\n        const source = node.source.value;\n        ASSERT(typeof store.resolve === 'function', 'store.resolve must be a function here', store.resolve);\n        const resolvedSource = store.resolve(source, filename);\n\n        ASSERT(node.specifiers, 'fixme if different', node);\n\n        node.specifiers.forEach(snode => {\n          const id = snode.local;\n          ASSERT(id.type === 'Identifier', 'fixme if local is not an ident', snode);\n\n          if (snode.type === 'ImportNamespaceSpecifier') {\n            ASSERT(snode.type === 'ImportNamespaceSpecifier');\n            // This will trigger the file to be processed. It'll be added to the list if new, it will be bumped to the\n            // top of the queue if not finished processing yet. It will resolve before this file.\n            imports.set(id.name, resolvedSource);\n          } else if (snode.type === 'ImportDefaultSpecifier') {\n            // This will trigger the file to be processed. It'll be added to the list if new, it will be bumped to the\n            // top of the queue if not finished processing yet. It will resolve before this file.\n            imports.set(id.name, resolvedSource);\n          } else {\n            ASSERT(snode.imported, 'fixme', snode.type, snode);\n            // This will trigger the file to be processed. It'll be added to the list if new, it will be bumped to the\n            // top of the queue if not finished processing yet. It will resolve before this file.\n            imports.set(id.name, resolvedSource);\n          }\n        });\n\n        break;\n      }\n      case 'ImportDefaultSpecifier: after': {\n        ASSERT(node.source && typeof node.source.value === 'string', 'fixme if else', node);\n        const source = node.source.value;\n        const resolvedSource = store.resolve(source, filename);\n\n        ASSERT(node.specifiers, 'fixme if different', node);\n\n        // This will trigger the file to be processed. It'll be added to the list if new, it will be bumped to the\n        // top of the queue if not finished processing yet. It will resolve before this file.\n        imports.set('default', resolvedSource);\n\n        break;\n      }\n\n      case 'MemberExpression:after': {\n        break;\n      }\n\n      case 'Super:after': {\n        break;\n      }\n\n      case 'ThisExpression:after': {\n        if (thisStack.length) {\n          log('Marking func as having `this` access');\n          thisStack[thisStack.length - 1].$z.thisAccess = true;\n        } else {\n          store.linter.check('GLOBAL_THIS', {filename, column: node.loc.start.column, line: node.loc.start.line});\n        }\n        break;\n      }\n\n      case 'ReturnStatement:before': {\n        node.$z.explicitReturns = 'yes'; // Per definition :)\n        break;\n      }\n\n      // block, if, else, try, catch, finally, switch, case, default, [with], label. Not the loops, can't guarantee them\n\n      case 'BlockStatement:after': // node.body\n        // If there is a node that has explicitReturns=yes and none of the nodes that precede it is break/continue/throw,\n        // then the block returns. Otherwise the block does not return.\n        for (let i=0; i<node.body.length; ++i) {\n          const snode = node.body[i];\n          if (snode.$z.explicitReturns === 'yes') {\n            node.$z.explicitReturns = 'yes';\n            break;\n          }\n          if (node.type === 'BreakStatement' || node.type === 'ContinueStatement' || node.type === 'ThrowStatement') {\n            break;\n          }\n        }\n        if (node.$z.explicitReturns !== 'yes') node.$z.explicitReturns = 'no';\n        log('- explicitReturns:', node.$z.explicitReturns);\n        break;\n\n      case 'IfStatement:after': // there is no ElseStatement (!), node.consequent and node.alternate\n        // The problem here is that each branch is not visited explicitly so we can't queue up a return tid for\n        // the `if` and the `else` separately. That's a little annoying. So we have to retroactively check the\n        // last statement, instead.\n\n        if (node.consequent.$z.explicitReturns !== 'yes') {\n          // The `if` statement must exist. If it is not returning then this doesn't either\n          node.$z.explicitReturns = 'no';\n        } else if (!node.alternate || node.alternate.$z.explicitReturns !== 'yes') {\n          // The `else` may not exist, in that case the whole thing doesn't return. Otherwise it only returns if the\n          // sub-statement returns.\n          node.$z.explicitReturns = 'no';\n        } else {\n          node.$z.explicitReturns = 'yes';\n        }\n        log('- explicitReturns:', node.$z.explicitReturns);\n        break;\n\n      // case 'TryStatement:before': {\n      //   // This is the catch scope (!)\n      //   node.handler.$z = {};\n      //   node.handler.$z.scope = {type: 'zscope', names: new Map};\n      //   break;\n      // }\n      case 'TryStatement:after': // node.block, node.handler, node.finalizer\n        // Tricky case. The `try` node returns if;\n        // - there is a finally block; the node returns when the finally returns, and does not when finally does not\n        // - there is only a catch block and both the blocks return\n        // Note that we ignore explicit `throw` statements, but we could later improve that situation.\n\n        if (node.finalizer) {\n          // If there is a finalizer block, I only care about the explicit return state of that block now.\n          // This is because it is guaranteed to be visited, and its return value trumps that of the try/catch blocks.\n          node.$z.explicitReturns = node.finalizer.$z.explicitReturns === 'yes' ? 'yes' : 'no';\n        } else if (node.block.$z.explicitReturns !== 'yes') {\n          // There is no finally, so the whole node cannot be explicitReturn if the `try` block is not\n          node.$z.explicitReturns = 'no';\n        } else if (node.handler.body.$z.explicitReturns !== 'yes') {\n          // There is no finally, so the whole node cannot be explicitReturn if the `catch` block is not\n          node.$z.explicitReturns = 'no';\n        } else {\n          // No finally and try and catch blocks return, so the whole node returns\n          node.$z.explicitReturns = 'yes';\n        }\n        log('- explicitReturns:', node.$z.explicitReturns);\n        break;\n\n      case 'SwitchStatement:after': // node.cases\n        // Only returns if all cases return AND one of the cases is a default\n        // Tricky case is when the case falls through and returns a following case.\n        // No real difference between case and default, except the default is mandatory for the switch to return expl.\n        let hasDefault = false;\n\n\n        // For each case check whether it returns explicitly (and before a break/continue) and if it doesn't, check\n        // the next case as well. Mark a default case but don't treat it differently otherwise. When all case blocks\n        // explicitly return then the whole switch node returns explicitly.\n        // In other words, this fails if for any case a `break/continue` is seen before a `return`, or when no `return`\n        // is seen at all since the start of the last `case`.\n        // Note: a node that is marked explicitReturns is similar to a return statement because all its branches return.\n\n        let seenReturnSinceLastCase = false;\n        let brokeBeforeReturned = false;\n        for (let i=0; i<node.cases.length && !brokeBeforeReturned; ++i) {\n          seenReturnSinceLastCase = false;\n          const caseNode = node.cases[i];\n          if (!caseNode.test) hasDefault = true;\n          caseNode.consequent.some(node => {\n            if (node) {\n              if (node.$z.explicitReturns || node.type === 'ReturnStatement') {\n                // Either this is the return statement, or it's a statement where all branches must lead to a return.\n                seenReturnSinceLastCase = true;\n                return true;\n              }\n              if (node.type === 'BreakStatement' || node.type === 'ContinueStatement') {\n                brokeBeforeReturned = true;\n                return true;\n              }\n            }\n          });\n        }\n        if (!seenReturnSinceLastCase || brokeBeforeReturned || !hasDefault) {\n          // Either no return statement was seen since, at least, the last case start, or at least one case exists\n          // that had a break/continue before the return statement. Either way, this switch is not an explicit return.\n          node.$z.explicitReturns = 'no';\n        } else {\n          // For all cases there was at least one return statement before the end of the swtich that was not preceded\n          // by a break or continue. This switch properly returns explicitly for all branches.\n          node.$z.explicitReturns = 'yes';\n        }\n        log('- explicitReturns:', node.$z.explicitReturns);\n        break;\n\n      case 'WithStatement:after': // node.body\n        ASSERT(false, 'with is not allowed in a \"strict\" context. The parser should have rejected this.');\n        break;\n\n      case 'LabeledStatement:after': // node.body\n        TODO // add tests\n        node.$z.explicitReturns = node.body.$z.explicitReturns === 'yes' ? 'yes' : 'no';\n        log('- explicitReturns:', node.$z.explicitReturns);\n        break;\n    }\n\n    // if (node.$scope) ASSERT(node.$scope.walked);\n\n    if (!before && node.$z.scope) {\n      const scope = lexScopeStack.pop();\n      if (['Program', 'FunctionExpression', 'ArrowFunctionExpression', 'FunctionDeclaration'].includes(node.type)) {\n        funcScopeStack.pop();\n      } else {\n        const funcScope = funcScopeStack[funcScopeStack.length - 1];\n      }\n    }\n\n    groupEnd();\n  }, ast, 'ast');\n\n  log('globallyUniqueNamingRegistery:', globallyUniqueNamingRegistery);\n\n  log('End of phase 1');\n  groupEnd();\n}\n","~/proj/zetype/src/phase2.mjs":"import * as Tenko from '../node_modules/tenko/build/tenko.prod.mjs'; // This way it works in browsers and nodejs ... :/\n\nimport {\n  ASSERT,\n  DIM,\n  BOLD,\n  RESET,\n  BLUE,\n\n  NO_SUPER_VALUE,\n\n  dir,\n  group,\n  groupEnd,\n  log,\n  printNode, tstr, NO_DEFAULT_VALUE, createPlaceholder,\n} from \"./utils.mjs\"\n\n// Functions have been hoisted, scopes have been resolved, time to merge AST nodes and leave as few nodes as possible\n// without actually interpreting code.\n// For example, return statement return value tid get merged with the return keyword and the whole statement node.\n\nexport function phase2(store, filename) {\n  const fileState = store.fileData.get(filename);\n  const {tokens, tokenTable} = fileState;\n  const linter = store.linter;\n\n  const lexScopeStack = [];\n  const rootScopeStack = [];\n  const superCallStack = []; // `super()` is validated by the parser so we don't have to worry about scoping rules\n\n  group('\\n\\n\\n##################################\\n## phase2  ::  ' + filename + '\\n##################################\\n\\n\\n');\n\n  let actions = [];\n  stmt(fileState.tenkoOutput.ast);\n  $(fileState.tenkoOutput.ast, '@log', 'End of Program');\n  fileState.globalActions = actions;\n\n  log('\\nCompiled actions:');\n  dir(actions, {depth: null});\n  log('\\nprint friendly actions:');\n  const printFriendly = actions.slice(0,20).map(function r(action, _, __, indent = '  ') {\n    if (action[0] === '@func') {\n      return indent + action[0] + ',' + action[3].slice(0, 5) + ', ' + action[3].slice(7).join(', ') + action.slice(4).join(', ') + ':\\n' + action[3][6].map(a => r(a, _, __, indent + '  ')).join('\\n');\n    }\n    return indent + action.join(', ');\n  }).join('\\n').split('\\n');\n  log('\\n' + printFriendly.slice(0, 100).join('\\n'), printFriendly.length >= 100 ? '(... ' + (printFriendly.length - 100) + ' more actions suppressed...)' : '');\n\n  groupEnd();\n\n  function $(node, action, ...args) {\n    const {loc: {start: {column, line}}} = node;\n    actions.push([action, column, line, args]);\n  }\n  function _$(node, action, ...args) {\n    const {loc: {start: {column, line}}} = node;\n    actions.unshift([action, column, line, args]);\n  }\n\n  function getFirstToken(node) {\n    ASSERT(node, 'getFirstToken wants a node', node);\n    const token = tokenTable.get(node.loc.start.column + 'x' + node.loc.start.line);\n    ASSERT(token, 'each ast node should be able to find the first token of that node', node, token);\n    return token;\n  }\n  function getPrevTokenPastGroupAndSpaces(node) {\n    const tokenRhs = getFirstToken(node);\n    let tokenPrev = tokens[tokenRhs.n - 1];\n    while (tokenPrev && (Tenko.isWhiteToken(tokenPrev.type) || tokenPrev.str === '(')) {\n      tokenPrev = tokens[tokenPrev.n - 1];\n    }\n    ASSERT(tokenPrev, 'should have found a token', tokenPrev);\n    return tokenPrev;\n  }\n\n  function findUniqueNameForBindingIdent(node, startAtPArent = false) {\n    ASSERT(node && node.type === 'Identifier', 'need ident node for this', node);\n    log('Finding unique name for `' + node.name + '`');\n    let index = lexScopeStack.length;\n    if (startAtPArent) --index; // For example: func decl id has to be looked up outside its own inner scope\n    while (--index >= 0) {\n      // log('- lex level', index,':', lexScopeStack[index].$z.nameMapping.has(node.name));\n      if (lexScopeStack[index].$z.nameMapping.has(node.name)) {\n        break;\n      }\n    }\n    if (index < 0) {\n      log('The ident `' + node.name + '` could not be resolved');\n      linter.check('IMPLICIT_GLOBAL', {filename, column: node.loc.start.column, line: node.loc.start.line}, node.name);\n      // Register one...\n      log('Creating global binding for `' + node.name + '` now');\n      lexScopeStack[0].$z.nameMapping.set(node.name, node.name);\n      index = 0;\n    }\n    const uniqueName = lexScopeStack[index].$z.nameMapping.get(node.name);\n    ASSERT(uniqueName !== undefined, 'should exist');\n    log('Should be bound in scope index', index, 'mapping to `' + uniqueName + '`');\n    return uniqueName;\n  }\n\n  function stmt(node, isExport = false) {\n    group(DIM + 'stmt(' + RESET + BLUE + node.type + RESET + DIM + ')' + RESET);\n\n    if (node.$scope || (node.type === 'TryStatement' && node.handler)) {\n      if (node.$scope) lexScopeStack.push(node);\n      else lexScopeStack.push(node.handler);\n      if (['Program', 'FunctionExpression', 'ArrowFunctionExpression', 'FunctionDeclaration'].includes(node.type)) {\n        rootScopeStack.push(node);\n      }\n    }\n\n    switch (node.type) {\n      case 'BlockStatement': {\n        node.body.forEach(node => stmt(node));\n        break;\n      }\n\n      case 'BreakStatement': {\n        // TODO: is there anything regarding labels our system can deal with that regular parsers can't?\n        break;\n      }\n\n      case 'ClassDeclaration': {\n        processClass(node, false, isExport);\n        break;\n      }\n\n      case 'ContinueStatement': {\n        // TODO: is there anything regarding labels our system can deal with that regular parsers can't?\n        break;\n      }\n\n      case 'DebuggerStatement': {\n        break;\n      }\n\n      case 'DoWhileStatement': {\n        stmt(node.body);\n\n        expr(node.test);\n        $(node, '@condition');\n\n        break;\n      }\n\n      case 'ExportAllDeclaration': {\n        // export * from 'foo'\n        const source = node.source.value;\n        ASSERT(typeof source === 'string');\n        store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'todo_export_star');\n        break;\n      }\n\n      case 'ExportDefaultDeclaration': {\n        // export default expr\n        // export default function(){}\n        // export default class(){}\n\n        // Note: imports/exports are not properly tracked. Only do the effort to cover executed code for now.\n\n        if (node.declaration.type === 'FunctionDeclaration' || node.declaration.type === 'ClassDeclaration') {\n          log('Export defaulting a function or class. Treating it a regular declaration that exports as `default`.');\n          // It's kind of relevant to parse them as statements because of how their id gets bound\n          stmt(node.declaration, 'default');\n        } else {\n          expr(node.declaration);\n          $(node, '@dup', '<export default value>');\n          $(node, '@export_as', 'default');\n        }\n        break;\n      }\n\n      case 'ExportNamedDeclaration': {\n        // These have a declaration and no specifiers:\n        // - export function f (){}\n        // - export class g {}\n        // - export let a\n        // - export const b = 1\n        // - export var c = 2\n\n        // These have specifiers and no declaration. One specifier per exported symbols.\n        // Type of export may affect type of specifier node\n        // - var d,e; export {d,e}\n        // - export {x}\n        // - export {x as y}\n        // - export x from 'foo'\n        // - export {x} from 'foo'\n        // - export * as y from 'foo'     (not same as only *)\n        // - export {x as z} from 'foo'\n\n        if (node.source) {\n          // export ... from\n          store.linter.check('TOFIX', locFrom, callerTee.tid);\n        } else if (node.declaration) {\n          if (node.declaration.type === 'FunctionDeclaration' || node.declaration.type === 'VariableDeclaration' || node.declaration.type === 'ClassDeclaration') {\n            stmt(node.declaration, true);\n          } else {\n            ASSERT(false, 'fixme', node);\n          }\n        } else {\n          node.specifiers.forEach(snode => {\n            ASSERT(snode.local.type === 'Identifier', 'fixme if different', snode);\n            ASSERT(snode.exported.type === 'Identifier', 'fixme if different', snode);\n\n            $(snode.local, '@ident', snode.local.name);\n            getFirstToken(snode.local).tlog = [];\n            $(snode, '@export_as', snode.exported.name);\n          });\n        }\n        break;\n      }\n\n      case 'ExpressionStatement': {\n        expr(node.expression);\n        $(node, '@drop'); // Ignore the type of the expression\n        break;\n      }\n\n      case 'EmptyStatement': {\n        break;\n      }\n\n      case 'ForStatement': {\n        if (node.init) {\n          if (node.init.type === 'VariableDeclaration') {\n            stmt(node.init);\n          } else {\n            expr(node.init); // TODO: what about var/let/const here?\n            $(node, '@drop');\n          }\n        }\n        if (node.test) {\n          expr(node.test);\n          $(node, '@condition');\n        }\n        if (node.update) {\n          expr(node.update);\n          $(node, '@drop');\n        }\n        stmt(node.body);\n        break;\n      }\n\n      case 'ForInStatement': {\n        $(node, '@push', 'string'); // Init the binding to a string; it'll receive property names\n\n        if (node.left.type === 'VariableDeclaration') {\n          ASSERT(node.left.declarations.length === 1, 'I think this is syntactically enforced?');\n          ASSERT(node.left.declarations[0].type === 'VariableDeclarator');\n          const id = node.left.declarations[0].id;\n          ASSERT(id && id.type === 'Identifier');\n          ASSERT(!node.left.declarations[0].init, 'for-in lhs should not be allowed to have an init');\n\n          log('For-in lhs:');\n          const uniqueName = findUniqueNameForBindingIdent(id);\n          $(id, '@binding', uniqueName, node.left.kind);\n        } else {\n          expr(node.left);\n          $(node, '@merge');\n          $(node, '@drop');\n        }\n\n        expr(node.right);\n        $(node, '@lint', 'primitive', 'FOR_IN_RHS_PRIMITIVE');\n        $(node, '@drop');\n\n        stmt(node.body);\n        break;\n      }\n\n      case 'ForOfStatement': {\n        // TODO: This needs proper support for iterable stuff for true support. We could start with superficial support.\n        if (node.await) store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'todo_for_await');\n\n        // Get the kind of the type of the rhs. Initially, that means string for strings and kind for arrays.\n        expr(node.right);\n        $(node, '@of');\n\n        if (node.left.type === 'VariableDeclaration') {\n          ASSERT(node.left.declarations.length === 1, 'I think this is syntactically enforced?');\n          ASSERT(node.left.declarations[0].type === 'VariableDeclarator');\n          const id = node.left.declarations[0].id;\n          ASSERT(id && id.type === 'Identifier');\n          ASSERT(!node.left.declarations[0].init, 'for-in lhs should not be allowed to have an init');\n\n          log('For-of lhs:');\n          const uniqueName = findUniqueNameForBindingIdent(id);\n          $(id, '@binding', uniqueName, node.left.kind);\n        } else {\n          expr(node.left);\n          $(node, '@merge');\n          $(node, '@drop');\n        }\n\n        stmt(node.body);\n        break;\n      }\n\n      case 'FunctionDeclaration': {\n        let abak = actions;\n        actions = []\n\n        $(node, '@log', 'start of func decl ' + (node.id ? node.id.name : '{anon}'));\n\n        $(node, '@this'); // Top of the stack ought to be the context\n        $(node, '@arguments');\n\n        const {minParamRequired, hasRest, paramBindingNames} = processFuncArgs(node);\n\n        $(node, '@body_start');\n\n        stmt(node.body);\n\n        log('The explicitReturns value for its body is:', [node.body.$z.explicitReturns]);\n        if (node.body.$z.explicitReturns !== 'yes') {\n          // Implicitly return `undefined`\n          $(node, '@push', 'undefined');\n          $(node, '@return');\n        }\n\n        let funcActions = actions;\n        actions = abak;\n\n        if (node.id) {\n          group('Function decl id:');\n          const uniqueName = findUniqueNameForBindingIdent(node.id, true);\n          groupEnd();\n\n          _$(node.id, '@binding', uniqueName, 'lex');\n        }\n        else store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'todo_export_default_without_name'); // I mean this'll just crash? :)\n\n        // For functions, focus on the `function` keyword\n        let funcToken = getFirstToken(node);\n        while (funcToken && (funcToken.str === 'export' || funcToken.str === 'default' || Tenko.isWhiteToken(funcToken.type))) {\n          funcToken = tokens[funcToken.n + 1];\n        }\n        ASSERT(funcToken.str === 'function', 'pretty sure this is an invariant', funcToken);\n        funcToken.tlog = [];\n\n\n        if (isExport) {\n          ASSERT(node.id, 'exported functions (not by default) must have an id as per syntax');\n          log('Registering as exported default value');\n          _$(node, '@export_as', isExport === true ? node.id.name : 'default');\n          _$(node, '@dup', '(exported func value)'); // Note: _$ is reverse order\n        }\n\n        const desc = 'Function<' + (node.id ? node.id.name : '<anon>') + ': line ' + node.loc.start.line + ', column ' + node.loc.start.column + '>';\n        _$(node, '@func', 'N' + node.$z.tid + '=' + (node.id ? node.id.name : 'anon'), node.id ? node.id.name : '', node.params.map(node => node.name), paramBindingNames, hasRest, minParamRequired, funcActions, 'decl', !!node.$z.thisAccess, node.$z.reachableNames, funcToken.n, filename, node.loc.start.column, node.loc.start.line, desc);\n\n        break;\n      }\n\n      case 'IfStatement': {\n        expr(node.test);\n        $(node, '@condition');\n\n        stmt(node.consequent);\n        if (node.alternate) stmt(node.alternate);\n\n        break;\n      }\n\n      case 'ImportDeclaration': {\n\n        const source = node.source;\n        ASSERT(typeof source.value === 'string', 'source should be a string', node);\n        ASSERT(typeof store.options.resolve === 'function' || store.options.resolve === undefined, 'resolve should be a func or unset', store.options);\n        const from = store.resolve(source.value, filename);\n\n        node.specifiers.forEach(snode => {\n          const local = snode.local;\n          ASSERT(local && local.type === 'Identifier', 'local should be an ident', snode);\n          const uniqueName = findUniqueNameForBindingIdent(local); // I dont think this is ever different, but w/e\n\n\n          switch (snode.type) {\n            case 'ImportDefaultSpecifier': {\n              // import x from 'y'\n              log('Importing the default export from `0' + from + '` as `' + local.name + '` (-> `' + uniqueName + '`)');\n              $(snode, '@import_binding', uniqueName, 'default', from);\n              break;\n            }\n            case 'ImportSpecifier': {\n              // import {x} from 'y'       // local === imported\n              // import {x,y,z} from 'y'   // will be three individual specifier nodes\n              // import {x as y} from 'y'\n\n              const imported = snode.imported;\n              ASSERT(imported && imported.type === 'Identifier', 'each specifier should have exactly one imported symbol', snode);\n              log('Importing the exported symbol `' + imported.name + '` from `' + from + '` as `' + local.name + '` (-> `' + uniqueName + '`)');\n              $(snode, '@import_binding', uniqueName, imported.name, from);\n              break;\n            }\n            case 'ImportNamespaceSpecifier': {\n              // import * as x from 'y'\n              log('Importing all exports from module `' + from + '` as an object in `' + local.name + '` (-> `' + uniqueName + '`)');\n              $(snode, '@import_star', uniqueName, from);\n              break;\n            }\n            default: {\n              ASSERT(false, 'fixme');\n            }\n          }\n        });\n\n        break;\n      }\n\n      case 'Program': {\n        node.body.forEach(node => stmt(node));\n        break;\n      }\n\n      case 'ReturnStatement': {\n        if (node.argument) expr(node.argument);\n        else $(node, '@push', 'undefined');\n        $(node, '@return'); // Assumes an (implicit or explicit) arg is pushed\n        break;\n      }\n\n      case 'TryStatement': {\n        stmt(node.block);\n        if (node.handler) {\n\n          if (node.handler.param) {\n            log('Processing catch clause');\n            // Catch clause is present. Register the binding.\n            ASSERT(node.handler.param.type === 'Identifier', 'todo catch clauses that are not idents', node.handler.param);\n            const uniqueName = findUniqueNameForBindingIdent(node.handler.param);\n            // This is a weakness in our model ... We may need to restrict what kind of values can be thrown. Or only\n            // allow the error object to be considered an instance of Error. We can disallow throwing anything else\n            // so that leaves built in errors and they all subclass Error, so Error is the common denominator.\n\n            // So here we will initialize the catch var as an Error instance and that's it.\n            $(node.handler.param, '@push', 'Error.prototype');\n            $(node.handler.param, '@obj', ['__proto__']);\n            // And this will be the init value of the binding\n            $(node.handler.param, '@binding', uniqueName, 'let'); // TODO: let? I think so :)\n          }\n          stmt(node.handler.body);\n        }\n        if (node.finalizer) {\n          stmt(node.finalizer);\n        }\n        break;\n      }\n\n      case 'SwitchStatement': {\n        expr(node.discriminant);\n        node.cases.forEach(cnode => {\n          // Defaults have no test\n          if (cnode.test) {\n            // All cases must have test for same type as discriminant (switch value)\n            expr(cnode.test);\n            $(cnode.test, '@merge'); // pop the test and the discriminant, merge them, result will be pushed to be the new discriminant. it is dropped later.\n          }\n          cnode.consequent.forEach(stmt);\n        });\n        $(node, '@drop'); // drop the discriminant\n        break;\n      }\n\n      case 'ThrowStatement': {\n        expr(node.argument);\n        $(node, '@drop');\n        break;\n      }\n\n      case 'VariableDeclaration': {\n        const kind = node.kind;\n        node.declarations.forEach(dnode => {\n          if (dnode.init) {\n            expr(dnode.init);\n          } else {\n            const pid = createPlaceholder(store, 'HB', 'binding `' + dnode.id ? dnode.id.name : '<destruct>' + '` without init');\n            linter.check('BINDING_NO_INIT', {filename, column: dnode.id.loc.start.column, line: dnode.id.loc.start.line}, dnode.id.name);\n            log('Created placeholder', tstr(pid), 'for the binding');\n            $(dnode, '@push', pid);\n          }\n\n          // The paramNode can be either an Identifier or a pattern of sorts\n          if (dnode.id.type === 'Identifier') {\n            // Simple case. Create the binding and be done.\n\n            log('Var decl id:');\n            const uniqueName = findUniqueNameForBindingIdent(dnode.id);\n\n            if (isExport) {\n              $(dnode, '@dup', '<exported binding decl>');\n              $(dnode, '@export_as', isExport === true ? uniqueName : 'default');\n            }\n\n            $(dnode, '@binding', uniqueName, kind);\n          } else if (dnode.id.type === 'ArrayPattern') {\n            // Complex case. Sort out the final param value vs default, then walk through the destructuring pattern.\n\n            if (isExport) store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'exported array pattern');\n\n            linter.check('ARRAY_PATTERN_UNSOUND', {filename, column: dnode.id.loc.start.column, line: dnode.id.loc.start.line});\n\n            // Next we are going to pushpop the top value recursively to process all parts of the pattern\n\n            dnode.id.elements.forEach(node => destructBindingArrayElement(node, kind));\n\n            $(dnode, '@drop'); // Drop the param array value. It should still be here and we don't need it anymore.\n          } else {\n            // Complex case. Sort out the final param value vs default, then walk through the destructuring pattern.\n\n            if (isExport) store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'exported object pattern');\n\n            ASSERT(dnode.id.type === 'ObjectPattern', 'fixme if else', dnode.id);\n\n            // Next we are going to pushpop the top value recursively to process all parts of the pattern\n\n            dnode.id.properties.forEach(ppnode => destructBindingObjectProp(ppnode, dnode.id, kind));\n\n            $(dnode, '@drop'); // Drop the param value. It should still be here and we don't need it anymore.\n          }\n\n        });\n        break;\n      }\n\n      case 'WhileStatement': {\n        expr(node.test);\n        $(node, '@condition');\n\n        stmt(node.body);\n\n        break;\n      }\n\n      default: {\n        log('unknown statement node:', node);\n        log('Missing support for stmt ' + node.type);\n        throw new Error('Missing support for stmt ' + node.type)\n      }\n    }\n\n    if (node.$scope || (node.type === 'TryStatement' && node.handler)) {\n      lexScopeStack.pop();\n      if (['Program', 'FunctionExpression', 'ArrowFunctionExpression', 'FunctionDeclaration'].includes(node.type)) {\n        rootScopeStack.pop();\n      }\n    }\n\n    groupEnd();\n  }\n  function expr(node, isMethod = false, isCallee = false, methodName = '') {\n    // Every call should take nothing from the stack and leave one type on the stack\n\n    group(DIM + 'expr(' + RESET + BLUE + node.type + RESET + DIM + ')' + RESET);\n\n    if (node.$scope) {\n      lexScopeStack.push(node);\n      if (['Program', 'FunctionExpression', 'ArrowFunctionExpression', 'FunctionDeclaration'].includes(node.type)) {\n        rootScopeStack.push(node);\n      }\n    }\n\n    switch (node.type) {\n      case 'ArrayExpression': {\n        if (node.elements.length === 0) {\n          log('Empty array, pushing a placeholder to the stack');\n\n          const pid = 'HEAK' + String(++store.uid); // placeholder id (holder, empty, array, kind)\n          store.set(pid, {_class: 'placeholder', tid: pid, type: 'H', props: new Map, seen: new Map, placeholder: true, alias: null});\n          log('Created a placeholder tee for kind:', tstr(pid));\n\n          $(node, '@push', pid);\n        } else {\n          for (let i=0; i<node.elements.length; ++i) {\n            const elNode = node.elements[i];\n            if (elNode.type === 'SpreadElement') {\n              // Special case spread because its behavior differs per parent case\n              expr(elNode.argument);\n              // Stack should now have an array and the owner array should have its kind merged like all other elements\n              $(node, '@kind', '<empty array literal>'); // Ignore if the array is empty... (in that case dup the stack)\n            } else {\n              expr(elNode);\n            }\n          }\n        }\n        $(node, '@arr', Math.max(1, node.elements.length));\n        break;\n      }\n\n      case 'AssignmentExpression': {\n\n        // Get the starting tokens;\n        // - left (either the property name or the binding ident)\n        // - operator (the first non-space token left of node.right\n        // - right (first token of the value being assigned)\n\n        const tokenOp = getPrevTokenPastGroupAndSpaces(node.right);\n        ASSERT(tokenOp.str.slice(-1) === '=', 'should have found the assign op', tokenOp);\n        tokenOp.tlog = [];\n\n        expr(node.right);\n\n        if (node.left.type === 'MemberExpression') {\n          if (node.left.computed) {\n            // No warning yet; this may be\n            // - an indexed array assignment\n            // - a primitve update\n            // - a object-as-map half-supported update\n            // Some warning will be shown by dyn_set\n            expr(node.left.object);\n            expr(node.left.property);\n            $(node, '@dyn_set', tokenOp.n);\n          } else {\n            expr(node.left.object);\n            $(node, '@set', node.left.property.name, tokenOp.n);\n          }\n        } else {\n          // TODO: patterns\n\n          const uniqueName = findUniqueNameForBindingIdent(node.left);\n          $(node, '@assign', uniqueName, node.operator, tokenOp.n);\n        }\n\n        break;\n      }\n\n      case 'ArrowFunctionExpression': {\n        let abak = actions;\n        actions = [];\n\n        $(node, '@log', 'start of arrow');\n\n        $(node, '@drop'); // Drop the context of the call. Arrows inherit this from their parent function.\n\n        const {minParamRequired, hasRest, paramBindingNames} = processFuncArgs(node);\n\n        $(node, '@body_start');\n\n        if (node.expression) {\n          expr(node.body);\n          $(node, '@return');\n        } else {\n          stmt(node.body);\n          log('The explicitReturns value for its body is:', [node.body.$z.explicitReturns]);\n          if (node.body.$z.explicitReturns !== 'yes') {\n            // Implicitly return `undefined`\n            $(node, '@push', 'undefined');\n            $(node, '@return');\n          }\n        }\n\n        let funcActions = actions;\n        actions = abak;\n\n        // For arrows, focus on the `=>` token. A little annoying since we have to skip an arbitrary header\n        // but we can use the body node as an offset and seek backwards to find the `=>` token.\n        // For method shorthands, we won't have an `=>` token but immediately find the `)` token. Need to figure out\n        // how to deal with that visually.\n        let funcToken = getFirstToken(node.body);\n        while (funcToken && funcToken.str !== '=>') {\n          funcToken = tokens[funcToken.n - 1];\n        }\n        ASSERT(funcToken && funcToken.str === '=>', 'pretty sure this is an invariant', funcToken);\n        funcToken.tlog = [];\n\n        const desc = 'Arrow<line ' + node.loc.start.line + ', column ' + node.loc.start.column + '>';\n        $(node, '@func', 'N' + node.$z.tid + '=arrow', '', node.params.map(node => node.name), paramBindingNames, hasRest, minParamRequired, funcActions, 'arrow', false, node.$z.reachableNames, funcToken.n, filename, node.loc.start.column, node.loc.start.line, desc);\n        break;\n      }\n\n      case 'BinaryExpression': {\n        log('Operator:', node.operator);\n\n        expr(node.left);\n        expr(node.right);\n\n        const tokenOp = getPrevTokenPastGroupAndSpaces(node.right);\n        ASSERT(tokenOp.str === node.operator, 'should have found the binary op', tokenOp);\n        tokenOp.tlog = [];\n        $(node, '@binop', node.operator, tokenOp.n); // Assumes two values on the stack but won't consume them\n\n        switch (node.operator) {\n          case '+': {\n            // Both sides have to be either a number or a string and equal to each other at this point\n            // Returns the same type.\n            $(node, '@plus');\n            break;\n          }\n          case '-': {\n            $(node, '@push', 'number');\n            $(node, '@merge');\n            $(node, '@merge');\n            $(node, '@drop'); // Don't care about the merged value, it always returns a number\n            $(node, '@push', 'number');\n            break;\n          }\n          case '==':\n          case '!=':\n            store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'weak comparison is bad and not implemented');\n            $(node, '@merge');\n            break;\n          case '===':\n          case '!==':\n            $(node, '@merge');\n            $(node, '@drop'); // Don't care about the merged value\n            $(node, '@push', 'boolean');\n            break;\n          case '<':\n          case '<=':\n          case '>':\n          case '>=':\n            // Merge left and right with number and return a boolean\n            $(node, '@push', 'number');\n            $(node, '@merge'); // must return a number\n            $(node, '@merge');\n            $(node, '@drop'); // Don't care about the merged value\n            $(node, '@push', 'boolean');\n            break;\n\n          case 'instanceof': {\n            // This model should conclusively determine the truth value of any `instanceof` expression\n            linter.check('INSTANCEOF_OBSOLETE', {filename, column: node.loc.start.column, line: node.loc.start.line});\n\n            // TODO: figure out the rules, proper\n            $(node, '@instanceof');\n\n            break;\n          }\n\n          case 'in': {\n            // This model should conclusively determine the truth value of any `in` expression\n            linter.check('IN_OBSOLETE', {filename, column: node.loc.start.column, line: node.loc.start.line});\n\n            // Require the lhs to be a string\n            expr(node.left);\n            $(node, '@push', 'string');\n            $(node, '@merge');\n\n            // TODO: figure out valid values of rhs. Probably have to verify that state in the @in callback\n            expr(node.right);\n            $(node, '@in', node);\n\n            break;\n          }\n\n          default:\n            // Merge left and right with number and return a number\n            $(node, '@push', 'number');\n            $(node, '@merge'); // Should return a number\n            $(node, '@merge'); // Should return a number\n            break;\n        }\n\n        break;\n      }\n\n      case 'CallExpression': {\n        log(DIM + 'Setting up call args' + RESET);\n        let spreadAt = -1; // If this call contained a spread, we have to verify it starts on-or-after the rest param, at runtime.\n        node.arguments.forEach((anode, i) => {\n          if (anode.type === 'SpreadElement') {\n            log('Spread in a call. Complicated because we can not know the array size in our model. Hence we can only support a handful of cases, mostly concerning this at the end of the arg list');\n            // TODO: we can do checks around the spread and see if they are the same type\n            // TODO: can ignore empty arrays (although is that really worth it in the real world?)\n            // For sound and completeness, we can only support a spread if it is covered in a rest param\n            // Since otherwise we wouldn't know whether to substitute the kind being spreaded, or undefined / default.\n            if (i !== 0) { // note: reversed order, so we expect rest to be index 0\n              // We currently can't reliably support a spread argument that is not at the tail of the argument list\n              // No need to check further at runtime.\n              linter.check('SPREAD_NOT_TAIL', {filename, column: anode.loc.start.column, line: anode.loc.start.line});\n            } else {\n              spreadAt = (node.arguments.length - 1) - i; // Note: list is reversed!\n            }\n            // Either way, get the kind, push it onto the stack for good measure...\n            expr(anode.argument);\n            $(node, '@kind', '<call spread arg>');\n          } else {\n            expr(anode)\n          }\n        });\n        log(DIM + 'Setting up callee to call' + RESET);\n        if (node.callee.type === 'Super') {\n          // Note: the extends of the class to which this constructor belongs is syntactically bound to this super()\n          log('This is a `super()` call');\n          const ownerFunction = superCallStack[superCallStack.length - 1];\n          ASSERT(ownerFunction && ownerFunction.superClass, 'parser should validate that a `super()` call is contained in an es6 constructor which must mean the owner class is extending a value', ownerFunction);\n          expr(ownerFunction.superClass); // put it on the stack\n          $(node, '@super_call', node.arguments.length, spreadAt);\n        } else {\n          log(DIM + 'Setting up call context' + RESET);\n          if (node.callee.type !== 'MemberExpression') $(node, '@push', 'undefined'); // in strict mode implicit context is undefined, not global\n          log('Putting the callee on the stack');\n          expr(node.callee, false, true);\n          log(DIM + 'Setting up call with ' + node.arguments.length + ' args' + RESET);\n          $(node, '@call', node.arguments.length, spreadAt);\n\n          getFirstToken(node).tlog = [];        }\n        break;\n      }\n\n      case 'ClassExpression': {\n        processClass(node, true, false);\n        break;\n      }\n\n      case 'ConditionalExpression': {\n        expr(node.test);\n        $(node, '@push', 'boolean');\n        $(node, '@merge'); // Merge condition with bool\n        $(node, '@drop'); // pop the bool\n        expr(node.consequent);\n        expr(node.alternate);\n        $(node, '@merge'); // Merge consequent with alternate (not with bool) and return it\n        break;\n      }\n\n      case 'FunctionExpression': {\n        log('isMethod:', isMethod);\n\n        let abak = actions;\n        actions = [];\n\n        $(node, '@log', 'start of func expr ' + (node.id ? node.id.name : '{anon}'));\n\n        if (node.id) {\n          // Oh fun, function expression id scoping\n          let has = false;\n          let scope = node.$scope;\n          ASSERT(scope.type === Tenko.SCOPE_LAYER_FUNC_BODY, 'please no 1', scope);\n          let names = scope.names;\n          if (names !== Tenko.HAS_NO_BINDINGS && names.has('shadowedFunction')) has = true;\n          scope = scope.parent;\n          ASSERT(scope.type === Tenko.SCOPE_LAYER_FUNC_PARAMS, 'please no 2', scope);\n          names = scope.names;\n          if (names !== Tenko.HAS_NO_BINDINGS && names.has('shadowedFunction')) has = true;\n          scope = scope.parent;\n          ASSERT(scope.type === Tenko.SCOPE_LAYER_FUNC_ROOT, 'please no 3', scope);\n          names = scope.names;\n          if (names !== Tenko.HAS_NO_BINDINGS && names.has('shadowedFunction')) has = true;\n          scope = scope.parent;\n          ASSERT(scope.type === Tenko.SCOPE_LAYER_GLOBAL, 'please no 4', scope);\n\n          if (has) {\n            log('The func expr name was shadowed by a param name or local var, ignoring it');\n            linter.check('FUNC_EXPR_NAME_SHADOW', {filename, column: node.id.loc.start.column, line: node.id.loc.start.line});\n          } else {\n            // Ok, the func expr had a name the name was not shadowed, record it\n            log('Making sure the func name gets bound properly');\n            // Specific hack because we won't have access to the 'current\" func instance otherwise\n            log('Function param id:');\n            const uniqueName = findUniqueNameForBindingIdent(node.id);\n            $(node, '@func_expr_name', uniqueName);\n          }\n        } else if (isMethod) {\n          log('Function expression is a method with key: `' + methodName + '`');\n          ASSERT(methodName, 'all methods have a key', methodName); // TODO: What about computed keys?\n        } else {\n          log('Function expression has no name');\n        }\n\n        $(node, '@binding', 'this', 'lex'); // Top of the stack ought to be the context for this call\n        $(node, '@push', 'number');\n        $(node, '@obj', ['length']); // Create the arguments object and put it on the stack\n        $(node, '@binding', 'arguments', 'lex');\n\n        const {minParamRequired, hasRest, paramBindingNames} = processFuncArgs(node);\n\n        $(node, '@body_start');\n\n        stmt(node.body);\n\n        log('The explicitReturns value for its body is:', [node.body.$z.explicitReturns]);\n        if (node.body.$z.explicitReturns !== 'yes') {\n          // Implicitly return `undefined`\n          $(node, '@push', 'undefined');\n          $(node, '@return');\n        }\n\n        let funcActions = actions;\n        actions = abak;\n\n        // For functions, focus on the `function` keyword\n        let funcToken = getFirstToken(node);\n        funcToken.tlog = [];\n\n        const debugName = (isMethod ? methodName : node.id ? node.id.name : '<anon>');\n        const desc = (isMethod ? 'Method' : 'Function') + '<' + debugName + ': line ' + node.loc.start.line + ', column ' + node.loc.start.column + '>';\n        $(node, '@func', 'N' + node.$z.tid + '=' + debugName, node.id ? node.id.name : '', node.params.map(node => node.name), paramBindingNames, hasRest, minParamRequired, funcActions, isMethod ? 'method' : 'expr', !!node.$z.thisAccess, node.$z.reachableNames, funcToken.n, filename, node.loc.start.column, node.loc.start.line, desc);\n        break;\n      }\n\n      case 'Identifier': {\n        const uniqueName = findUniqueNameForBindingIdent(node);\n        log('Queueing lookup for `' + uniqueName + '`');\n        $(node, '@ident', uniqueName);\n\n        getFirstToken(node).tlog = [];\n        break;\n      }\n\n      case 'Literal': {\n        if (typeof node.value === 'string') {\n          $(node, '@push', 'string');\n        } else if (typeof node.value === 'number') {\n          $(node, '@push', 'number');\n        } else if (typeof node.value === 'boolean') {\n          $(node, '@push', 'boolean');\n        } else if (node.regex !== undefined) {\n          $(node, '@push', 'RegExp.prototype');\n          $(node, '@obj', ['__proto__']);\n        } else if (node.value === null) {\n          $(node, '@push', 'null');\n        } else {\n          log('Missing support for literal', node);\n          store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'unknown literal type');\n        }\n        break;\n      }\n\n      case 'LogicalExpression': {\n        // The operands of the logical expression (&& and ||) are expected to be bool, even though JS doesn't care\n        // They return whichever value is truthy, which is impossible for the model to determine, so we return boolean\n\n        // Technically both sides ought to be bools. But for hte model, at least they ought to be the same type.\n        // The operator will return that type (not bool), so check for bool but don't automatically return it.\n\n        expr(node.left);\n        expr(node.right);\n\n        const tokenOp = getPrevTokenPastGroupAndSpaces(node.right);\n        ASSERT(tokenOp.str === node.operator, 'should have found the binary op', tokenOp);\n        tokenOp.tlog = [];\n        $(node, '@binop', node.operator, tokenOp.n); // Assumes two values on the stack but won't consume them\n\n        $(node, '@logical', node.operator);\n        break;\n      }\n\n      case 'MemberExpression': {\n        const nameStack = [];\n        const dynaStack = [];\n        function r(node) {\n          if (node.type === 'MemberExpression') {\n            if (node.computed) {\n              // All bets are off now. We cannot support this completely (though we could support _some_ cases).\n              // We'll now unconditionally attempt to treat the access as an indexed array access (we can refine checks\n              // for this). So do a @kind and if that fails too, it will return an `undefined`, otherwise it'll work\n              // as intended.\n              log('Dynamic property access. Last ditch effort: attempting to get the kind of an array or treat plain object as map');\n              dynaStack.push(true);\n              nameStack.push(node.property);\n              r(node.object);\n            } else {\n              dynaStack.push(false);\n              nameStack.push(node.property);\n              r(node.object);\n            }\n          } else if (node.type === 'Super') {\n            log('This is a `super.prop` property');\n            // The instance that owns the method containing this super prop can be found at the top of store.get('#superStack')\n            $(node, '@super_prop'); // Root object\n          } else {\n            expr(node); // Root object\n          }\n        }\n        r(node);\n\n        while (nameStack.length > 0) {\n          const wasDynamic = dynaStack.pop();\n          const nameNode = nameStack.pop();\n\n          if (nameStack.length === 0 && isCallee) {\n            // The top address is now the callee. We want to get a method from it (consumes top)\n            // AND use it as context for the call (also consumes top), so dupe it here\n            $(node, '@dup', '<top is called and serves as context>');\n          }\n\n          if (wasDynamic) { // Dynamic property access; trying to get the kind of the array as the \"get\", or kind of object-as-map\n            expr(nameNode);\n            $(nameNode, '@dyn_get', nameStack.length);\n          } else {\n            ASSERT(nameNode && nameNode.type === 'Identifier', 'the stack should contain ident nodes or zeroes', nameNode);\n            $(nameNode, '@get', nameNode.name);\n            getFirstToken(nameNode).tlog = [];\n          }\n        }\n        break;\n      }\n\n      case 'NewExpression': {\n        let spreadAt = -1; // see CallExpression\n        log(DIM + 'Setting up `new` args' + RESET);\n\n        node.arguments.forEach((node, i) => {\n          if (node.type === 'SpreadElement') {\n            log('Spread in a `new`. Complicated because we can not know the array size in our model. Hence we can only support a handful of cases, mostly concerning this at the end of the arg list');\n            // TODO: we can do checks around the spread and see if they are the same type\n            // TODO: can ignore empty arrays (although is that really worth it in the real world?)\n            // For sound and completeness, we can only support a spread if it is covered in a rest param\n            // Since otherwise we wouldn't know whether to substitute the kind being spreaded, or undefined / default.\n            if (i !== 0) { // note: reversed order, so we expect rest to be index 0\n              // We currently can't reliably support a spread argument that is not at the tail of the argument list\n              // No need to check further at runtime.\n              linter.check('SPREAD_NOT_TAIL', {filename, column: node.loc.start.column, line: node.loc.start.line});\n            } else {\n              spreadAt = i;\n            }\n            // Either way, get the kind, push it onto the stack for good measure...\n            expr(node.argument);\n            $(node, '@kind', '<spread arg>');\n          } else {\n            expr(node)\n          }\n        });\n\n        expr(node.callee);\n        $(node, '@new', node.arguments.length, spreadAt);\n        break;\n      }\n\n      case 'ObjectExpression': {\n        $(node, '@obj', []);\n\n        $(node, '@super_stack_push'); // Make the object reference available to any methods that use super properties\n\n        const spreads = [];\n        node.properties.forEach(pnode => {\n          if (pnode.type === 'SpreadElement') {\n            expr(pnode.argument);\n            spreads.push(true);\n          } else {\n            ASSERT(pnode.type === 'Property', 'fixmeifnot', pnode);\n            ASSERT(!pnode.computed, 'computed prop wot?', pnode);\n            ASSERT(pnode.key.type === 'Identifier' || pnode.key.type === 'Literal', 'prop key should be ident or num/str', pnode);\n\n            ASSERT(pnode.value);\n            expr(pnode.value, pnode.method ? 'method' : '', false, pnode.method ? (pnode.key.type === 'Identifier' ? pnode.key.name : String(pnode.key.value)) : undefined);\n            spreads.push(false);\n          }\n        });\n\n        $(node, '@super_stack_pop');\n\n        $(node, '@obj_init', node.properties.map(node => node.type === 'Property' ? (node.key.type === 'Identifier' ? node.key.name : String(node.key.value)) : '<spread>').reverse(), spreads);\n\n        break;\n      }\n\n      case 'RegExpLiteral': {\n        $(node, '@regex');\n        break;\n      }\n\n      case 'SequenceExpression': {\n        node.expressions.forEach((enode, i) => {\n          group('Sequence part', (i + 1), '/', node.expressions.length);\n          expr(enode);\n          if (i < node.expressions.length - 1) {\n            log('This is not the last value in the sequence so dropping it');\n            // Only keep the last expression value on the stack. The rest is discarded.\n            $(node, '@drop');\n          } else {\n            log('This is the last value in the sequence so that is what it returns');\n          }\n          groupEnd();\n        });\n        break;\n      }\n\n      case 'Super': {\n        // Two cases:\n        // - call\n        // - prop\n        // The call is syntactically restricted to es6 constructors of classes that extend _something_. That something\n        // is only checked at runtime, and so `super` is only resolved at runtime as well.\n        // The prop can occur in any class method or object method. This usage is syntactically restircted to the\n        // method shorthand syntax and its reference is bound to the initial object of its __proto__. That bond cannot\n        // be broken or changed in JS (unlike call, which is an indirect lookup).\n\n        // This handler is a noop because the MemberExpression and CallExpression handlers should handle super\n        break;\n      }\n\n      case 'TemplateLiteral': {\n        node.expressions.forEach(node => {\n          expr(node);\n          $(node, '@lint-inv', 'string', 'TEMPLATE_EXPR_STRING');\n          $(node, '@drop'); // TODO: if not string, resolve the .toString/.valueOf as JS would, etc.\n        });\n\n        $(node, '@push', 'string');\n        break;\n      }\n\n      case 'ThisExpression': {\n        // It's a hack but since you can't declare a local binding named `this`, we can get away with it.\n        log('Queueing lookup explicitly for `this`');\n        $(node, '@ident', 'this');\n        getFirstToken(node).tlog = [];\n        break;\n      }\n\n      case 'UnaryExpression': {\n        log('Operator:', node.operator);\n\n        expr(node.argument);\n\n        switch (node.operator) {\n          case 'delete': {\n            store.linter.check('DELETE_MEH', {filename, column: node.loc.start.column, line: node.loc.start.line});\n            $(node, '@drop');\n            $(node, '@push', 'boolean');\n            break;\n          }\n\n          case '+':\n          case '-':\n          case '~': {\n            $(node, '@push', 'number');\n            $(node, '@merge');\n            break;\n          }\n\n          case '!': {\n            $(node, '@push', 'boolean');\n            $(node, '@merge');\n            break;\n          }\n\n          case 'typeof': {\n            // Trick question ;)\n            $(node, '@drop');\n            $(node, '@push', 'string');\n            break;\n          }\n\n          case 'void': {\n            $(node, '@drop');\n            $(node, '@push', 'undefined');\n            break;\n          }\n\n          default: {\n            store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'unknown unary op');\n          }\n        }\n\n        break;\n      }\n\n      case 'UpdateExpression': {\n        // TODO: there is a subtle difference between prefix and postfix that we can catch as a nice gimmick\n        expr(node.argument);\n        $(node, '@push', 'number');\n        $(node, '@merge');\n        break;\n      }\n\n      default: {\n        log('unknown expression node:', node);\n        throw new Error('Missing support for expr ' + node.type)\n      }\n    }\n\n    if (node.$scope) {\n      lexScopeStack.pop();\n      if (['Program', 'FunctionExpression', 'ArrowFunctionExpression', 'FunctionDeclaration'].includes(node.type)) {\n        rootScopeStack.pop();\n      }\n    }\n\n    groupEnd();\n  }\n\n  function processClass(node, isExpr, isExport) {\n    superCallStack.push(node);\n\n    // Put the `extends` expression on the stack, or an actual `null` to signify there wasn't any\n    if (node.superClass) expr(node.superClass);\n    else $(node, '@push', NO_SUPER_VALUE);\n\n    // Track the total number of methods, static or proto, because they will be put on the stack mixed\n    let methodTypes = [];\n    let methodNames = [];\n\n    if (node.body.body.length > 0) {\n      $(node, '@super_stack_push'); // Put the proto object reference onto a proto stack while we parse out the methods\n\n      log('Processing', node.body.body.length, 'potential methods');\n      node.body.body.forEach(node => {\n        if (!node) return; // possible\n        ASSERT(node.type === 'MethodDefinition', 'expand once class syntax is not just method definitions');\n        const methodName = (node.key ? node.key.name : '<??>');\n        log('- ' + (methodTypes.length + 1) + ': a ' + (node.static ? 'static' : 'proto') + ' method: `' + methodName + '`');\n\n        if (node.computed) {\n          linter.check('CLASS_COMPUTED_METHOD', {filename, column: node.loc.start.column, line: node.loc.start.line});\n        }\n\n        ASSERT(node.key && node.key.type === 'Identifier', 'if the method is not dynamic, the key must exist and must be an ident', node);\n        ASSERT(node.value.type === 'FunctionExpression', 'for now, method values are func expr nodes');\n\n        // TODO: constructor path\n        // TODO: tag as methods, perhaps the class can patch that up for us... we also need to know which methods are static\n        expr(node.value, 'method', false, methodName);\n\n        methodNames.push(node.key.name);\n        methodTypes.push(node.static ? 'static' : 'proto');\n      });\n\n      $(node, '@super_stack_pop'); // Bring the proto object back to the stack to serve as a stack arg to @class\n    }\n\n    // Put the future prototype object on the stack.\n    $(node, '@obj', []);\n\n    const desc = 'Class<' + (node.id ? node.id.name : '<anon>') + ': line ' + node.loc.start.line + ', column ' + node.loc.start.column + '>';\n    $(node, '@class', 'N' + node.$z.tid + '=' + (node.id ? node.id.name : 'anon'), node.id ? node.id.name : '', methodTypes.reverse(), methodNames.reverse(), desc);\n\n    if (isExport) {\n      ASSERT(node.id, 'exported classes (not by default) must have an id as per syntax');\n      $(node, '@dup');\n      $(node, '@export_as', isExport === true ? node.id.name : 'default');\n    }\n\n    if (isExpr) {\n      // TODO: how do we best model the class expression id being accessible inside the class? fake an arrow?\n      if (node.id) store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'class expression id is a small scoping nightmare. just skip tests with a class expr id; not a vital path to cover atm');\n    } else {\n      if (node.id) {\n        log('Class id:');\n        const uniqueName = findUniqueNameForBindingIdent(node.id);\n        $(node, '@binding', uniqueName, 'lex');\n      } else {\n        store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'exported class as a default has no name');\n      }\n    }\n\n    superCallStack.pop();\n  }\n\n  function processFuncArgs(node) {\n    $(node, '@log', '### <function param setup> ###');\n\n    let minParamRequired = 0; // Ends up as the last non-rest param without default, +1\n    let hasRest = false;\n    let paramBindingNames = []; // Includes names inside pattern\n\n    group('Compiling params');\n    node.params.forEach((pnode, i) => {\n      // The rest param can not have a default so check that one first\n      if (pnode.type === 'RestElement') {\n        log('- param', i, 'is a rest');\n        ASSERT(i === node.params.length - 1, 'rest must be last element');\n        // - Rest cannot have a default, but must be an array\n        // - Do not increment min req count for the rest.\n        // - The top of the stack should be the _kind_ (not the actual array) of the rest array. It may be null,\n        //   in that case there were not enough args to also cover the rest param. (Or, somehow the kind of an\n        //   empty array leaked into it ...)\n        $(pnode, '@arr', 1);\n        ASSERT(pnode.argument.type === 'Identifier', 'fixme for non-ident rest params', pnode);\n        hasRest = true;\n\n        $(pnode, '@push', NO_DEFAULT_VALUE); // Ignore the default. Rest doesn't have it.\n\n        // The name may not match, for example a func expr with the same name as one of its args\n        const uniqueName = findUniqueNameForBindingIdent(pnode.argument);\n        $(pnode, '@param_binding', uniqueName);\n        paramBindingNames.push(uniqueName);\n      } else {\n        // Now there's basically two states: a param with a default or without a default. The params with a default\n        // have an node that is basically \"boxed\" into an AssignmentPattern. Put the right value on the stack and\n        // continue to process the left value. Otherwise, put null on the stack and process the node itself.\n\n        let paramNode = pnode;\n        if (pnode.type === 'AssignmentPattern') {\n          log('- param', i, 'has a default');\n          ASSERT(pnode.left.type === 'Identifier' || pnode.left.type === 'ObjectPattern' || pnode.left.type === 'ArrayPattern', 'fixme if different', pnode.left);\n          // Put right on the stack as the param default, continue to process left\n          expr(pnode.right);\n          paramNode = pnode.left;\n        } else {\n          minParamRequired = i + 1;\n          log('- param', i, 'has no default, min args now at:', minParamRequired);\n          // Put null on the stack, to signify no param default, and continue to process this node\n          $(pnode, '@push', NO_DEFAULT_VALUE);\n          // Need at least this many args\n        }\n\n        // The paramNode can be either an Identifier or a pattern of sorts\n        if (paramNode.type === 'Identifier') {\n          // Simple case. Create the param binding and be done.\n\n          // The name may not match, for example a func expr with the same name as one of its args\n          const uniqueName = findUniqueNameForBindingIdent(paramNode);\n          $(pnode, '@param_binding', uniqueName);\n          paramBindingNames.push(uniqueName);\n        } else if (paramNode.type === 'ArrayPattern') {\n          // Complex case. Sort out the final param value vs default, then walk through the destructuring pattern.\n\n          linter.check('ARRAY_PATTERN_UNSOUND', {filename, column: paramNode.loc.start.column, line: paramNode.loc.start.line});\n\n          $(pnode, '@defaults');\n\n          // Next we are going to pushpop the top value recursively to process all parts of the pattern\n\n          paramNode.elements.forEach(n => processArrayPatternElement(n, paramBindingNames));\n\n          $(pnode, '@drop'); // Drop the param array value. It should still be here and we don't need it anymore.\n        } else {\n          // Complex case. Sort out the final param value vs default, then walk through the destructuring pattern.\n\n          ASSERT(paramNode.type === 'ObjectPattern', 'fixme if else', paramNode);\n\n          $(pnode, '@defaults');\n\n          // Next we are going to pushpop the top value recursively to process all parts of the pattern\n\n          paramNode.properties.forEach(pnode => processObjectPatternProp(pnode, paramNode, paramBindingNames));\n\n          $(pnode, '@drop'); // Drop the param value. It should still be here and we don't need it anymore.\n        }\n      }\n    });\n    log('Min args now at:', minParamRequired);\n    groupEnd();\n\n    $(node, '@log', '### </function param setup> ###');\n\n    return {minParamRequired, hasRest, paramBindingNames};\n  }\n  function processArrayPatternElement(node, paramBindingNames) {\n    // The top of the stack ought to be the _array_ whose elements is being processed and they should all\n    // resolve to the same type as the `kind` of the array.\n    // Note: This call should not modify the stack before/after.\n\n    $(node, '@dup'); // Leave the array on the stack\n    $(node, '@kind', '<array pattern element>'); // Get the kind of the arr that should be on top right now.\n\n    // `enode` is one element of the array. If the element had a default, apply that logic now\n    let enode = node;\n    if (node.type === 'AssignmentPattern') {\n      expr(node.right);\n      enode = node.left;\n    } else {\n      $(node, '@push', NO_DEFAULT_VALUE);\n    }\n\n    $(node, '@defaults');\n\n    // The top of the stack should now be the type of the element currently being processed. It is either\n    // the kind of the array of which this element is a part of, or if that is `undefined` it is the\n    // default if the element has any;\n    // - f(['x']) function f([a=1]){}  -> a is type string\n    // - f([]) function f([a=1]){}     -> a is type number\n    // - f() function f([a=1]){}       -> error (lint warnings)\n\n    if (enode.type === 'ObjectPattern') {\n      // Top of stack must now be object. Process it recursively then drop it.\n      enode.properties.forEach(e => processObjectPatternProp(e, enode, paramBindingNames));\n      $(node, '@drop');\n    } else if (enode.type === 'ArrayPattern') {\n      // Top of stack must now be array. Process it recursively then drop it.\n      enode.elements.forEach(n => processArrayPatternElement(n, paramBindingNames));\n      $(node, '@drop');\n    } else if (enode.type === 'RestElement') {\n      ASSERT(enode.argument.type === 'Identifier', 'fixme if different', enode); // This can be an arr/obj pattern, too\n      // Assume that the array gets the same kind as the array being spread from\n      $(node, '@arr', 1); // \"1 arg\". The kind is shared and assumed not to be undefined.\n\n      // The name may not match, for example a func expr with the same name as one of its args\n      const uniqueName = findUniqueNameForBindingIdent(enode.argument);\n      // Now create a binding with the property value onto this name\n      $(node, '@binding', uniqueName, 'var');\n      paramBindingNames.push(uniqueName);\n    } else {\n      ASSERT(enode.type === 'Identifier', 'fixme if different', enode);\n\n      // The name may not match, for example a func expr with the same name as one of its args\n      const uniqueName = findUniqueNameForBindingIdent(enode);\n      // Now create a binding with the property value onto this name\n      $(node, '@binding', uniqueName, 'var');\n      paramBindingNames.push(uniqueName);\n    }\n  }\n  function processObjectPatternProp(node, objNode, paramBindingNames) {\n    // The top of the stack ought to be the _obj_ whose properties are being processed and they should all\n    // resolve to properties of this object. Current call processed one such property node.\n    // Note: This call should not modify the stack before/after.\n\n    ASSERT(node.type === 'Property' || node.type === 'ObjectPattern' || node.type === 'RestElement', 'fixme for other types', node);\n\n    // Note: If there is a default, the .value will be an AssignmentPattern:\n    // {x}\n    // {x:y}\n    // {x=z}\n    // {x:y=z}\n\n    if (node.type === 'RestElement') {\n      // A rest element does not have a key/value property like other property nodes do\n      ASSERT(node.argument.type === 'Identifier', 'fixme if different', node); // This can be an arr/obj pattern, too\n\n      // Rest is more difficult because you have take the input object, eliminate all properties that are\n      // explicitly checked, then take the resulting set of properties and construct a new object with that\n\n      const unusedNames = objNode.properties.map(pnode => {\n        if (pnode.type === 'Property') {\n          if (pnode.computed) {\n            linter.check('DYNAMIC_PROP_ACCESS', {filename, column: pnode.loc.start.column, line: pnode.loc.start.line}, 'destructuring');\n\n            store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'destructuring dynamic property stuff'); // check how to make dyn_prop stuff work when destructuring\n\n            // We may be able to salvage this, tentatively and under protest, if this is a plain object and all props have the same tid\n            expr(pnode.property);\n            // The action should assert the property on the stack to be a string or number, then discard it\n            // If the object is a plain object (type='o') and it has a non-false .kind, then return that kind. Otherwise return undefined.\n            $(pnode, '@dyn_prop');\n\n            return null;\n          }\n          ASSERT(pnode.key.type === 'Identifier');\n          return pnode.key.name;\n        } else {\n          ASSERT(pnode.type === 'RestElement');\n          return null;\n        }\n      }).filter(Boolean);\n\n      $(node, '@objrest', [...unusedNames, '__proto__']); // proto appears not to be copied regardless\n\n      // The name may not match, for example a func expr with the same name as one of its args\n      const uniqueName = findUniqueNameForBindingIdent(node.argument);\n      // Now create a binding with the property value onto this name\n      $(node, '@binding', uniqueName, 'var');\n      paramBindingNames.push(uniqueName);\n    } else {\n      ASSERT(node.key.type === 'Identifier', 'fixme for other key types', node.key);\n      ASSERT(node.value.type === 'Identifier' || node.value.type === 'AssignmentPattern' || node.value.type === 'ObjectPattern' || node.value.type === 'ArrayPattern', 'fixme for other value types', node.value);\n\n      const knode = node.key;\n\n      // Get the property from the top of the stack (but leave the object as well for the next iteration)\n      $(node, '@dup');\n      $(knode, '@get', knode.name, node.value.type === 'AssignmentPattern');\n      getFirstToken(knode).tlog = [];\n\n      // The prop name is not relevant at this point (the prop was fetched and is on top of the stack)\n      // Put the default on the stack, prepare the actual value node (binding ident/obj/arr)\n      let vnode = node.value;\n      if (vnode.type === 'AssignmentPattern') {\n        expr(vnode.right);\n        vnode = vnode.left;\n      } else {\n        $(node, '@push', NO_DEFAULT_VALUE);\n      }\n\n      $(node, '@defaults');\n\n      if (vnode.type === 'ObjectPattern') {\n        // Top of stack must now be object. Process it recursively then drop it.\n        vnode.properties.forEach(pnode => processObjectPatternProp(pnode, vnode, paramBindingNames));\n        $(node, '@drop');\n      } else if (vnode.type === 'ArrayPattern') {\n        // Top of stack must now be array. Process it recursively then drop it.\n        vnode.elements.forEach(n => processArrayPatternElement(n, paramBindingNames));\n        $(node, '@drop');\n      } else {\n        ASSERT(vnode.type === 'Identifier', 'fixme if different value', vnode);\n        // Doesn't matter whether it's shorthand or not; the binding name is in the value node\n\n        // The name may not match, for example a func expr with the same name as one of its args\n        const uniqueName = findUniqueNameForBindingIdent(vnode);\n        // Now create a binding with the property value onto this name\n        $(node, '@binding', uniqueName, 'var');\n        paramBindingNames.push(uniqueName);\n      }\n    }\n  }\n\n  function destructBindingObjectProp(pnode, objNode, kind) {\n    ASSERT(objNode && typeof objNode === 'object');\n\n    // Can't be assignment on the toplevel (that'd be the decl init)\n    if (pnode.type === 'Property') {\n\n      // let {x} = obj\n      // -> prop will have key and value be the same Identifier\n      // let {x = z} = obj\n      // -> prop will have key ident, value be assignment of some rhs to an Identifier with same value as key\n      // let {x: y} = obj\n      // -> key and value will be different Identifiers\n      // let {x: y = z} = obj\n      // -> key is Identifier and value is assignment with rhs to different Identifier than key\n\n      if (pnode.computed) {\n        // let {[x]: y} = obj\n        linter.check('DYNAMIC_PROP_ACCESS', {filename, column: pnode.loc.start.column, line: pnode.loc.start.line}, 'destructuring2');\n\n        store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'destructuring dynamic property stuff'); // Check how to make this dyn_prop stuff work for destructuring\n\n        // We may be able to salvage this, tentatively and under protest, if this is a plain object and all props have the same tid\n        expr(pnode.property);\n        // The action should assert the property on the stack to be a string or number, then discard it\n        // If the object is a plain object (type='o') and it has a non-false .kind, then return that kind. Otherwise return undefined.\n        $(pnode, '@dyn_prop');\n\n        return;\n      }\n\n      ASSERT(pnode.key.type === 'Identifier', 'fixme if else', pnode.key);\n\n      $(pnode, '@dup');\n      $(pnode.key, '@get', pnode.key.name, pnode.value.type === 'AssignmentPattern');\n      getFirstToken(pnode.key).tlog = [];\n\n      // Top of the stack should be object being destructured.\n      // Value is an Identifier, AssignmentPattern, ObjectPattern, or ArrayPattern. Assignment can nest the other three.\n      // Since this path can still require a property lookup on the object on the top of the stack, we'll need to\n      // unbox the AssignmentPattern step-by-step, rather than generically. (Because we need to do default.) Very sad.\n\n      if (pnode.value.type === 'Identifier') {\n        // No default\n        // let {x} = obj\n        // let {x:y} = obj\n        log('Pattern piece id:');\n        const uniqueName = findUniqueNameForBindingIdent(pnode.value);\n        $(pnode, '@binding', uniqueName, kind);\n      } else if (pnode.value.type === 'ObjectPattern') {\n        // let {x: {x}} = obj\n        pnode.value.properties.forEach(ppnode => destructBindingObjectProp(ppnode, pnode.value, kind));\n        $(pnode, '@drop'); // Drop the param value. It should still be here and we don't need it anymore.\n      } else if (pnode.value.type === 'ArrayPattern') {\n        // let {x: [x]} = obj\n        linter.check('ARRAY_PATTERN_UNSOUND', {filename, column: pnode.loc.start.column, line: pnode.loc.start.line});\n        pnode.value.elements.forEach(node => destructBindingArrayElement(node, kind));\n        $(pnode, '@drop'); // Drop the param value. It should still be here and we don't need it anymore.\n      } else {\n        ASSERT(pnode.value.type === 'AssignmentPattern', 'fixme if else', pnode.value); // patterns?\n        ASSERT(pnode.value.left.type === 'Identifier', 'left is ident', pnode);\n\n        // let {x = z} = obj\n        // let {x: y = z} = obj\n        // let {x: {x} = z} = obj\n        // let {x: [x] = z} = obj\n\n        let vnode = pnode.value.left;\n\n        // Top of the stack is property obj.x\n        // Next we can get the default value (the rhs of the assignment pattern) and run a defaults\n        expr(pnode.value.right);\n        $(pnode, '@defaults');\n\n        // Top of the stack is now the value to destructure/bind, the second is the parent object\n\n        if (vnode.type === 'Identifier') {\n          // No default\n          // let {x} = obj\n          // let {x:y} = obj\n\n          log('Pattern piece id:');\n          const uniqueName = findUniqueNameForBindingIdent(vnode);\n          $(pnode, '@binding', uniqueName, kind);\n        } else if (vnode.value.type === 'ObjectPattern') {\n          // let {x: {x}} = obj\n          pnode.value.properties.forEach(ppnode => destructBindingObjectProp(ppnode, pnode.value, kind));\n          $(pnode, '@drop'); // Drop the param value. It should still be here and we don't need it anymore.\n        } else if (vnode.value.type === 'ArrayPattern') {\n          // let {x: [x]} = obj\n          linter.check('ARRAY_PATTERN_UNSOUND', {filename, column: vnode.loc.start.column, line: vnode.loc.start.line});\n          pnode.value.elements.forEach(node => destructBindingArrayElement(node, kind));\n          $(pnode, '@drop'); // Drop the param value. It should still be here and we don't need it anymore.\n        } else {\n          ASSERT(false, 'fixme for other nodes', vnode);\n        }\n      }\n    } else if (pnode.type === 'RestElement') {\n      const unusedNames = objNode.properties.map(pnode => {\n        if (pnode.type === 'Property') {\n          if (pnode.computed) {\n            linter.check('DYNAMIC_PROP_ACCESS', {filename, column: pnode.loc.start.column, line: pnode.loc.start.line}, 'destructuring3');\n\n            store.linter.check('TOFIX', {filename, column: node.loc.start.column, line: node.loc.start.line}, 'destructuring dynamic property stuff'); // check how to make dyn_prop stuff work for destructuring\n\n            // We may be able to salvage this, tentatively and under protest, if this is a plain object and all props have the same tid\n            expr(pnode.property);\n            // The action should assert the property on the stack to be a string or number, then discard it\n            // If the object is a plain object (type='o') and it has a non-false .kind, then return that kind. Otherwise return undefined.\n            $(pnode, '@dyn_prop');\n\n            return null;\n          }\n          ASSERT(pnode.key.type === 'Identifier');\n          return pnode.key.name;\n        } else {\n          ASSERT(pnode.type === 'RestElement');\n          return null;\n        }\n      }).filter(Boolean);\n\n      $(pnode, '@objrest', [...unusedNames, '__proto__']); // proto appears not to be copied regardless\n\n      ASSERT(pnode.argument.type === 'Identifier', 'rest arg is ident or fixme', pnode.argument);\n      const uniqueName = findUniqueNameForBindingIdent(pnode.argument);\n      $(pnode, '@binding', uniqueName, kind);\n    } else {\n      ASSERT(false, 'fixme', pnode);\n    }\n  }\n  function destructBindingArrayElement(pnode, kind) {\n    // Can't be assignment on the toplevel (that'd be the decl init)\n\n    $(pnode, '@dup');\n    $(pnode, '@kind', '<array binding pattern>');\n\n    let enode = pnode;\n    if (pnode.type === 'AssignmentPattern') {\n      expr(pnode.right);\n      enode = pnode.left;\n      $(pnode, '@defaults');\n    } else {\n      // $(pnode, '@push', NO_DEFAULT_VALUE);\n      // $(pnode, '@defaults');\n    }\n\n\n    if (enode.type === 'Identifier') {\n      // No init\n      // $(pnode, '@push', NO_DEFAULT_VALUE);\n      // $(pnode, '@defaults'); // If value is undefined and there is a default, use default, otherwise if there is a default, validate it against the value. Leave either on the stack.\n      log('Pattern piece id:');\n      const uniqueName = findUniqueNameForBindingIdent(enode);\n      $(pnode, '@binding', uniqueName, kind);\n    } else if (enode.type === 'ObjectPattern') {\n      enode.properties.forEach(ppnode => destructBindingObjectProp(ppnode, enode, kind));\n      $(pnode, '@drop'); // Drop the param value. It should still be here and we don't need it anymore.\n    } else if (enode.type === 'ArrayPattern') {\n      linter.check('ARRAY_PATTERN_UNSOUND', {filename, column: enode.loc.start.column, line: enode.loc.start.line});\n      enode.elements.forEach(node => destructBindingArrayElement(node, kind));\n      $(pnode, '@drop'); // Drop the param value. It should still be here and we don't need it anymore.\n    } else if (pnode.type === 'RestElement') {\n      ASSERT(pnode.argument.type === 'Identifier', 'fixme if else', pnode.argument);\n      // While it could share the type, in theory it's a fresh reference, which is relevant for tracking\n      // own properties, so we create a fresh array type for it.\n      $(pnode, '@arr', 1);\n      // Cannot have initializer. Set to input array because why not.\n      const uniqueName = findUniqueNameForBindingIdent(pnode.argument);\n      $(pnode, '@binding', uniqueName, kind);\n    } else {\n      ASSERT(false, 'fixme if else', enode);\n    }\n  }\n}\n","~/proj/zetype/src/phase3.mjs":"\n/*\n\n// next steps:\n- make the last set of class tests work. abolish the shadowing, pave the way for mode v4\n- defineProperty trickery\n\n\n// fixing maps/sets?\n// we could look into promises, but that seems like a bigger problem to tackle\n// dare i say optionals/nullables? might have the same way forward as plusses ..\n// or pattern stuff, but that's not really problem solving. that's just polish.\n// collect which properties are looked up on values\n\nthis was the todo list from v2 before this v3\n\n- spread\n- optional / nullable\n- classes / super\n- try / catch (and throwing in general?)\n- tagged templates\n- destructuring (assignment, arrow, catch)\n- return type of asyncs\n- constructor and new.target\n- new and classes\n- new and (arrows/bind\n\n- defining all the spec builtins\n- knowing that something is an object, just not what kind of object? like `instanceof` and `in`\n- constructors\n- any non-lexical bindings (`var`) are undefined until defined. Inside any function these are nullable. drat.\n- can we assert TDZ in our model?\n- workaround for delete? `(({a, ...r})=>r)(obj)`, () => {let {a, ...r} = obj`\n- freezing / frozen objects\n  - how to deal with an object that gets frozen? how to deal with the before/after. I guess `x = {}; x = freeze(x)` is illegal because its not monomorphic -> `x={};y=freeze(x)`\n  - obj attributes (writable/configurable/etc)\n- classes;\n  - does a class represent an opaque type? are two different classes with same sig of same type?\n  - what are hte limits to subclassing for us?\n\n\n\n- before we would shadow tees when entering a new scope but now we will create a new global tee instead\n- this should allow us to work around the problem of returning references from the same function multiple times and resolving to the value under the shadow in global space\n- the potential downside is losing a guarantee about the whole thing being final, but i think I kinda lost that one already when I went with props and tribute, nayways.\n\n\n\n */\n\n\n// function f(){ return this }; f.apply(bar);\n// `function f(){ f.toString(); f.toString(16); f * f }` -> \"any kind of value; number or user object; must be number\"\n// chained calls, a()() and a().b()\n\nimport {\n  ASSERT,\n  WHITE_BLACK,\n  RED,\n  BLUE,\n  RESET,\n  BOLD,\n  GREEN,\n  PURPLE,\n  DIM,\n\n  SUPER_PROP_OWNER_NOT_FOR_CLASS,\n  SUPER_PROP_OWNER_NOT_FOR_GLOBAL,\n  SUPER_PROP_OWNER_NOT_A_METHOD,\n  ASSERT_SUPER_PROP_OWNER,\n\n  dir,\n  group,\n  groupEnd,\n  log,\n  printNode,\n  tstr, ASSERT_LOC,\n} from \"./utils.mjs\"\nimport {YELLOW} from './utils.mjs';\nimport builtinGlobalBindings from './globals.mjs';\nimport {playActions} from './actions.mjs';\n\nexport function phase3(store, filename) {\n  group('\\n\\n\\n##################################\\n## phase3  ::  ' + filename + '\\n##################################\\n\\n\\n');\n  \n  const fileState = store.fileData.get(filename);\n\n  const globalTid = 'G' + String(++store.uid);\n  const globalTee = {\n    _class: 'global obj',\n    tid: globalTid,\n    type: 'O', // Any need to make it special?\n    builtin: true, // Safe to do?\n    iid: 0,\n    props: new Map,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map,\n    alias: null,\n    fromFilename: filename,\n    fromColumn: 0,\n    fromLine: 0,\n    locFrom: {filename, column: -1, line: -1},\n    fencedClone(fence, recur = new Map, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs) {\n      ASSERT(false, 'why is this called on global?');\n      // (If this needs to be implemented see the object type)\n    },\n  };\n  store.set(globalTid, globalTee);\n  fileState.globalTid = globalTid;\n\n  const globalModuleTid = 'O' + String(++store.uid);\n  {\n    const props = new Map;\n    const tee = {\n      _class: 'global.module obj',\n      tid: globalModuleTid,\n      type: 'O', // Any need to make it special?\n      builtin: true, // Safe to do?\n      iid: 0,\n      // props: new Map([['exports', globalModuleExportsTid]]),\n      // seen: new Map([['exports', globalModuleExportsTid]]),\n      props,\n      setProp(name, tid) { this.props.set(name, tid); return tid; },\n      seen: new Map,\n      alias: null,\n      locFrom: {filename, column: -2, line: -1},\n      fencedClone(fence, recur = new Map, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs) {\n        ASSERT(false, 'why is this called on global.module?');\n        // (If this needs to be implemented see the object type)\n      },\n    };\n    store.set(globalModuleTid, tee);\n    fileState.globalModuleTid = globalModuleTid;\n  }\n\n  const closureMap = new Map(builtinGlobalBindings);\n  let closure = {\n    class: 'closure',\n    type: 'global',\n    digest(color) { return color ? YELLOW + 'G' + RESET : 'G'; },\n    get(name) { return closureMap.get(name); },\n    set(name, tid) { return closureMap.set(name, tid); },\n    has(name) { return closureMap.has(name); },\n    str() {\n      return '<global scope>';\n    },\n    find(name, locFrom) {\n      ASSERT(typeof name === 'string', 'must find a name', name);\n      ASSERT_LOC(locFrom);\n\n      log('Looking for `' + name + '` in global scope');\n      if (closureMap.has(name)) return closureMap.get(name);\n\n      store.linter.check('USED_BINDING_BEFORE_DECL', locFrom, name);\n      log('Marking `' + name + '` as an implicit global');\n      store.fileData.get(filename).implicitGlobals.add(name);\n      closureMap.set(name, 'undefined'); // I guess\n      return 'undefined'; // Let it poly out\n    },\n    parentClosure: null,\n    superPropOwner: SUPER_PROP_OWNER_NOT_FOR_GLOBAL,\n    instanceFence: 0, // Any iid higher than this was created after this closure (in global, that's everything that's not builtin)\n    calleeTid: 'global',\n    filename,\n  };\n\n  closure.set('window', globalTid);\n  closure.set('global', globalTid);\n  closure.set('module', globalModuleTid);\n\n  const stack = [];\n\n  const locFrom = {filename, column: 0, line: 0};\n  playActions(locFrom, store, fileState.globalActions, globalTee, 'undefined', closure, stack);\n\n  groupEnd();\n\n  return store;\n}\n\n\n\n\n","~/proj/zetype/src/lint.mjs":"import {\n  ASSERT,\n  ASSERT_LOC,\n  RESET,\n  RED_WHITE,\n  WHITE_BLACK,\n\n  dir,\n  group,\n  groupEnd,\n  log,\n} from './utils.mjs';\n\n// The system should be able to ignore all lints and still work. So either a lint is actually a permanent LangError or it should be ignore-able by the system.\n\nconst LEVEL = {\n  L: {kind: 'lint', state: 'ok', desc: 'trivial linting problem, ast based linting would catch this, no problem for the model'},\n  W: {kind: 'warn', state: 'ok', desc: 'non-trivial linting problem, no problem for the model'},\n  C: {kind: 'crash', state: 'ok', desc: 'this will be a runtime crash error, not a problem for the model'},\n  F: {kind: 'fatal', state: 'bad', desc: 'this will be a runtime crash error, model is now in a partially unsound state'},\n  B: {kind: 'bad', state: 'bad', desc: 'linting problem, puts the model in a partially unsound state'},\n  M: {kind: 'model', state: 'bad', desc: 'problem; this is a limitation of the model and it is now in a partially unsound state'},\n};\n\nexport const codes = new Map();\n// Use `set` because that's the only way to maintain typing in our model. TODO: we could explicitly \"DSL\" support the map constructor with double array\ncodes.set('PROP_NOT_FOUND', {level: 'W', code: 'PROP_NOT_FOUND', message: 'Read a property from an object that did not actually have the property. This is valid in JS but signals a potential bug.'});\ncodes.set('PROP_NOT_FOUND_HAS_DEFAULT', {level: 'W', code: 'PROP_NOT_FOUND_HAS_DEFAULT', message: 'Destructured property not found but had a default so using that.'});\ncodes.set('IMMUTABLE_CLASS_PROTO', {level: 'E', code: 'IMMUTABLE_CLASS_PROTO', message: 'Tried to overwrite the `.prototype` of an es6 class but that is not possible. This breaks our model so we do not support even attempting it.'});\ncodes.set('CLASS_COMPUTED_METHOD', {level: 'E', code: 'CLASS_COMPUTED_METHOD', message: 'The method key of a class member cannot be a dynamic property because the model cannot track this.'});\ncodes.set('ARRAY_PUSH_NO_ARGS', {level: 'W', code: 'ARRAY_PUSH_NO_ARGS', message: 'Called Array#push without any args. This can work but it is a no-op so it signals a potential bug.'});\ncodes.set('ARRAY_PUSH_CONTEXT', {level: 'W', code: 'ARRAY_PUSH_CONTEXT', message: 'Called Array#push with a context that was not an actual array. This can work but signals a potential bug.'});\ncodes.set('ARRAY_UNSHIFT_NO_ARGS', {level: 'W', code: 'ARRAY_UNSHIFT_NO_ARGS', message: 'Called `Array#unshift` without any args. This can work but it is a no-op so it signals a potential bug.'});\ncodes.set('ARRAY_UNSHIFT_CONTEXT', {level: 'W', code: 'ARRAY_UNSHIFT_CONTEXT', message: 'Called `Array#unshift` with a context that was not an actual array. This can work but signals a potential bug.'});\ncodes.set('ARRAY_ISARRAY_ARGLESS', {level: 'W', code: 'ARRAY_ISARRAY_ARGLESS', message: 'The `Array.isArray` function expects at least one array, otherwise it will check whether `undefined` is an array. Spoiler alert: It is not.'});\ncodes.set('ARRAY_ISARRAY_ARG2', {level: 'W', code: 'ARRAY_ISARRAY_ARG2', message: 'The `Array.isArray` function ignores any args beyond the first one.'});\ncodes.set('ARRAY_POP_WITH_ARGS', {level: 'W', code: 'ARRAY_POP_WITH_ARGS', message: 'Called Array#pop with some args but it ignores them so that signals a potential bug.'});\ncodes.set('ARRAY_POP_UNDERFLOW', {level: 'W', code: 'ARRAY_POP_UNDERFLOW', message: 'Array#pop was used but the model can not guarantee the pop does not create an underflow (returning undefined) so all bets are off now.'});\ncodes.set('ARRAY_POP_CONTEXT', {level: 'W', code: 'ARRAY_POP_CONTEXT', message: 'Array#pop was called with a non-array for context.'});\ncodes.set('ARRAY_POP_EMPTY', {level: 'W', code: 'ARRAY_POP_EMPTY', message: 'Array had no kind yet, meaning it was popped before it had a chance to collect any element so pop must have been called on an empty array.'});\ncodes.set('ARRAY_SHIFT_UNDERFLOW', {level: 'W', code: 'ARRAY_SHIFT_UNDERFLOW', message: 'Array#shift was used but the model can not guarantee the pop does not create an underflow (returning undefined) so all bets are off now.'});\ncodes.set('ARRAY_SHIFT_EMPTY', {level: 'W', code: 'ARRAY_SHIFT_EMPTY', message: 'Array had no kind yet, meaning it was shifted before it had a chance to collect any element so pop must have been called on an empty array.'});\ncodes.set('ARRAY_LAMBDA_UNDERFLOW', {level: 'W', code: 'ARRAY_LAMBDA_UNDERFLOW', message: 'One of the array lambda methods was was called with zero arguments. That will lead to a runtime error.'});\ncodes.set('ARRAY_LAMBDA_OVERFLOW', {level: 'W', code: 'ARRAY_LAMBDA_OVERFLOW', message: 'One of the array lambda methods was was called more than two arguments. Those are ignored.'});\ncodes.set('ARRAY_LAMBDA_FUNC_ARG', {level: 'W', code: 'ARRAY_LAMBDA_FUNC_ARG', message: 'The first arg of an array lambda method must be a function or it will lead to a runtime error.'});\ncodes.set('ARRAY_LAMBDA_ARR_CONTEXT', {level: 'W', code: 'ARRAY_LAMBDA_ARR_CONTEXT', message: 'The second arg of a lambda method, and otherwise its context, ought to be an array. This model currently does not support array-like values here.'});\ncodes.set('ARRAY_LAMBDA_ARR_KIND', {level: 'W', code: 'ARRAY_LAMBDA_ARR_KIND', message: 'An array lambda method was called on an array with unknown type, meaning an empty array. This means the callback was called with `undefined`s, which is not likely to be correct.'});\ncodes.set('ARRAY_REDUCE_ARR_KIND', {level: 'W', code: 'ARRAY_REDUCE_ARR_KIND', message: 'An array lambda method was called on an array with unknown type, meaning an empty array. This is a runtime error for Array#reduce and Array#reduceRight. No big deal for the model.'});\ncodes.set('ARRAY_FILTER_RETURNS', {level: 'W', code: 'ARRAY_FILTER_RETURNS', message: 'The function arg of `Array#filter` ought to return an actual boolean.'});\ncodes.set('ARRAY_FIND_RETURNS', {level: 'W', code: 'ARRAY_FIND_RETURNS', message: 'The function arg of `Array#find` and `Array#findIndex` ought to return an actual boolean.'});\ncodes.set('ARRAY_ANYSOME_RETURNS', {level: 'W', code: 'ARRAY_ANYSOME_RETURNS', message: 'The function arg of `Array#some` and `Array#any` ought to return a boolean or undefined.'});\ncodes.set('FUNCTION_TOSTRING_ARGS', {level: 'W', code: 'FUNCTION_TOSTRING_ARGS', message: 'Called Function#toString with some args but it ignores them so that signals a potential bug.'});\ncodes.set('FUNCTION_TOSTRING_CONTEXT', {level: 'W', code: 'FUNCTION_TOSTRING_CONTEXT', message: 'Function#toString can only be called with a context of a function. It is a runtime error otherwise.'});\ncodes.set('FUNCTION_APPLY_ARGCOUNT', {level: 'W', code: 'FUNCTION_APPLY_ARGCOUNT', message: 'Only the first and second arg to `Functon#apply` are used. The rest is ignored. Supplying them anyways is a red flag.'});\ncodes.set('FUNCTION_BIND_BAD_CONTEXT', {level: 'W', code: 'FUNCTION_BIND_BAD_CONTEXT', message: 'Tried to Function#bind an object to `undefined` even though it accesses `this`.'});\ncodes.set('FUNCTION_BIND_THISLESS_CONTEXT', {level: 'W', code: 'FUNCTION_BIND_THISLESS_CONTEXT', message: 'Tried to Function#bind an object to a function that did not refer to `this`. The context should have no effect so it might signal a unintended bug.'});\ncodes.set('FUNCTION_BIND_PRIMITIVE', {level: 'W', code: 'FUNCTION_BIND_PRIMITIVE', message: 'Tried to Function#bind with a primitive for context. This will cause the context to be \"boxed\" to an object. More often than not, this is not the intention.'});\ncodes.set('FUNCTION_BIND_NULL', {level: 'W', code: 'FUNCTION_BIND_NULL', message: 'Tried to Function#bind a function to null. This effectively attempts to bind to global in non-strict mode, or to `undefined` in strict mode. Intention is unclear.'});\ncodes.set('FUNCTION_BIND_NEW', {level: 'W', code: 'FUNCTION_BIND_NEW', message: 'Using `new` on a function that is the result of `Function#bind` results in a runtime error.'});\ncodes.set('FUNCTION_BIND_CLASS', {level: 'W', code: 'FUNCTION_BIND_CLASS', message: 'While `Function#bind` on a class is allowed, it is likely that there are better ways to accomplish the same thing.'});\ncodes.set('FUNCTION_BIND_CLASS_CONTEXT', {level: 'W', code: 'FUNCTION_BIND_CLASS_CONTEXT', message: 'Calling `Function#bind` on a class with a context other than `undefined` is useless.'});\ncodes.set('BOOLEAN_TOSTRING_ARGS', {level: 'W', code: 'BOOLEAN_TOSTRING_ARGS', message: 'Called Boolean#toString with some args but it ignores them so that signals a potential bug.'});\ncodes.set('BOOLEAN_TOSTRING_CONTEXT', {level: 'W', code: 'BOOLEAN_TOSTRING_CONTEXT', message: 'Boolean#toString can only be called with a context of a boolean. It is a runtime error otherwise.'});\ncodes.set('NUMBER_ISFINITE_ARGLESS', {level: 'W', code: 'NUMBER_ISFINITE_ARGLESS', message: 'Called `Number.isFinite` without any args, meaning it tests `undefined`, which is always `false`.'});\ncodes.set('NUMBER_ISFINITE_ARG1', {level: 'W', code: 'NUMBER_ISFINITE_ARG1', message: 'Called `Number.isFinite` with an arg that was not a number value, which is always `false`.'});\ncodes.set('NUMBER_ISFINITE_ARG2', {level: 'W', code: 'NUMBER_ISFINITE_ARG2', message: 'The `Number.isFinite` function ignores any arg except for the first one.'});\ncodes.set('NUMBER_TOSTRING_ARGS', {level: 'W', code: 'NUMBER_TOSTRING_ARGS', message: 'Called Number#toString with more than one arg but it ignores those so that signals a potential bug.'});\ncodes.set('NUMBER_TOSTRING_CONTEXT', {level: 'W', code: 'NUMBER_TOSTRING_CONTEXT', message: 'Number#toString can only be called with a context of a number. It is a runtime error otherwise.'});\ncodes.set('NUMBER_TOSTRING_NUM', {level: 'W', code: 'NUMBER_TOSTRING_NUM', message: 'The first arg to `Number#toString` is optional but if it is given it must be a number.'});\ncodes.set('STRING_FCC_ARGLESS', {level: 'W', code: 'STRING_FCC_ARGLESS', message: 'Called `String.fromCharCode` without any args but that is probably not what was intended.'});\ncodes.set('STRING_FCC_ARGS', {level: 'W', code: 'STRING_FCC_ARGS', message: 'Called `String.fromCharCode` with an arg that was not a number. It only expects numbers.'});\ncodes.set('STRING_FCP_ARGLESS', {level: 'W', code: 'STRING_FCC_ARGLESS', message: 'Called `String.fromCodePoint` without any args but that is probably not what was intended.'});\ncodes.set('STRING_FCP_ARGS', {level: 'W', code: 'STRING_FCC_ARGS', message: 'Called `String.fromCodePoint` with an arg that was not a number. It only expects numbers.'});\ncodes.set('STRING_CODEPOINTAT_UNSOUND', {level: 'W', code: 'STRING_CODEPOINTAT_UNSOUND', message: 'The `String#codePointAt` method may return `undefined` for indexes that do not exist, so the model cannot reliably predict the resulting type. It will assume string but the model is unsound now.'});\ncodes.set('STRING_REPEAT_ARGLESS', {level: 'W', code: 'STRING_REPEAT_ARGLESS', message: 'Called `String#repeat` without any args but which makes it repeat zero times and return an empty string.'});\ncodes.set('STRING_SPLIT_ARGLESS', {level: 'W', code: 'STRING_SPLIT_ARGLESS', message: 'Called `String#split` without any args but that makes it effectively a noop.'});\ncodes.set('STRING_SPLIT_ARG1', {level: 'W', code: 'STRING_SPLIT_ARG1', message: 'The `String#split` function expects either a string or a regular expression as first arg.'});\ncodes.set('STRING_TOSTRING_ARGS', {level: 'W', code: 'STRING_TOSTRING_ARGS', message: 'Called String#toString with some args but it ignores them so that signals a potential bug.'});\ncodes.set('STRING_TOSTRING_CONTEXT', {level: 'W', code: 'STRING_TOSTRING_CONTEXT', message: 'String#toString can only be called with a context of a string. It is a runtime error otherwise.'});\ncodes.set('STRING_MATCH_UNSAFE', {level: 'W', code: 'STRING_MATCH_UNSAFE', message: 'String#match can return a `null` or an array of strings and this model cannot determine which ahead of time. Assuming array of strings but this is not sound.'});\ncodes.set('STRING_REPLACE_ARG1', {level: 'W', code: 'STRING_REPLACE_ARG1', message: 'The first arg to `String#replace` should be a string or regex.'});\ncodes.set('STRING_REPLACE_ARG2', {level: 'W', code: 'STRING_REPLACE_ARG2', message: 'The second arg to `String#replace` should be a string or function.'});\ncodes.set('STRING_REPLACE_FUNC', {level: 'W', code: 'STRING_REPLACE_FUNC', message: 'The second arg to `String#replace` as function can not be safely modeled because the function may receive strings or undefined depending on the actual matching. This breaks the model.'});\ncodes.set('STRING_REPLACE_RETURN', {level: 'W', code: 'STRING_REPLACE_RETURN', message: 'The second arg to `String#replace` is a function that should return a string.'});\ncodes.set('STRING_TLS_ARG1', {level: 'W', code: 'STRING_TLS_ARG1', message: 'The first arg to `String#toLocaleLowerString` and `String#toLocaleUpperString` is optionally either a string or array of strings.'});\ncodes.set('CALL_ARG_ARITY', {level: 'W', code: 'CALL_ARG_ARITY', message: 'Called a function with a different number of arguments than it had defined.'});\ncodes.set('EXTENDS_NULL', {level: 'W', code: 'EXTENDS_NULL', message: 'Found a class which extended a value that resolved to `null`. This is not a problem when defining the class but the class will throw a runtime error if it was ever instantiated.'});\ncodes.set('EXTENDS_PRIMITIVE', {level: 'W', code: 'EXTENDS_PRIMITIVE', message: 'Found a class which extended a primitive value. This will be a runtime error at declaration time.'});\ncodes.set('EXTENDS_NO_PROTO', {level: 'W', code: 'EXTENDS_NO_PROTO', message: 'Found a class that extends a value that has no prototype. This will be a runtime error at declaration time.'});\ncodes.set('EXTENDS_BAD_PROTO', {level: 'W', code: 'EXTENDS_NO_PROTO', message: 'Found a class that extends a value that has a bad prototype value. This will be a runtime error at declaration time.'});\ncodes.set('ASSERT_WARN_SUPER_WITHOUT_EXTENDS', {level: 'W', code: 'ASSERT_WARN_SUPER_WITHOUT_EXTENDS', message: 'Technically you can extend a class with `Function.prototype` and I would not want to take that power away from you but more often than not it would actually be a bug in the model and I would want to know about it during development..'});\ncodes.set('SUPER_NULL', {level: 'W', code: 'SUPER_NULL', message: 'Cannot invoke `super()` inside a constructor of a class that extends `null`'});\ncodes.set('SUPER_PRIMITIVE', {level: 'W', code: 'SUPER_PRIMITIVE', message: 'Cannot invoke `super()` inside a constructor of a class that extends a primitive (number/string/etc'});\ncodes.set('SUPER_INVALID', {level: 'W', code: 'SUPER_INVALID', message: 'Tried to access a property on `super` but that is not a valid value in the current context / class owner so it will just return `undefined`'});\ncodes.set('PROTO_MERGE', {level: 'W', code: 'PROTO_MERGE', message: 'Merged the __proto__ of two objects because one pointed to Object.prototype and no property had been resolved on it before. This should be fine but may lead to an unforseen problem case. Also, you probably should not be changing __proto__ after 2020.'});\ncodes.set('BINDING_NO_INIT', {level: 'W', code: 'BINDING_NO_INIT', message: 'A binding without initializer value is sealed to `undefined`, which is rarely what you want'});\ncodes.set('INSTANCEOF_OBSOLETE', {level: 'W', code: 'INSTANCEOF_OBSOLETE', message: 'You should not need `instanceof` because the model should be able to determine the truthfulness without a doubt'});\ncodes.set('INSTANCEOF_FAIL', {level: 'W', code: 'INSTANCEOF_FAIL', message: 'The result of an `instanceof` check was found to be `false` at least once'});\ncodes.set('IN_OBSOLETE', {level: 'W', code: 'IN_OBSOLETE', message: 'You should not need `in` because the model should be able to determine the truthfulness without a doubt'});\ncodes.set('IN_FAIL', {level: 'W', code: 'IN_FAIL', message: 'The result of an `in` check was found to be `false` at least once'});\ncodes.set('CONTEXT_NO_THIS', {level: 'W', code: 'CONTEXT_NO_THIS', message: 'A function was called with a context that was not `undefined` or the global object even though it does not access `this` at all'});\ncodes.set('CONTEXT_MISSING', {level: 'W', code: 'CONTEXT_MISSING', message: 'A function was called with an `undefined` context even though it does access `this`'});\ncodes.set('SET_PROTOTYPE', {level: 'W', code: 'SET_PROTOTYPE', message: 'Updating the .prototype of a class or constructor can cause property lookups to change, potentially (and unguardedly so) violating the monomorphic principle of properties. All bets are off.'});\ncodes.set('SET_PROTO', {level: 'W', code: 'SET_PROTOTYPE', message: 'Updating the .__proto__ can cause property lookups to change on this object and others, potentially (and unguardedly so) violating the monomorphic principle of properties. All bets are off.'});\ncodes.set('TEST_UNDEF', {level: 'W', code: 'TEST_UNDEF', message: 'Conditional tests should use bools. Undefined will work and does not break the model but are always falsy so may indicate problems.'});\ncodes.set('TEST_NULL', {level: 'W', code: 'TEST_NULL', message: 'Conditional tests should use bools. Nulls will work and do not break the model but are always falsy so may indicate problems.'});\ncodes.set('TEST_NUMSTR', {level: 'W', code: 'TEST_NUMSTR', message: 'Conditional tests should use bools. Numbers and strings may work but might hide problems. This warning does not break the model.'});\ncodes.set('TEST_OBJ', {level: 'W', code: 'TEST_OBJ', message: 'Conditional tests should use bools. Objects will work and do not break the model but are always truthy so may indicate problems.'});\ncodes.set('FUNC_EXPR_NAME_SHADOW', {level: 'W', code: 'FUNC_EXPR_NAME_SHADOW', message: 'The name of a function expression was shadowed by a param or local var. Can you tell the difference?'});\ncodes.set('UNUSED_DEFAULT_ARG_POLY', {level: 'W', code: 'UNUSED_DEFAULT_ARG_POLY', message: 'The parameter had a default value with a different type than the arg value, but the default value was not used (in this case) so it was not a problem for this reported case.'});\ncodes.set('SET_NEW_UNSEEN_PROP', {level: 'W', code: 'SET_NEW_UNSEEN_PROP', message: 'Setting a property on an object that did not have that property before and which was not observed yet. It would be wise and clear to explicitly define all possible properties of an object at declaration time.'});\ncodes.set('SET_NEW_BUT_SEEN_PROP', {level: 'W', code: 'SET_NEW_BUT_SEEN_PROP', message: 'Setting a property on an object that was observed to be `undefined` before already. This will break the model.'});\ncodes.set('FOR_IN_RHS_PRIMITIVE', {level: 'W', code: 'FOR_IN_RHS_PRIMITIVE', message: 'The rhs of the for-in is a primitive. This will work but makes it effectively a noop so probably not what was intended.'});\ncodes.set('FOR_OF_NON_ARRAY', {level: 'W', code: 'FOR_OF_NON_ARRAY', message: 'The rhs of a `for-of` was not an array.'}); // TODO: iterabl\ncodes.set('TEMPLATE_EXPR_STRING', {level: 'W', code: 'TEMPLATE_EXPR_STRING', message: 'The expressions inside a template string ought to be strings.'});\ncodes.set('GLOBAL_THIS', {level: 'W', code: 'GLOBAL_THIS', message: 'Detected the `this` keyword in a position where it must refer to the global object but that is `undefined` in strict mode'});\ncodes.set('ARROW_WITH_CONTEXT', {level: 'W', code: 'ARROW_WITH_CONTEXT', message: 'An arrow was called with an explicit context but arrows are implicitly bound to the context of their parent scope so their own context is moot'});\ncodes.set('CONSOLE_LOG_ARGLESS', {level: 'W', code: 'CONSOLE_LOG_ARGLESS', message: '`console.log` was called without args. Not illegal but may not be intentional.'});\ncodes.set('CONSOLE_DEBUG_ARGLESS', {level: 'W', code: 'CONSOLE_DEBUG_ARGLESS', message: '`console.debug` was called without args. Not illegal but may not be intentional.'});\ncodes.set('CONSOLE_WARN_ARGLESS', {level: 'W', code: 'CONSOLE_WARN_ARGLESS', message: '`console.warn` was called without args. Not illegal but may not be intentional.'});\ncodes.set('CONSOLE_ERROR_ARGLESS', {level: 'W', code: 'CONSOLE_ERROR_ARGLESS', message: '`console.error` was called without args. Not illegal but may not be intentional.'});\ncodes.set('CONSOLE_ERROR_ARG_STRING', {level: 'W', code: 'CONSOLE_ERROR_ARG_STRING', message: '`console.error` generally takes a string for the first argument and does not tend to serialize objects in a pretty way'});\ncodes.set('CONSOLE_ERROR_ARGS', {level: 'W', code: 'CONSOLE_ERROR_ARGS', message: '`console.error` was calledw with multiple args but generally only uses the first arg'});\ncodes.set('CONSOLE_TRACE_ARG_STRING', {level: 'W', code: 'CONSOLE_TRACE_ARG_STRING', message: '`console.trace` generally takes a string for the first argument and does not tend to serialize objects in a pretty way'});\ncodes.set('CONSOLE_TRACE_ARGS', {level: 'W', code: 'CONSOLE_TRACE_ARGS', message: '`console.trace` was calledw with multiple args but generally only uses the first arg'});\ncodes.set('CONSOLE_DIR_ARGLESS', {level: 'W', code: 'CONSOLE_DIR_ARGLESS', message: '`console.dir` was called without args. Not illegal but may not be intentional.'});\ncodes.set('CONSOLE_DIR_ARGS', {level: 'W', code: 'CONSOLE_DIR_ARGS', message: '`console.dir` generally takes two args where the second is an object with options'});\ncodes.set('CONSOLE_GROUPEND_ARGS', {level: 'W', code: 'CONSOLE_GROUPEND_ARGS', message: '`console.groupEnd` ignores its arguments so passing them on is not going to work.'});\ncodes.set('IMPLICIT_GLOBAL', {level: 'W', code: 'IMPLICIT_GLOBAL', message: 'Could not resolve identifier to binding. Implicit global? Missing builtin?'});\ncodes.set('USED_BINDING_BEFORE_DECL', {level: 'W', code: 'USED_BINDING_BEFORE_DECL', message: 'Either this was an implicit global or it was accessed before actually declaring it (that would be a TDZ violation)'});\ncodes.set('ARRAY_KIND', {level: 'W', code: 'ARRAY_KIND', message: 'The kind of an array was expected to be fetched but the target value was not an array or string'}); // TODO: iterables\ncodes.set('ARRAY_KIND_READ_BUT_UNDET', {level: 'W', code: 'ARRAY_KIND_READ_BUT_UNDET', message: 'Tried to read the kind of an array but its kind was undetermined. That should mean it was empty and it returns undefined. The array kind is now set to undefined, although that is probably not correct overall. Model is now unsound.'}); // TODO: iterabl\ncodes.set('ARRAY_KIND_EMPTY', {level: 'W', code: 'ARRAY_KIND_EMPTY', message: 'The kind of an array was required but the kind was not known yet because it started as an empty array and has not yet received any values'});\ncodes.set('ARRAY_INCLUDES_ARGLESS', {level: 'W', code: 'ARRAY_INCLUDES_ARGLESS', message: 'The `Array#includes` method needs an arg to search for, otherwise it will search for `undefined`, which is unlikely what you want.'});\ncodes.set('ARRAY_JOIN_ARGLESS', {level: 'W', code: 'ARRAY_JOIN_ARGLESS', message: 'The `Array#join` method will implicitly use \",\" as the join string. It is advised to be explicit in that value.'});\ncodes.set('ARRAY_JOIN_ARG1', {level: 'W', code: 'ARRAY_JOIN_ARG1', message: 'The `Array#join` method expects a string its arg.'});\ncodes.set('ARRAY_JOIN_ARG2', {level: 'W', code: 'ARRAY_JOIN_ARG2', message: 'The `Array#join` method only uses the first arg to join.'});\ncodes.set('ARRAY_JOIN_CONTEXT', {level: 'W', code: 'ARRAY_JOIN_CONTEXT', message: 'The `Array#join` method requires an array context.'}); // TODO: it's probably generic (I didn't check\ncodes.set('ARR_MONO_KIND', {level: 'W', code: 'ARR_MONO_KIND', message: 'For the sake of the model arrays can only be monomorphic. In this case there was at least one element that was not compatible with the others.'});\ncodes.set('SPREAD_BEFORE_REST', {level: 'W', code: 'SPREAD_BEFORE_REST', message: 'The arg being spread does not fully map into a rest param and since the array being spread might be empty, the model cannot guarantee that the type is or is not undefined due to underflow'});\ncodes.set('SPREAD_NOT_TAIL', {level: 'W', code: 'SPREAD_NOT_TAIL', message: 'Since the model does not know how many elements an array contains it cannot guarantee anything about the position of fixed args when spreading an array between them so we can only support arg spread at the end of the arg list and only very few cases can work soundly'});\ncodes.set('MERGING_EMPTY_ARRAYS', {level: 'W', code: 'MERGING_EMPTY_ARRAYS', message: 'Setting the kind of an array, which was unknown, to the kind of another array, which was also unknown. This is a current weakness in the system and breaks the soundness.'});\ncodes.set('PROP_ON_NULL_UNDEF', {level: 'W', code: 'PROP_ON_NULL_UNDEF', message: 'Attempted to read a property from a value that was `null` or `undefined`, which will guarantee a runtime error.'});\ncodes.set('OBJ_REST_ON_PRIMITIVE', {level: 'W', code: 'REST_ON_PRIMITIVE', message: 'Passed on a primitive to an object rest pattern. This works but would always results in an empty object.'});\ncodes.set('DYNAMIC_PROP_ACCESS', {level: 'W', code: 'DYNAMIC_PROP_ACCESS', message: 'Since this model does not track actual values, it cannot support dynamic property access, so this access is assumed to return `undefined`, which is probably incorrect. Try to eliminate the dynamic property access or to consolidate them to small helpers.'});\ncodes.set('DYNAMIC_INDEX_ACCESS_ARRAY', {level: 'W', code: 'DYNAMIC_INDEX_ACCESS_ARRAY', message: 'Dynamic property access of a number property on an array. We can assume that returns the kind of the array but it is not sound as it may return undefined at runtime for OOB indexes.'});\ncodes.set('DYNAMIC_INDEX_ACCESS_EMPTY_ARRAY', {level: 'W', code: 'DYNAMIC_INDEX_ACCESS_EMPTY_ARRAY', message: 'Dynamic property access of a number property on an EMPTY array. This probably returns `undefined` at runtime and we consider the model to be unsound because of it.'});\ncodes.set('DYNAMIC_INDEX_ACCESS_STRING', {level: 'W', code: 'DYNAMIC_INDEX_ACCESS_STRING', message: 'Dynamic property access of a number property on an string. We can assume that returns a string but it is not sound as it may return undefined at runtime for OOB indexes.'});\ncodes.set('DYNAMIC_INDEX_ACCESS_EMPTY_OBJECT', {level: 'W', code: 'DYNAMIC_INDEX_ACCESS_EMPTY_OBJECT', message: 'Dynamic access on an empty object will return `undefined`. The model is considered to be unsound now.'});\ncodes.set('DYNAMIC_ACCESS_OBJECT_AS_MAP', {level: 'W', code: 'DYNAMIC_ACCESS_OBJECT_AS_MAP', message: 'Dynamic property access on an object that only has properties of the same kind can work but is unsafe because it may also return `undefined`. The model is broken because it cannot guarantee that.'});\ncodes.set('COMPUTED_PROPERTY', {level: 'W', code: 'COMPUTED_PROPERTY', message: 'Since this model does not track actual values, it cannot support computed properties as it will not know what property is being set. Try to eliminate the dynamic property access or to consolidate them to small helpers.'});\ncodes.set('PROP_SET_ON_NULL_UNDEF', {level: 'W', code: 'PROP_SET_ON_NULL_UNDEF', message: 'Attempted to set a property on `null` or `undefined`, which would lead to a runtime error.'});\ncodes.set('PROP_SET_ON_PRIMITIVE', {level: 'W', code: 'PROP_SET_ON_PRIMITIVE', message: 'Attempted to set a property on a primitive value. This will be ignored by JS and is probably not intentional.'});\ncodes.set('CALLED_UNCALLABLE', {level: 'W', code: 'CALLED_UNCALLABLE', message: 'Attempted to call a value that was not callable. The attempt is ignored but either means there is a bug in the code or there was a problem that has already been reported on that led to this situation. The call will be a noop and treated as if it returned `undefined`.'});\ncodes.set('SETTIMEOUT_ARG_TYPE', {level: 'W', code: 'SETTIMEOUT_ARG_TYPE', message: 'The first arg to `setTimeout` should be a function or a string.'});\ncodes.set('SETTIMEOUT_STRING_ARG', {level: 'W', code: 'SETTIMEOUT_STRING_ARG', message: 'While a string is a valid arg type for `setTimeout`, it does mean this model can not check it, so it cannot support that.'});\ncodes.set('SETTIMEOUT_NUM_ARG', {level: 'W', code: 'SETTIMEOUT_NUM_ARG', message: 'The second arg of `setTimeout` ought to be a number; the delay in ms.'});\ncodes.set('SETTIMEOUT_EXCESS_ARGS', {level: 'W', code: 'SETTIMEOUT_EXCESS_ARGS', message: '`setTimeout` received more args than the two it uses.'});\ncodes.set('SETINTERVAL_ARG_TYPE', {level: 'W', code: 'SETINTERVAL_ARG_TYPE', message: 'The first arg to `setInterval` should be a function or a string.'});\ncodes.set('SETINTERVAL_STRING_ARG', {level: 'W', code: 'SETINTERVAL_STRING_ARG', message: 'While a string is a valid arg type for `setInterval`, it does mean this model can not check it, so it cannot support that.'});\ncodes.set('SETINTERVAL_NUM_ARG', {level: 'W', code: 'SETINTERVAL_NUM_ARG', message: 'The second arg of `setInterval` ought to be a number; the interval delay in ms.'});\ncodes.set('SETINTERVAL_EXCESS_ARGS', {level: 'W', code: 'SETINTERVAL_EXCESS_ARGS', message: '`setInterval` received more args than the two it uses.'});\ncodes.set('CLEARTIMEOUT_NUM_ARG', {level: 'W', code: 'CLEARTIMEOUT_NUM_ARG', message: '`clearTimeout` expects a number, it ignores anything else.'});\ncodes.set('CLEARTIMEOUT_EXCESS_ARGS', {level: 'W', code: 'CLEARTIMEOUT_EXCESS_ARGS', message: '`clearTimeout` received more args than the one it uses.'});\ncodes.set('CLEARINTERVAL_NUM_ARG', {level: 'W', code: 'CLEARINTERVAL_NUM_ARG', message: '`clearInterval` expects a number, it ignores anything else.'});\ncodes.set('CLEARINTERVAL_EXCESS_ARGS', {level: 'W', code: 'CLEARINTERVAL_EXCESS_ARGS', message: '`clearInterval` received more args than the one it uses.'});\ncodes.set('ERROR_TOSTRING_ARGS', {level: 'W', code: 'ERROR_TOSTRING_ARGS', message: 'Called Error#toString with some args but it ignores them so that signals a potential bug.'});\ncodes.set('ERROR_STRING_ARG', {level: 'W', code: 'ERROR_STRING_ARG', message: 'Called Error#toString with an arg that was not a string.'});\ncodes.set('ARRAY_PATTERN_UNSOUND', {level: 'W', code: 'ARRAY_PATTERN_UNSOUND', message: 'This model does not track array contents so it can not guarantee the array passed on to a destructuring pattern has sufficient elements to cover the entire pattern. It assumes it can but that may be incorrect.'});\ncodes.set('NEW_NOT_CONSTRUCTOR', {level: 'W', code: 'NEW_NOT_CONSTRUCTOR', message: 'Tried to apply `new` to a value that is not a constructor. Ignoring this and returning `undefined` but that is very unlikely to be correct.'});\ncodes.set('CANNOT_CALL_BUILTIN_CONSTRUCTOR', {level: 'W', code: 'CANNOT_CALL_BUILTIN_CONSTRUCTOR', message: 'Cannot call this builtin constructor without `new`. That will trigger a runtime error.'});\ncodes.set('BUILTIN_FUNC_NOT_CONSTRUCTOR', {level: 'W', code: 'BUILTIN_FUNC_NOT_CONSTRUCTOR', message: 'Attempted to use `new` on a built-in function that was not a constructor. That will throw a runtime error.'});\ncodes.set('CONSTRUCTOR_NULL_PARENT', {level: 'W', code: 'CONSTRUCTOR_NULL_PARENT', message: 'Cannot instantiate a constructor when its prototype is `null` or does not exist at all.'});\ncodes.set('COMPOUND_ASSIGN_TYPE', {level: 'W', code: 'COMPOUND_ASSIGN_TYPE', message: 'Compound assignment must be numbers operands.'});\ncodes.set('COMPOUND_ASSIGN_PLUS', {level: 'W', code: 'COMPOUND_ASSIGN_PLUS', message: 'Compound addition assignment (`+=`) must be numbers or string, same on both sides.'});\ncodes.set('PLUS_MERGE_TYPE', {level: 'W', code: 'PLUS_MERGE_TYPE', message: 'The operands to `+` must either both be number or both be strings.'});\ncodes.set('PLUS_MERGE_NUM_STR', {level: 'W', code: 'PLUS_MERGE_NUM_STR', message: 'The operands to `+` on a string and a number should really explicitly turn the number into a string first. This warning does not break the model.'});\ncodes.set('PLUS_MERGE_STR_PRIM', {level: 'W', code: 'PLUS_MERGE_STR_PRIM', message: 'The operands to `+` on a string and another primitive should really explicitly turn the primitive into a string first. This warning does not break the model.'});\ncodes.set('PLUS_MERGE_NUM_UNDEF', {level: 'W', code: 'PLUS_MERGE_NUM_UNDEF', message: 'The operands to `+` on a number and undefined is going to lead to NaN which is unlikely what you want. This warning does not break the model.'});\ncodes.set('PLUS_MERGE_NUM_NULL', {level: 'W', code: 'PLUS_MERGE_NUM_NULL', message: 'The operands to `+` on a number and null is going to be a regular addition where `null` is `0`. Might not be intentional. This warning does not break the model.'});\ncodes.set('PLUS_MERGE_NUM_BOOL', {level: 'W', code: 'PLUS_MERGE_NUM_BOOL', message: 'The operands to `+` on a number and boolean is going add `0` (for `false`) or `1` (for `true`) to the number, which is unlikely what you want. This warning does not break the model.'});\ncodes.set('POLY_PRIMITIVES', {level: 'W', code: 'POLY_PRIMITIVES', message: 'Tried to merge two primitives together (and not the same ones).'});\ncodes.set('POLY_BUILTINS', {level: 'W', code: 'POLY_BUILTINS', message: 'Tried to merge two builtin values together (and not the same ones).'});\ncodes.set('POLY_BUILTIN_ARRAY', {level: 'W', code: 'POLY_BUILTIN_ARRAY', message: 'Tried to merge a non-object with a built-in array.'});\ncodes.set('POLY_OTHER', {level: 'W', code: 'POLY_OTHER', message: 'Tried to merge two objects together but they at least one property had different types (potentially nested/inherited) and so the objects could not be merged.'});\ncodes.set('POLY_PRIMITIVE_TO_PLACEHOLDER_WITH_PROPS', {level: 'W', code: 'POLY_PRIMITIVE_TO_PLACEHOLDER_WITH_PROPS', message: 'Merging a placeholder with assigned properties to a primitive. This is probably a bug as you cannot set properties on primitives.'});\ncodes.set('IMPORT_UNKNOWN', {level: 'W', code: 'IMPORT_UNKNOWN', message: 'Tried to import a symbol from a file but did not find an export in that file for that symbol. This would be a runtime error. The model assumes `undefined` for this import, which is almost guaranteed to be incorrect.'});\ncodes.set('IMPORT_FILE_UNKNOWN', {level: 'W', code: 'IMPORT_FILE_UNKNOWN', message: 'Tried to import a symbol from a file but the file was not processed by the system yet. Either the system is unaware of the file or there is a circular dependency, which the system does not support.'});\ncodes.set('FUNCTION_MERGE', {level: 'W', code: 'FUNCTION_MERGE', message: 'Tried to merge two functions and this model does not support that right now. I am not sure what that kind of merge would look like. This means one of the two functions is ignored so the output cannot be trusted.'});\ncodes.set('PARSEFLOAT_ARG1', {level: 'W', code: 'PARSEFLOAT_ARG1', message: 'The first arg to `parseFloat` ought to be a string. Anything else might be a red flag.'});\ncodes.set('PARSEFLOAT_ARG2', {level: 'W', code: 'PARSEFLOAT_ARG2', message: 'The `parseFloat` function only uses the first arg. It does not have a base arg like `parseInt`.'});\ncodes.set('PARSEFLOAT_ARGLESS', {level: 'W', code: 'PARSEFLOAT_ARGLESS', message: 'Calling `parseFloat` without any args is pointless.'});\ncodes.set('PARSEINT_ARG1', {level: 'W', code: 'PARSEINT_ARG1', message: 'The first arg to `parseInt` ought to be a string. Anything else might be a red flag.'});\ncodes.set('PARSEINT_ARG2', {level: 'W', code: 'PARSEINT_ARG2', message: 'The second arg to `parseInt` is optional but if supplied should be a number; the base to parse in.'});\ncodes.set('PARSEINT_ARG3', {level: 'W', code: 'PARSEINT_ARG3', message: 'The `parseInt` function only uses the first two args.'});\ncodes.set('PARSEINT_1_ARG', {level: 'W', code: 'PARSEINT_1_ARG', message: 'It is strongly adviced to always supply a second arg, even if that is just 10, because JS might potentially parse an octal otherwise.'});\ncodes.set('PARSEINT_ARGLESS', {level: 'W', code: 'PARSEINT_ARGLESS', message: 'Calling `parseInt` without any args is pointless.'});\ncodes.set('JSON_STRINGIFY_ARGLESS', {level: 'W', code: 'JSON_STRINGIFY_ARGLESS', message: 'Calling `JSON.stringify` without args is bad.'});\ncodes.set('JSON_STRINGIFY_ARG1', {level: 'W', code: 'JSON_STRINGIFY_ARG1', message: 'The first arg to `JSON.parse` should be a string)'});\ncodes.set('JSON_STRINGIFY_ARG2', {level: 'W', code: 'JSON_STRINGIFY_ARG2', message: 'The second arg to `JSON.parse` should be a function.'});\ncodes.set('JSON_STRINGIFY_ARG3', {level: 'W', code: 'JSON_STRINGIFY_ARG3', message: 'The `JSON.parse` function does not use more than two args so passing on more is a red flag.'});\ncodes.set('JSON_PARSE_RETURN', {level: 'W', code: 'JSON_PARSE_RETURN', message: 'The model cannot know what the shape is of the call to `JSON.parse` so it cannot verify this code.'});\ncodes.set('SET_WITHOUT_NEW', {level: 'W', code: 'SET_WITHOUT_NEW', message: 'You must use `new` to call `Set`. It will be a runtime error otherwise.'});\ncodes.set('SET_ARG1', {level: 'W', code: 'SET_ARG1', message: 'The first arg of `Set` is optional but must be an iterable (the model currently only supports arrays)'}); // TODO\ncodes.set('SET_ARG2', {level: 'W', code: 'SET_ARG2', message: 'The `Set` constructor only supports zero or one args, ignores others'});\ncodes.set('SET_EMPTY_ARRAY', {level: 'W', code: 'SET_EMPTY_ARRAY', message: 'Created a new Set by passing on an empty array. Not a problem but may also not be intentional.'});\ncodes.set('SET_FOREACH_CONTEXT', {level: 'W', code: 'SET_FOREACH_CONTEXT', message: 'The `Set#forEach` function expects the context to be a Set instance.'});\ncodes.set('SET_FOREACH_SET_KIND', {level: 'W', code: 'SET_FOREACH_SET_KIND', message: 'The `Set#forEach` function was called on a Set whose kind is unknown. It may indicate a problem. Or perhaps the callback is never called (DCE).'});\ncodes.set('MAPSET_FOREACH_ARGLESS', {level: 'W', code: 'MAPSET_FOREACH_ARGLESS', message: 'Calling `Map#forEach` or `Set#forEach` without args is going to lead to a runtime error.'});\ncodes.set('MAPSET_FOREACH_ARG3_TMI', {level: 'W', code: 'MAPSET_FOREACH_ARG3_TMI', message: 'The `Map#forEach` and `Set#forEach` functions only accept two args and ignore the rest.'});\ncodes.set('MAPSET_FOREACH_FUNC_ARG', {level: 'W', code: 'MAPSET_FOREACH_FUNC_ARG', message: 'The `Map#forEach` and `Set#forEach` functions require the first arg to be a function.'});\ncodes.set('MAP_FOREACH_CONTEXT', {level: 'W', code: 'MAP_FOREACH_CONTEXT', message: 'The `Map#forEach` function expects the context to be a Map instance.'});\ncodes.set('MAP_FOREACH_MAP_KIND', {level: 'W', code: 'MAP_FOREACH_MAP_KIND', message: 'The `Map#forEach` function was called on a Map whose key and value kind were unknown. This may mean the map was empty when this method was called. Or may indicate a different problem. Or perhaps the callback is never called (DCE).'});\ncodes.set('MAP_FOREACH_MAP_KEY_KIND', {level: 'W', code: 'MAP_FOREACH_MAP_KEY_KIND', message: 'The `Map#forEach` function was called on a Map whose key kind is unknown. It may indicate a problem. Or perhaps the callback is never called (DCE).'});\ncodes.set('MAP_FOREACH_MAP_VALUE_KIND', {level: 'W', code: 'MAP_FOREACH_MAP_VALUE_KIND', message: 'The `Map#forEach` function was called on a Map whose value kind is unknown. It may indicate a problem. Or perhaps the callback is never called (DCE).'});\ncodes.set('MAP_WITHOUT_NEW', {level: 'W', code: 'MAP_WITHOUT_NEW', message: 'You must use `new` to call `Map`. It will be a runtime error otherwise.'});\ncodes.set('MAP_ARG1', {level: 'W', code: 'MAP_ARG1', message: 'The first arg of `Map` is optional but must be an iterable (the model currently only supports arrays)'}); // TODO\ncodes.set('MAP_HAS_ARG1', {level: 'W', code: 'MAP_HAS_ARG1', message: 'The first arg of `Map#delete` should be of same kind as the Map but was not.'});\ncodes.set('MAP_ARG1_SUB_ARR', {level: 'W', code: 'MAP_ARG1_SUB_ARR', message: 'The iterable arg must iterate over an array that is a tuple: [key, value]. Otherwise it will trigger a runtime error.'});\ncodes.set('MAP_ARG2', {level: 'W', code: 'MAP_ARG2', message: 'The `Map` constructor only supports zero or one args, ignores others'});\ncodes.set('MAP_EMPTY_ARRAY', {level: 'W', code: 'MAP_EMPTY_ARRAY', message: 'Created a new Map by passing on an empty array. Not a problem but may also not be intentional. This will break the model because the array and map have their kind sealed to `undefined`.'});\ncodes.set('SET_ADD_ARGLESS', {level: 'W', code: 'SET_ADD_ARGLESS', message: 'While you can call `Set#add` without args, it is the same as calling it with `undefined` and you should be explicit in that to prevent confusion.'});\ncodes.set('MAP_SET_ARGLESS', {level: 'W', code: 'MAP_SET_ARGLESS', message: 'The `Map#set` method uses the first two args. Zero args is unlikely intentional.'});\ncodes.set('MAP_SET_ARG2', {level: 'W', code: 'MAP_SET_ARG2', message: 'The `Map#set` method uses the first two args. Even if the second is `undefined` you should pass it explicitly to prevent confusion.'});\ncodes.set('MAP_SET_ARG3', {level: 'W', code: 'MAP_SET_ARG3', message: 'The `Map#set` method only uses the first two args. Any more may be a mistake.'});\ncodes.set('MAP_SET_CONTEXT', {level: 'W', code: 'MAP_SET_CONTEXT', message: 'The `Map#set` context must be a Map.'});\ncodes.set('MAP_GET_ARGLESS', {level: 'W', code: 'MAP_GET_ARGLESS', message: 'The `Map#get` method uses the first arg. Zero args means fetching `undefined`, which is rarely the intention.'});\ncodes.set('MAP_GET_ARG1', {level: 'W', code: 'MAP_GET_ARG1', message: 'The `Map#get` method should be called with an arg that is the same type as the key type of this map.'});\ncodes.set('MAP_GET_ARG2', {level: 'W', code: 'MAP_GET_ARG2', message: 'The `Map#set` method only uses the first arg. Any more may be a mistake.'});\ncodes.set('MAP_GET_CONTEXT', {level: 'W', code: 'MAP_GET_CONTEXT', message: 'The `Map#get` context must be a Map.'});\ncodes.set('REGEXP_ARGLESS', {level: 'W', code: 'REGEXP_ARGLESS', message: 'The `RegExp` function/constructor works without arguments but it will be rare that you actually do not want it to receive any arguments.'});\ncodes.set('REGEXP_ARG1', {level: 'W', code: 'REGEXP_ARG1', message: 'The `RegExp` function/constructor expects the first arg to be the regex body and it will coerce the first argument to a string.'});\ncodes.set('REGEXP_ARG2', {level: 'W', code: 'REGEXP_ARG2', message: 'The `RegExp` function/constructor expects the second arg to be a set of flags, which ought to be strings.'});\ncodes.set('REGEXP_ARG3', {level: 'W', code: 'REGEXP_ARG3', message: 'The `RegExp` function/constructor ignores any arguments beyond the first two'});\ncodes.set('REGEXP_EXEC_UNSAFE', {level: 'W', code: 'REGEXP_EXEC_UNSAFE', message: 'RegExp#exec can return a `null` or an array of strings and this model cannot determine which ahead of time. Assuming array of strings but this is not sound.'});\ncodes.set('BUILTIN_ARGLESS', {level: 'W', code: 'BUILTIN_ARGLESS', message: 'The builtin function was called with zero args, even though it expects args'});\ncodes.set('BUILTIN_ARG1_STRING', {level: 'W', code: 'BUILTIN_ARG1_STRING', message: 'The builtin function expected the first arg to be a string.'});\ncodes.set('BUILTIN_ARG1_NUMBER', {level: 'W', code: 'BUILTIN_ARG1_NUMBER', message: 'The builtin function expected the first arg to be a number.'});\ncodes.set('BUILTIN_ARG1_REGEX', {level: 'W', code: 'BUILTIN_ARG1_REGEX', message: 'The builtin function expected the first arg to be a regex.'});\ncodes.set('BUILTIN_ARG1_OBJ', {level: 'W', code: 'BUILTIN_ARG1_OBJ', message: 'The builtin function expected the first arg to be some kind of object.'});\ncodes.set('BUILTIN_ARG1_TMI', {level: 'W', code: 'BUILTIN_ARG1_TMI', message: 'The builtin function expected zero args.'});\ncodes.set('BUILTIN_ARG2_STRING', {level: 'W', code: 'BUILTIN_ARG2_STRING', message: 'The builtin function expected the second arg to be a string.'});\ncodes.set('BUILTIN_ARG2_NUMBER', {level: 'W', code: 'BUILTIN_ARG2_NUMBER', message: 'The builtin function expected the second arg to be a number.'});\ncodes.set('BUILTIN_ARG2_MISSING', {level: 'W', code: 'BUILTIN_ARG2_MISSING', message: 'The builtin function expected at least two args but received fewer.'});\ncodes.set('BUILTIN_ARG2_OBJ', {level: 'W', code: 'BUILTIN_ARG2_OBJ', message: 'The builtin function expected the second arg to be some kind of object.'});\ncodes.set('BUILTIN_ARG2_TMI', {level: 'W', code: 'BUILTIN_ARG2_TMI', message: 'The builtin function expected one arg and ignores the rest.'});\ncodes.set('BUILTIN_ARG3_STRING', {level: 'W', code: 'BUILTIN_ARG3_STRING', message: 'The builtin function expected the third arg to be a string.'});\ncodes.set('BUILTIN_ARG3_NUMBER', {level: 'W', code: 'BUILTIN_ARG3_NUMBER', message: 'The builtin function expected the third arg to be a number.'});\ncodes.set('BUILTIN_ARG3_MISSING', {level: 'W', code: 'BUILTIN_ARG3_MISSING', message: 'The builtin function expected at least three args but received fewer.'});\ncodes.set('BUILTIN_ARG3_TMI', {level: 'W', code: 'BUILTIN_ARG3_TMI', message: 'The builtin function expected two args and ignores the rest.'});\ncodes.set('BUILTIN_ARG4_TMI', {level: 'W', code: 'BUILTIN_ARG4_TMI', message: 'The builtin function expected three args and ignores the rest.'});\ncodes.set('BUILTIN_CONTEXT_BOOL', {level: 'W', code: 'BUILTIN_CONTEXT_BOOL', message: 'The builtin function expected the context of the call to be a boolean.'});\ncodes.set('BUILTIN_CONTEXT_STRING', {level: 'W', code: 'BUILTIN_CONTEXT_STRING', message: 'The builtin function expected the context of the call to be a string.'});\ncodes.set('BUILTIN_CONTEXT_NUMBER', {level: 'W', code: 'BUILTIN_CONTEXT_NUMBER', message: 'The builtin function expected the context of the call to be a number.'});\ncodes.set('BUILTIN_CONTEXT_ARRAY', {level: 'W', code: 'BUILTIN_CONTEXT_ARRAY', message: 'The builtin function expected the context of the call to be an array.'});\ncodes.set('BUILTIN_CONTEXT_REGEX', {level: 'W', code: 'BUILTIN_CONTEXT_STRING', message: 'The builtin function expected the context of the call to be a regex.'});\ncodes.set('BUILTIN_CONTEXT_MAP', {level: 'W', code: 'BUILTIN_CONTEXT_MAP', message: 'The builtin function expected the context of the call to be a map.'});\ncodes.set('BUILTIN_CONTEXT_SET', {level: 'W', code: 'BUILTIN_CONTEXT_SET', message: 'The builtin function expected the context of the call to be a set.'});\ncodes.set('LOGICAL_OPERANDS_SAME_PRIMITIVE', {level: 'W', code: 'LOGICAL_OPERANDS_SAME_PRIMITIVE', message: 'Found a logical operator (`||` or `&&`) with non-bools that were the same. This might work and will not break the model but they ought to be bools.'});\ncodes.set('LOGICAL_OPERANDS_NULL_UNDEF_LEFT', {level: 'W', code: 'LOGICAL_OPERANDS_NULL_UNDEF_LEFT', message: 'Found a logical operator (`||` or `&&`) with `undefined` or `null` to the left. This will work but the outcome is fixed depending on the op. This will not break the model but might mean trouble.'});\ncodes.set('LOGICAL_OPERANDS_PRIM_LEFT', {level: 'W', code: 'LOGICAL_OPERANDS_NULL_UNDEF_LEFT', message: 'Found a logical operator (`||` or `&&`) with a \"not nullable primitive\" to the left. This may work but the outcome cannot be statically determined so it breaks the model.'});\ncodes.set('LOGICAL_OPERANDS_OBJ_LEFT', {level: 'W', code: 'LOGICAL_OPERANDS_OBJ_LEFT', message: 'Found a logical operator (`||` or `&&`) with an object to the left. This works but the return value is static depending on the operator, may indicate a problem. The operator should be used with bools. This case does not break the model.'});\ncodes.set('MATH_ARG_NUMBER', {level: 'W', code: 'MATH_ARG_NUMBER', message: 'All args to this math function are expected to be a number.'});\ncodes.set('NO_ITERATORS', {level: 'W', code: 'NO_ITERATORS', message: 'The model does not support iterators so .keys(), .value(), and .entries() cannot be modeled on Map and Set right now.'});\ncodes.set('OBJECT_GETPROTOTYPEOF_NULL', {level: 'W', code: 'OBJECT_GETPROTOTYPEOF_NULL', message: 'Trying to get the prototype of `undefined` or `null` will lead to a runtime error. This probably broke the model as we can only return `undefined` for it.'});\ncodes.set('OBJECT_KEYS', {level: 'W', code: 'OBJECT_KEYS', message: 'The model cannot get the .keys() of an object. It will just return an array of strings since that is the most likely. Should not break the model.'});\ncodes.set('OBJECT_VALUES', {level: 'W', code: 'OBJECT_VALUES', message: 'This model does not really support doing `Object.values()` on an object. Will return an array of undefined and that is unlikely to be correct.'});\ncodes.set('INFINITE_RECURSION_MAYBE', {level: 'W', code: 'INFINITE_RECURSION_MAYBE', message: 'Is this a case of infinite recursion? Or regular recursion?'});\ncodes.set('OBJ_SPREAD_STRING', {level: 'W', code: 'OBJ_SPREAD_STRING', message: 'Spreading a string is legit but this model does not track strings so it cannot know which properties are added as a result so the model is broken now.'});\ncodes.set('DELETE_MEH', {level: 'W', code: 'DELETE_MEH', message: 'The `delete` operator will remove properties which the model currently does not support.'});\ncodes.set('TOFIX', {level: 'W', code: 'TOFIX', message: 'This code path is not yet implemented / something is missing. Consider the model broken.'});\n\nexport function createLinter() {\n  let messages = [];\n  let suppressStack = [];\n  let suppressed = false;\n\n  function check(type, loc, ...args) {\n    ASSERT(codes.has(type), 'Unknown linting code: ' + type);\n    if (suppressed) return;\n\n    log('Lint problem: ' + RESET + RED_WHITE + type + RESET, '::', args, '::', codes.get(type).message);\n\n    loc === null || ASSERT_LOC(loc); // test merge will get locs that are null\n    messages.push({type, args, loc});\n  }\n  function setMessages(arr) {\n    messages = arr;\n  }\n  function getMessages() {\n    return messages;\n  }\n\n  function suppress(bool) {\n    ASSERT(typeof bool === 'boolean', 'should be bool', bool);\n    if (bool === true) {\n      if (suppressStack.length === 0) log(WHITE_BLACK + '!LINT!' + RESET, ':: linting is ' + (bool ? 'now' : 'no longer') + ' suppressed...');\n      suppressStack.push(suppressed);\n      suppressed = true;\n    } else {\n      suppressed = suppressStack.pop();\n      if (suppressStack.length === 0) log(WHITE_BLACK + '!LINT!' + RESET, ':: linting is ' + (bool ? 'now' : 'no longer') + ' suppressed...');\n    }\n  }\n  function resetSuppress(bool) {\n    suppressed = false;\n  }\n\n  return {\n    check,\n    setMessages,\n    getMessages,\n    suppress,\n    resetSuppress,\n  };\n}\n","~/proj/zetype/src/utils.mjs":"export const RED = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[31;1m';\nexport const RED_WHITE = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[41;1m';\nexport const GREEN = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[32m';\nexport const YELLOW = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[33;1m';\nexport const BLUE = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[34;1m';\nexport const PURPLE = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[35;1m';\nexport const WHITE = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[37m';\nexport const RESET = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[0m';\nexport const DIM = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[30;1m';\nexport const BOLD = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[;1;1m';\nexport const TRIBE = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[36;1m';\nexport const WHITE_BLACK = typeof process !== 'undefined' && process.argv.includes('-C') ? '' : '\\x1b[30;47m';\n\nexport const NO_DEFAULT_VALUE = {debug: 'NO_DEFAULT_VALUE: the ast had no default value for this node'};\nexport const NO_SUPER_VALUE = {debug: 'NO_SUPER_VALUE: the ast had no node for the superClass'};\nexport const SUPER_PROP_OWNER_NOT_FOR_CLASS = {debug: 'SUPER_PROP_OWNER_NOT_FOR_CLASS: this is the class value itself which cannot be invoked so this property is useless'};\nexport const SUPER_PROP_OWNER_NOT_FOR_GLOBAL = {debug: 'SUPER_PROP_OWNER_NOT_FOR_GLOBAL: this is the global object which has no super owner'};\nexport const SUPER_PROP_OWNER_NOT_A_METHOD = {debug: 'SUPER_PROP_OWNER_NOT_A_METHOD: regular methods have no super owner'};\nexport const NO_SUPER_PROP_FOR_BUILTINS = {debug: 'NO_SUPER_PROP_FOR_BUILTINS: built-in functions have no super owner'};\n\nfunction ASSERT(b, m = '', ...rest) {\n  if (!b) {\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n    groupEnd(true);\n\n    error('Assertion error happened...');\n    log('ASSERTION ARGS:');\n    let n = m || '<assertion without desc>';\n    log(...rest.length?rest:['<assert had no further args>']);\n\n    if (log !== console.log && typeof window !== 'undefined') {\n      console.error('Assertion error happened...');\n      console.log('ASSERTION ARGS:');\n      console.log(...rest.length ? rest : ['<assert had no further args>']);\n    }\n    console.trace(n + '; ' + rest.join(', '));\n    throw new Error(n);\n  }\n}\nfunction ASSERT_LOC(loc) {\n  ASSERT(typeof loc === 'object' && loc, 'loc should be an object', loc);\n  ASSERT(typeof loc.filename === 'string', 'loc filename must be a string', loc);\n  ASSERT(typeof loc.column === 'number' && loc.column >= 0, 'loc filename must be a number >=0', loc);\n  ASSERT(typeof loc.line === 'number' && loc.line >= 1, 'loc filename must be a number >0', loc);\n}\nfunction ASSERT_TID(tid, ...optional) {\n  // Certain special tids should only appear in selected contexts and should not leak outside of those contexts\n  // ASSERT(!Array.isArray(tid), 'tids should not be arrays', tid);\n  ASSERT(typeof tid === 'string' /*|| tid === NO_SUPER_VALUE*/ || optional.includes(tid), 'a tid should be a string or one of a few predefined constants', [tid, optional]);\n  // if (!optional.includes('H')) ASSERT(tid[0] !== 'H', 'not expecting placeholders on the stack', tid);\n  return true;\n}\n\nfunction printNode(node) {\n  ASSERT(node);\n  ASSERT(node.type);\n  switch (node.type) {\n    case 'Identifier':\n      return `<<${node.name}>>`;\n    case 'Literal':\n      return `<${node.raw}>`;\n    case 'MemberExpression':\n      return `${printNode(node.object)}.${printNode(node.property)}`;\n    case 'CallExpression':\n      return `${printNode(node.callee)}(${node.arguments.map(printNode).join(', ')})`;\n    case 'FunctionDeclaration':\n    case 'FunctionExpression':\n      return `function${node.id ? ' ' + printNode(node.id) : ''}(${node.params.map(printNode).join(', ')})`;\n    case 'ThisExpression':\n      return 'this';\n    case 'Super':\n      return 'super';\n    case 'AssignmentPattern':\n      ASSERT(node.left.type === 'Identifier', 'todo, fixme if this is different');\n      return printNode(node.left)+'='+printNode(node.right);\n    case 'NewExpression':\n      return 'new ' + printNode(node.callee) + '(' + node.arguments.map(printNode).join(', ') + ')';\n    default:\n      return `<???${node.type}>`;\n  }\n  // return `${t}${path.nodes[i].name ? '<' + path.nodes[i].name + '>' : ''}${t === 'Literal' ? '<' + path.nodes[i].raw + '>' : ''}${path.props[i+1] && `[${path.props[i+1]}]` || ''}`\n}\n\nconst VERBOSE = true;\n\nconst Console = {\n  log: (...args) => console.log(...args),\n  error: (...args) => console.error(...args),\n  group: (...args) => console.group(...args),\n  groupEnd: (...args) => console.groupEnd(...args),\n  dir: (...args) => console.dir(...args),\n}\n\nfunction setStdio(handler) {\n  Console.log = (...args) => handler('L', ...args);\n  Console.error = (...args) => handler('E', ...args);\n  Console.group = (...args) => handler('G', ...args);\n  Console.groupEnd = (...args) => handler('F', ...args);\n  Console.dir = (...args) => handler('D', ...args);\n}\n\nfunction clearStdio() {\n  Console.log = (...args) => console.log(...args);\n  Console.error = (...args) => console.log(...args);\n  Console.group = (...args) => console.group(...args);\n  Console.groupEnd = (...args) => console.groupEnd(...args);\n  Console.dir = (...args) => console.dir(...args);\n}\n\nlet indent = 0;\nfunction log(...args) {\n  if (VERBOSE) return Console.log(...args);\n}\nfunction error(...args) {\n  if (VERBOSE) return Console.error(...args);\n}\nfunction group(...args) {\n  ++indent;\n  if (VERBOSE) return Console.group(...args);\n}\nfunction groupEnd(...args) {\n  --indent;\n  if (VERBOSE) return Console.groupEnd(...args);\n}\nfunction dir(...args) {\n  if (VERBOSE) return Console.dir(...args);\n}\n\nfunction tstr(tid) {\n  if (typeof tid === 'string') return RED + tid + RESET;\n  if (tid === NO_DEFAULT_VALUE) return PURPLE + '`NO_DEFAULT_VALUE`' + RESET;\n  if (tid === NO_SUPER_VALUE) return PURPLE + '`NO_SUPER_VALUE`' + RESET;\n  if (tid === SUPER_PROP_OWNER_NOT_FOR_CLASS) return PURPLE + '`SUPER_PROP_OWNER_NOT_FOR_CLASS`' + RESET;\n  if (tid === SUPER_PROP_OWNER_NOT_FOR_GLOBAL) return PURPLE + '`SUPER_PROP_OWNER_NOT_FOR_GLOBAL`' + RESET;\n  if (tid === SUPER_PROP_OWNER_NOT_A_METHOD) return PURPLE + '`SUPER_PROP_OWNER_NOT_A_METHOD`' + RESET;\n  if (tid === NO_SUPER_PROP_FOR_BUILTINS) return PURPLE + '`NO_SUPER_PROP_FOR_BUILTINS`' + RESET;\n  return PURPLE + '`' + tid + '`' + RESET;\n}\n\nfunction ASSERT_SUPER_PROP_OWNER(v) {\n  ASSERT(v === NO_SUPER_VALUE || v === NO_SUPER_PROP_FOR_BUILTINS || v === SUPER_PROP_OWNER_NOT_A_METHOD ||  v === SUPER_PROP_OWNER_NOT_FOR_CLASS || v === SUPER_PROP_OWNER_NOT_FOR_GLOBAL || typeof v === 'string', 'super prop owner is a particular set of values but not this one', v);\n}\n\nexport function createPlaceholder(store, tidPrefix, desc) {\n  ASSERT(typeof tidPrefix === 'string' && tidPrefix[0] === 'H', 'the tid should start with an H');\n  const pid = tidPrefix + String(++store.uid); // placeholder id (holder, array, kind)\n  const props = new Map;\n  store.set(pid, {\n    _class: 'placeholder',\n    tid: pid,\n    type: 'H',\n    props: props,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map,\n    placeholder: true,\n    alias: null,\n  });\n  log('Created a placeholder tee', tstr(pid), 'for', desc);\n  return pid;\n}\nexport function createArrayTid(store) {\n  return 'A' + String(++store.uid);\n}\nexport function createClassTid(store) {\n  return 'C' + String(++store.uid);\n}\nexport function createFuncoTid(store) {\n  return 'F' + String(++store.uid);\n}\nexport function createMapTid(store) {\n  return 'M' + String(++store.uid);\n}\nexport function createObjectTid(store) {\n  return 'O' + String(++store.uid);\n}\nexport function createSetTid(store) {\n  return 'S' + String(++store.uid);\n}\n\nfunction getIndent() {\n  // To assert proper group open/close paths\n  return indent;\n}\n\nexport {\n  ASSERT,\n  ASSERT_LOC,\n  ASSERT_TID,\n  ASSERT_SUPER_PROP_OWNER,\n\n  clearStdio,\n  dir,\n  group,\n  groupEnd,\n  log,\n  printNode,\n  setStdio,\n  tstr,\n  getIndent,\n};\n","~/proj/zetype/src/builtins.mjs":"// - `|=` should merge operands to number (`assignable |= parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_rightExprStart_start, $tp_rightExprStart_line, $tp_rightExprStart_column, coalSeen,'right');`)\n// - `33:38 [x] IMPLICIT_GLOBAL [window]`\n\nimport {\n  ASSERT,\n  ASSERT_TID,\n  BOLD,\n  NO_SUPER_PROP_FOR_BUILTINS,\n  group,\n  groupEnd,\n  log,\n  RESET,\n  tstr,\n  createPlaceholder, getIndent\n} from \"./utils.mjs\"\nimport {merge, testMerge, mergeAll, isPrimitive, mergeTestAll, isPlaceholder} from \"./tools.mjs\"\nimport {metaCall, playActionArr, playActionObj, playActionMap, playActionSet, playActionFunc, playActionKind, playActionNew} from \"./actions.mjs\"\n\nfunction playActionBuiltinObj(store, tid, props, noProto) {\n  // There ought to be as many values on the stack as there are properties with initializers\n  // Create a tee with these properties\n\n  const r = playActionObj({filename: '<builtin>', column: 0, line: 0}, store, tid, null, [...props.keys()], [...props.values()]);\n  ASSERT(r === tid);\n  const tee = store.get(tid);\n  tee._class = 'builtin obj';\n  tee.builtin = true;\n  if (noProto) tee.props.delete('__proto__'); // This is Object.prototype\n  return tid;\n}\n\nexport function setupBuiltins(store) {\n  // This makes sure that all files share the same builtin type references\n\n  store.set('boolean', {\n    tid: 'boolean',\n    type: 'P',\n    digest(color) { return color ? tstr('boolean') : 'boolean'; },\n    builtin: true,\n    set alias(x) { throw do_not_alias_primitives },\n  });\n  store.set('number', {\n    tid: 'number',\n    type: 'P',\n    digest(color) { return color ? tstr('number') : 'number'; },\n    builtin: true,\n    set alias(x) { throw do_not_alias_primitives },\n  });\n  store.set('null', {\n    tid: 'null',\n    type: 'P',\n    digest(color) { return color ? tstr('null') : 'null'; },\n    builtin: true,\n    set alias(x) { throw do_not_alias_primitives },\n  });\n  store.set('string', {\n    tid: 'string',\n    type: 'P',\n    digest(color) { return color ? tstr('string') : 'string'; },\n    builtin: true,\n    set alias(x) { throw do_not_alias_primitives },\n  });\n  store.set('undefined', {\n    tid: 'undefined',\n    type: 'P',\n    digest(color) { return color ? tstr('undefined') : 'undefined'; },\n    builtin: true,\n    set alias(x) { throw do_not_alias_primitives },\n  });\n\n  createFunction(store, 'Array#concat', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n      log('Call had no args so return the context');\n      return contextTid;\n    }\n\n    let kindTid;\n\n    // Would be nice to support array-likes in the future...\n    const contextTeeToUse = store.get(contextTid);\n    if (contextTeeToUse.type !== 'A') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n      kindTid = 'undefined'; // :shrug:\n    } else {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n    }\n\n    // For each arg, if the arg is an array, merge its kind with kindTid, otherwise merge the arg with kindTid\n    callArgs.forEach((arg) => {\n      const tee = store.get(arg);\n      if (tee.type === 'A') {\n        kindTid = merge(locFrom, store, tee.kind, kindTid);\n      } else {\n        kindTid = merge(locFrom, store, arg, kindTid);\n      }\n    });\n\n    log('Returning fresh arr with resulting kind:', tstr(kindTid));\n    return playActionArr(locFrom, store, undefined, stack, kindTid);\n  });\n  createFunction(store, 'Array#copyWithin', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2 && callArgs[2] !== 'number') {\n      store.linter.check('BUILTIN_ARG3_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 3) {\n      store.linter.check('BUILTIN_ARG4_TMI', locFrom, callerTee.tid);\n    }\n\n    // Context ought to be an array type (although it could be anything, of course)\n    const contextTee = store.get(contextTid);\n    ASSERT(contextTee, 'should receive valid tee', contextTid);\n    let kind = 'undefined';\n    if (contextTee.type === 'A') {\n      log('Creating a new array with the same kind:', tstr(contextTee.kind));\n      kind = contextTee.kind;\n    } else {\n      // We may want to refine this check and support array-like\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n      log('copyWithin was called with a context that was not array so pushing an array of', tstr('undefined'));\n    }\n\n    return playActionArr(locFrom, store, undefined, stack, kind);\n  });\n  createFunction(store, 'Array#every', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return 'boolean';\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type !== 'A') {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    } else {\n      const kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Returning an array of the same kind as the input array:', tstr(contextTeeToUse.kind));\n    } else {\n      const kindTid = contextTeeToUse.kind || 'undefined'; // Non-arrays and empty arrays have been warned against now\n      contextTeeToUse.kind = kindTid; // If it didn't have a type, it does now. TODO: we can do better here ...\n\n      group('Now calling the callback with a', tstr(kindTid), 'and a', tstr('number'), 'and the array being iterated:', tstr(contextTidToUse));\n      const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n      log('The Array#every lambda call resulted in', tstr(returnTid));\n      groupEnd();\n\n      if (returnTid !== 'boolean' || returnTid !== 'undefined') {\n        // Technically it doesn't really matter but for the sake of consistency, the callback ought to either return a boolean or undefined\n        store.linter.check('ARRAY_ANYSOME_RETURNS', locFrom, callerTee.tid, returnTid);\n      }\n    }\n\n    return 'boolean';\n  });\n  createFunction(store, 'Array#entries', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'A') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'undefined';\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Array#fill', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 3) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type === 'A') {\n      const filler = argCount > 0 ? callArgs[0] : 'undefined';\n      const kindTee = store.get(contextTee.kind);\n      if (kindTee.type === 'H') {\n        // It's okay if this array is empty; in that case the kind is explicitly set now\n        log('Now setting the kind of the array to the tid of the first arg:', tstr(filler));\n        store.linkTo(kindTee, store.get(filler));\n        contextTee.kind = filler;\n      } else {\n        log('Merge the needle with the kind now...');\n        contextTee.kind = merge(locFrom, store, contextTee.kind, filler);\n      }\n    } else {\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n    }\n\n    log('Return the same context:', tstr(contextTid));\n    return contextTid;\n  });\n  createFunction(store, 'Array#filter', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call. Returning an array of type undefined');\n      return playActionArr(locFrom, store, undefined, stack, 'undefined');\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    let kindTid = 'undefined'; // If the context is not an array\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'A') {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    if (funcTee.type === 'F') {\n      group('Now calling the callback with a', tstr(kindTid), 'and a', tstr('number'), 'and the array being iterated:', tstr(contextTidToUse));\n      const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n      log('The Array#filter lambda call resulted in', tstr(returnTid));\n      groupEnd();\n\n      if (returnTid !== 'boolean') {\n        // This doesn't break the model but the lambda ought to return a boolean for filter.\n        store.linter.check('ARRAY_FILTER_RETURNS', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Returning an array of the same kind as the input array:', tstr(contextTeeToUse.kind));\n    }\n\n    return playActionArr(locFrom, store, undefined, stack, kindTid);\n  });\n  createFunction(store, 'Array#find', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call. Returning an array of type undefined');\n      return playActionArr(locFrom, store, undefined, stack, 'undefined');\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    let kindTid = 'undefined'; // If the context is not an array\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'A') {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n        log('Sealing the kind now because it is being returned');\n        store.linkTo(kindTee, store.get('undefined'));\n        kindTid = 'undefined';\n        contextTeeToUse.kind = 'undefined';\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    if (funcTee.type === 'F') {\n      group('Now calling the callback with a', tstr(kindTid), 'and a', tstr('number'), 'and the array being iterated:', tstr(contextTidToUse));\n      const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n      log('The Array#find lambda call resulted in', tstr(returnTid));\n      groupEnd();\n\n      if (returnTid !== 'boolean') {\n        // This doesn't break the model but the lambda ought to return a boolean for find.\n        store.linter.check('ARRAY_FILTER_RETURNS', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Returning an array of the same kind as the input array:', tstr(contextTeeToUse.kind));\n    }\n\n    log('Returning the kind of the array:', tstr(kindTid));\n    return kindTid;\n  });\n  createFunction(store, 'Array#findIndex', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return 'boolean';\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    let kindTid = 'undefined';\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'A') {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Returning a', tstr('boolean'));\n      return 'boolean';\n    }\n\n    group('Now calling the callback with a', tstr(kindTid), 'and a', tstr('number'), 'and the array being iterated:', tstr(contextTidToUse));\n    const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n    log('The Array#findIndex lambda call resulted in', tstr(returnTid));\n    groupEnd();\n\n    if (returnTid !== 'boolean' || returnTid !== 'undefined') {\n      // Technically it doesn't really matter but for the sake of consistency, the callback ought to either return a boolean or undefined\n      store.linter.check('ARRAY_FIND_RETURNS', locFrom, callerTee.tid);\n    }\n\n    return 'boolean';\n  });\n  createFunction(store, 'Array#flat', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // TODO: very technically this should do a toString() of the kind and follow that rabbit hole but :shrug:\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'A') {\n      store.linter.check('BUILTIN_CONTEXT', locFrom, callerTee.tid);\n      log('Returning an array of', tstr('undefined'));\n      return playActionArr(locFrom, store, undefined, stack, 'undefined');\n    }\n\n    // Fetch the array and recursively find the first non-array. Create a new array with that kind and return it.\n    let kindTid = contextTee.kind;\n    let kindTee = store.get(kindTid);\n    while (kindTee.type === 'A') {\n      kindTid = kindTee.kind;\n      kindTee = store.get(kindTid);\n    }\n\n    log('Returning an array of', tstr(kindTee));\n    return playActionArr(locFrom, store, undefined, stack, kindTee);\n  });\n  createFunction(store, 'Array#flatMap', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return 'boolean';\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    let kindTid = 'undefined';\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'A') {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Returning a', tstr('boolean'));\n      return 'boolean';\n    }\n\n    group('Now calling the callback with a', tstr(kindTid), 'and a', tstr('number'), 'and the array being iterated:', tstr(contextTidToUse));\n    const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n    log('The Array#flatMap lambda call resulted in', tstr(returnTid), ', that is the kind of the array to be returned');\n    groupEnd();\n\n    return playActionArr(locFrom, store, undefined, stack, returnTid);\n  });\n  createFunction(store, 'Array#forEach', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return 'undefined';\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type !== 'A') {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    } else {\n      const kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call');\n\n      return 'undefined';\n    }\n\n    const kindTid = contextTeeToUse.kind || 'undefined'; // Non-arrays and empty arrays have been warned against now\n\n    group('Now calling the callback with a', tstr(kindTid), 'and a', tstr('number'), 'and the array being iterated:', tstr(contextTeeToUse.tid));\n    const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kindTid, 'number', contextTeeToUse.tid], -1, store, '', store.instanceId, true);\n    log('The Array#forEach lambda call resulted in', tstr(returnTid));\n    groupEnd();\n\n    // Ignore return value. And even though from a purist perspective it _ought_ to be undefined, we don't care.\n    return 'undefined';\n  });\n  createFunction(store, 'Array#includes', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_INCLUDES_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 3) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type === 'A') {\n      const needle = argCount > 0 ? callArgs[0] : 'undefined';\n      const kindTee = store.get(contextTee.kind);\n      if (kindTee.type === 'H') {\n        store.linter.check('ARRAY_KIND_EMPTY', locFrom, callerTee.tid);\n        log('Now setting the kind of the array to the tid of the needle:', tstr(needle));\n        store.linkTo(kindTee, store.get(needle));\n        contextTee.kind = needle;\n      } else {\n        log('Merge the needle with the kind now...');\n        merge(locFrom, store, contextTee.kind, needle);\n      }\n    } else {\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n    }\n\n    return 'boolean';\n  });\n  createFunction(store, 'Array#indexOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_INCLUDES_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 3) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type === 'A') {\n      const needle = argCount > 0 ? callArgs[0] : 'undefined';\n      const kindTee = store.get(contextTee.kind);\n      if (kindTee.type === 'H') {\n        store.linter.check('ARRAY_KIND_EMPTY', locFrom, callerTee.tid);\n        log('Now setting the kind of the array to the tid of the needle:', tstr(needle));\n        store.linkTo(kindTee, store.get(needle));\n        contextTee.kind = needle;\n      } else {\n        log('Merge the needle with the kind now...');\n        merge(locFrom, store, contextTee.kind, needle);\n      }\n    } else {\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n    }\n\n    return 'number';\n  });\n  createFunction(store, 'Array#join', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // TODO: very technically this should do a toString() of the kind and follow that rabbit hole but :shrug:\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_JOIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('ARRAY_JOIN_ARG2', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'A') {\n      store.linter.check('ARRAY_JOIN_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Array#keys', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'A') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'undefined';\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Array#lastIndexOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_INCLUDES_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 3) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type === 'A') {\n      const needle = argCount > 0 ? callArgs[0] : 'undefined';\n      const kindTee = store.get(contextTee.kind);\n      if (kindTee.type === 'H') {\n        store.linter.check('ARRAY_KIND_EMPTY', locFrom, callerTee.tid);\n        log('Now setting the kind of the array to the tid of the needle:', tstr(needle));\n        store.linkTo(kindTee, store.get(needle));\n        contextTee.kind = needle;\n      } else {\n        log('Merge the needle with the kind now...');\n        merge(locFrom, store, contextTee.kind, needle);\n      }\n    } else {\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n    }\n\n    return 'number';\n  });\n  createFunction(store, 'Array#map', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return playActionArr(locFrom, undefined, store, stack, 'undefined');\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    let kindTid = 'undefined';\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'A') {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Assuming the .filter would return an array of the same kind.');\n      return playActionArr(locFrom, store, undefined, stack, kindTid);\n    }\n\n    group('Now calling the callback with a', tstr(kindTid), 'and a', tstr('number'), 'and the context', tstr(contextTidToUse));\n    const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n    log('The Array#map lambda call resulted in', tstr(returnTid));\n    groupEnd();\n\n    // Wrap the return type in an array. That's what will be returned.\n    return playActionArr(locFrom, store, undefined, stack, returnTid);\n  });\n  createFunction(store, 'Array#pop', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('ARRAY_POP_UNDERFLOW', locFrom, callerTee.tid);\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    // Context ought to be an array type (although it could be anything, of course)\n    const contextTee = store.get(contextTid);\n    ASSERT(contextTee, 'should receive valid tee', contextTid);\n    if (contextTid[0] !== 'A') {\n      // We may want to refine this check and support array-like\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n\n      log('Since context is unknown we now push', tstr('undefined'));\n      return 'undefined';\n    }\n\n    const kindTid = contextTee.kind;\n    ASSERT(typeof kindTid === 'string', 'kind should be a string', contextTee.kind);\n    const kindTee = store.get(kindTid);\n    if (kindTee.type === 'H') { // A placeholder must mean we haven't seen concrete operations to this array yet, right?\n      store.linter.check('ARRAY_POP_EMPTY', locFrom, callerTee.tid);\n      log('Array had no kind yet so now sealing its kind to', tstr('undefined'));\n      store.linkTo(kindTee, store.get('undefined'));\n      contextTee.kind = 'undefined';\n      return 'undefined';\n    }\n\n    log('The array kind is:', tstr(kindTee.tid));\n    return kindTee.tid;\n  });\n  createFunction(store, 'Array#push', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_PUSH_NO_ARGS', locFrom, callerTee.tid);\n    }\n\n    // Context ought to be an array type (although it could be anything, of course)\n    const contextTee = store.get(contextTid);\n    ASSERT(contextTee, 'should receive valid tee', contextTid)\n\n    log('Meta pushing', callArgs.map(tstr).join(', '), 'onto', tstr(contextTee.tid), '(so merging its kind with those args)');\n\n    // We may need to refine this but right now we can verify array tids with their tid prefix\n    if (contextTee.type !== 'A') {\n      store.linter.check('ARRAY_PUSH_CONTEXT', locFrom, callerTee.tid);\n      log('Returning a', tstr('number'), ', but not sure what the runtime would do here');\n      return 'number';\n    }\n\n    if (argCount === 0) {\n      log('There were no args to push into the array. Returning', tstr('number'), ' (new array length)');\n      return 'number';\n    }\n\n    const kindTee = store.get(contextTee.kind);\n    if (kindTee.type === 'H') {\n      // I don't think we should throw a lint here. The array is empty but its kind is explicitly\n      // set here so that should not be a problem.\n      // store.linter.check('ARRAY_KIND_EMPTY', locFrom, callerTee.tid);\n      log('Array had no kind yet, setting it to the merged tee of the push args');\n      log('Setting it to the tid of the first arg which will be merged with all the others:', tstr(callArgs[0]));\n\n      const argTid = callArgs[0]; // There has to be at least one\n      const argTee = store.get(argTid);\n\n      store.linkTo(kindTee, argTee);\n      contextTee.kind = argTee.tid;\n    }\n\n    // First test the merge (without changes or lints). If that fails, issue (only) a mono_kind error\n    const toMerge = [contextTee.kind, ...callArgs];\n    log('Merging all other args with the kind', tstr(contextTee.kind));\n    if (mergeTestAll(locFrom, toMerge, store)) {\n      // Have to do an actual merge, anyways, because it may mutate tees\n      contextTee.kind = mergeAll(locFrom, toMerge, store);\n    } else {\n      // This is what happens when you do [1].push('a')\n      store.linter.check('ARR_MONO_KIND', locFrom, callerTee.tid);\n    }\n\n    // Array push returns the new size of the array\n    return 'number';\n  });\n  createFunction(store, 'Array#reduce', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return playActionArr(locFrom, undefined, store, stack, 'undefined');\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = contextTid; // Note: second arg is NOT context override\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse), ', kind:', tstr(contextTeeToUse.kind));\n\n    ASSERT(funcTee && contextTeeToUse);\n\n    let kindTid = 'undefined';\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'A') {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_REDUCE_ARR_KIND', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Assuming the .filter would return an array of the same kind.');\n      return playActionArr(locFrom, store, undefined, stack, kindTid);\n    }\n\n    let accTid = kindTid;\n    if (argCount > 1) {\n      // The second arg is the first accumulator, otherwise the kind of the arg is. They don't need to be the same.\n      accTid = callArgs[1];\n    }\n\n    group('Now calling the callback with an accumulator', tstr(accTid), ', a current tid', tstr(kindTid), 'and an index', tstr('number'), 'and the context', tstr(contextTidToUse));\n    let returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 4, [accTid, kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n    log('The Array#reduce lambda call resulted in', tstr(returnTid), '. It ought to be the same as the accumulator', tstr(accTid), 'so merging them now');\n    returnTid = merge(locFrom, store, returnTid, accTid);\n    groupEnd();\n\n    log('Returning the returned value which is accumulator:', tstr(returnTid));\n    return returnTid;\n  });\n  createFunction(store, 'Array#reduceRight', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return playActionArr(locFrom, undefined, store, stack, 'undefined');\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = contextTid; // Note: second arg is NOT context override\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    let kindTid = 'undefined';\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'A') {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_REDUCE_ARR_KIND', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Assuming the .filter would return an array of the same kind.');\n      return playActionArr(locFrom, store, undefined, stack, kindTid);\n    }\n\n    let accTid = kindTid;\n    if (argCount > 1) {\n      // The second arg is the first accumulator, otherwise the kind of the arg is. They don't need to be the same.\n      accTid = callArgs[1];\n    }\n\n    group('Now calling the callback with an accumulator', tstr(accTid), ', a current tid', tstr(kindTid), 'and an index', tstr('number'), 'and the context', tstr(contextTidToUse));\n    let returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 4, [accTid, kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n    log('The Array#reduceRight lambda call resulted in', tstr(returnTid), '. It ought to be the same as the accumulator', tstr(accTid), 'so merging them now');\n    returnTid = merge(locFrom, store, returnTid, accTid);\n    groupEnd();\n\n    log('Returning the returned value which is accumulator:', tstr(returnTid));\n    return returnTid;\n  });\n  createFunction(store, 'Array#reverse', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'A') {\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n    }\n\n    // Since the array kind os irrelevant to `reverse`, we're gonna skip checking it entirely.\n    // The reverse is in place and returns the same context\n    return contextTid;\n  });\n  createFunction(store, 'Array#shift', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('ARRAY_SHIFT_UNDERFLOW', locFrom, callerTee.tid);\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    // Context ought to be an array type (although it could be anything, of course)\n    const contextTee = store.get(contextTid);\n    ASSERT(contextTee, 'should receive valid tee', contextTid);\n    if (contextTid[0] !== 'A') {\n      // We may want to refine this check and support array-like\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n\n      log('Since context is not an array we now return', tstr('undefined'));\n      return 'undefined';\n    }\n\n    const kindTee = store.get(contextTee.kind);\n    if (kindTee.type === 'H') {\n      store.linter.check('ARRAY_SHIFT_EMPTY', locFrom, callerTee.tid);\n      log('Array had no kind yet, must be empty, sealing kind to', tstr('undefined'), 'and returning it');\n      store.linkTo(kindTee, store.get('undefined'));\n      contextTee.kind = 'undefined';\n      return 'undefined';\n    }\n\n    log('The array kind is:', tstr(kindTee.tid));\n    return kindTee.tid;\n  });\n  createFunction(store, 'Array#slice', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    // Context ought to be an array type (although it could be anything, of course)\n    const contextTee = store.get(contextTid);\n    ASSERT(contextTee, 'should receive valid tee', contextTid);\n    let kind = 'undefined';\n    if (contextTee.type === 'A') {\n      log('Creating a new array with the same kind:', tstr(contextTee.kind));\n      kind = contextTee.kind;\n    } else {\n      // We may want to refine this check and support array-like\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n      log('Slice was called with a context that was not array so pushing an array of', tstr('undefined'));\n    }\n\n    return playActionArr(locFrom, store, undefined, stack, kind);\n  });\n  createFunction(store, 'Array#some', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_LAMBDA_UNDERFLOW', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return 'boolean';\n    }\n\n    if (argCount > 2) {\n      store.linter.check('ARRAY_LAMBDA_OVERFLOW', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    let kindTid = 'undefined';\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'A') {\n      kindTid = contextTeeToUse.kind;\n      ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n      const kindTee = store.get(kindTid);\n      if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call. Returning a', tstr('boolean'));\n      return 'boolean';\n    }\n\n    group('Now calling the callback with a', tstr(kindTid), 'and a', tstr('number'), 'and the array being iterated:', tstr(contextTidToUse));\n    const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kindTid, 'number', contextTidToUse], -1, store, '', store.instanceId, true);\n    log('The Array#some lambda call resulted in', tstr(returnTid));\n    groupEnd();\n\n    if (returnTid !== 'boolean' || returnTid !== 'undefined') {\n      // Technically it doesn't really matter but for the sake of consistency, the callback ought to either return a boolean or undefined\n      store.linter.check('ARRAY_ANYSOME_RETURNS', locFrom, callerTee.tid);\n    }\n\n    return 'boolean';\n  });\n  createFunction(store, 'Array#sort', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // We could warn against no args but it could very well be intentional ...\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0) {\n      const funcTid = callArgs[0];\n      const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n      log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n      const funcTee = store.get(funcTid);\n      const contextTeeToUse = store.get(contextTidToUse);\n      ASSERT(funcTee && contextTeeToUse);\n\n      let kindTid = 'undefined';\n      // Would be nice to support array-likes in the future...\n      if (contextTeeToUse.type === 'A') {\n        kindTid = contextTeeToUse.kind;\n        ASSERT(typeof kindTid === 'string', 'kinds should be strings', kindTid);\n        const kindTee = store.get(kindTid);\n        if (kindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n          store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n        }\n      } else {\n        store.linter.check('ARRAY_LAMBDA_ARR_CONTEXT', locFrom, callerTee.tid);\n      }\n\n      if (funcTee.type !== 'F') {\n        store.linter.check('ARRAY_LAMBDA_FUNC_ARG', locFrom, callerTee.tid);\n        log('Cannot invoke this so ignoring the call. Assuming the .filter would return an array of the same kind.');\n        return playActionArr(locFrom, store, undefined, stack, kindTid);\n      }\n\n      group('Now calling the callback with the kind', tstr(kindTid), ', twice');\n      const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 2, [kindTid, kindTid], -1, store, '', store.instanceId, true);\n      log('The Array#sort lambda call resulted in', tstr(returnTid), '(which we ignore)');\n      groupEnd();\n    }\n\n    log('Returning the original context:', tstr(contextTid));\n    return contextTid;\n  });\n  createFunction(store, 'Array#splice', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      // Offset of the splice\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      // Number of elements to remove\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    const newElements = callArgs.slice(2);\n    if (argCount > 2) {\n      log('Injecting the following tids into the array, meaning we will merge them with its kind: [', newElements.map(tstr).join(', '), ']');\n    }\n\n    // Context ought to be an array type (although it could be anything, of course)\n    const contextTee = store.get(contextTid);\n    ASSERT(contextTee, 'should receive valid tee', contextTid);\n    let kind = 'undefined'; // Prefer the type of the arg being injected. But otherwise default to undefined\n    if (contextTee.type === 'A') {\n      log('Creating a new array with the same kind:', tstr(contextTee.kind));\n      kind = contextTee.kind;\n    } else {\n      // We may want to refine this check and support array-like\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n\n      if (newElements.length) {\n        log('Slice was called on a non array that injects new elements. This is broken as heck. Returning array with kind of one of the injected elements:', tstr(newElements[newElements.length - 1]));\n        kind = newElements[0];\n      } else {\n        log('Slice was called with a context that was not array so returning an array of', tstr('undefined'));\n      }\n    }\n\n    if (newElements.length) {\n      log('Merging the new elements with the array kind now...');\n      kind = mergeAll(locFrom, newElements, store);\n    }\n\n    if (contextTee.type === 'A') {\n      contextTee.kind = kind;\n    }\n\n    ASSERT_TID(kind);\n\n    // Note: splice does return a NEW array. So create its tid now.\n    // Splice returns an array with the removed elements, if any.\n    return playActionArr(locFrom, store, undefined, stack, kind);\n  });\n  createFunction(store, 'Array#toString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // TODO: very technically this should do a toString() of the kind and follow that rabbit hole but :shrug:\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'A') {\n      store.linter.check('ARRAY_JOIN_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Array#toLocaleString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // TODO: very technically this should do a toString() of the kind and follow that rabbit hole but :shrug:\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    // Meh. Ignoring this one.\n    // if (argCount > 1 && callArgs[1] !== '...') {\n    //   store.linter.check('BUILTIN_ARG1_', locFrom, callerTee.tid);\n    // }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'A') {\n      store.linter.check('ARRAY_JOIN_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Array#unshift', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_UNSHIFT_NO_ARGS', locFrom, callerTee.tid);\n    }\n\n    // Context ought to be an array type (although it could be anything, of course)\n    const contextTee = store.get(contextTid);\n    ASSERT(contextTee, 'should receive valid tee', contextTid)\n\n    if (contextTee.type !== 'A') {\n      store.linter.check('ARRAY_UNSHIFT_CONTEXT', locFrom, callerTee.tid);\n      log('Returning a', tstr('number'), 'but not sure what the runtime would do here');\n      return 'number';\n    }\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_UNSHIFT_NO_ARGS', locFrom, callerTee.tid);\n      log('Returning a', tstr('number'), '(new array length)');\n      return 'number';\n    }\n\n    let kindTee = store.get(contextTee.kind);\n    if (kindTee.type === 'H') {\n      log('Array had no kind yet, setting it to the merged tee of the unshift args');\n      const argTee = store.get(callArgs[0]);\n      log('Setting it to the tid of the first arg which will be merged with all the others:', tstr(argTee.tid));\n      store.linkTo(kindTee, argTee);\n      contextTee.kind = argTee.tid;\n\n      kindTee = argTee;\n    }\n\n    log('Merging all args with the kind', tstr(kindTee.tid));\n    // First test the merge (without changes or lints). If that fails, issue (only) a mono_kind error\n    if (mergeTestAll(locFrom, callArgs, store)) {\n      // Have to do an actual merge, anyways, because it may mutate tees\n      const kind = mergeAll(locFrom, callArgs, store);\n      contextTee.kind = merge(locFrom, store, kind, contextTee.kind);\n    } else {\n      // This is what happens when you do [1].unshift('a')\n      store.linter.check('ARR_MONO_KIND', locFrom, callerTee.tid);\n    }\n\n    // Array unshift returns the new size of the array\n    return 'number';\n  });\n  createFunction(store, 'Array#values', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'A') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_ARRAY', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'undefined';\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n\n  playActionBuiltinObj(store, 'Array.prototype', new Map([\n    ['__proto__', 'Object.prototype'],\n    ['concat', 'Array#concat'],\n    ['copyWithin', 'Array#copyWithin'],\n    ['every', 'Array#every'],\n    ['entries', 'Array#entries'],\n    ['fill', 'Array#fill'],\n    ['forEach', 'Array#forEach'],\n    ['filter', 'Array#filter'],\n    ['find', 'Array#find'],\n    ['findIndex', 'Array#findIndex'],\n    ['flat', 'Array#flat'],\n    ['flatMap', 'Array#flatMap'],\n    ['includes', 'Array#includes'],\n    ['indexOf', 'Array#indexOf'],\n    ['lastIndexOf', 'Array#lastIndexOf'],\n    ['join', 'Array#join'],\n    ['length', 'number'],\n    ['keys', 'Array#keys'],\n    ['map', 'Array#map'],\n    ['pop', 'Array#pop'],\n    ['push', 'Array#push'],\n    ['reduce', 'Array#reduce'],\n    ['reduceRight', 'Array#reduceRight'],\n    ['reverse', 'Array#reverse'],\n    ['shift', 'Array#shift'],\n    ['slice', 'Array#slice'],\n    ['some', 'Array#some'],\n    ['sort', 'Array#sort'],\n    ['splice', 'Array#splice'],\n    ['toString', 'Array#toString'],\n    ['toLocaleString', 'Array#toLocaleString'],\n    ['unshift', 'Array#unshift'],\n    ['values', 'Array#values'],\n  ]));\n  createFunction(store, 'Array.from', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0) {\n      // Simple edge case\n      if (callArgs[0] === 'string') {\n        log('Array.from(' + tstr('string') + ') is an array of string');\n        return playActionArr(locFrom, store, undefined, stack, 'string');\n      }\n    }\n\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    return 'undefined';\n  });\n  createFunction(store, 'Array.isArray', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_ISARRAY_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    // Ignore the first arg type. Technically we could eliminate this call entirely because we should know which\n    // values are or aren't arrays. But due to function args being polymorphic that seems unnecessarily tight.\n\n    if (argCount > 1) {\n      store.linter.check('ARRAY_ISARRAY_ARG2', locFrom, callerTee.tid);\n    }\n\n    return 'boolean';\n  });\n  createFunction(store, 'Array.of', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('ARRAY_ISARRAY_ARGLESS', locFrom, callerTee.tid);\n      const pid = createPlaceholder('HAO', 'array from without params');\n      return playActionArr(locFrom, store, undefined, stack, pid);\n    }\n\n    let kindTid = mergeAll(locFrom, callArgs, store);\n\n    log('Returning an array of kind', tstr(kindTid));\n    return playActionArr(locFrom, store, undefined, stack, kindTid);\n  });\n  createConstructor(store, 'Array', 'Array.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    // New behavior is same as without new\n    log(BOLD + 'Array' + RESET + '(' + callArgs.map(tstr).join(', ')+')');\n\n    // Edge case: if there was a spread and there was one arg, or two with the first being a number, then create\n    // an array with the same kind and call it a day. For anything else issue a lint and merge the array kind with\n    // all the other elements.\n\n    let kindTid = 'undefined';\n    if (spreadAt === 0 || (spreadAt === 1 && callArgs[0] === 'number')) {\n      // This is Array(...x) or Array(10, ...x). Consider the array kind equal to the kind of x, which is the first arg\n      // Don't care about other spreadAt cases. TODO: not sure this is even a special case here\n      ASSERT((spreadAt === 0 && argCount === 1) || (spreadAt === 1 && argCount === 2), 'argcount should match spread index', argCount, spreadAt);\n      log('The spread into Array causes an array by the same kind:', tstr(callArgs[1]));\n      kindTid = callArgs[spreadAt === 1 ? 1 : 0];\n    } else if (argCount === 0) {\n      log('This is `Array()` and it should do the same as `[]`');\n\n      kindTid = createPlaceholder(store, 'HACKE', 'Array() kind');\n    } else if (argCount === 1 && callArgs[0] === 'number') {\n      // Check if TOP is a number. In that case, pop the arg and return array with unresolved kind\n      log('This is `Array(number)` and it should do the same as `[]`, drop the arg');\n\n      kindTid = createPlaceholder(store, 'HACKN', 'Array(number) kind');\n    } else {\n      ASSERT(argCount > 0 && !(argCount === 1 && callArgs[0] === 'number'), 'this else branch should mean there are args and it is not just a number');\n      // Use first arg as kind and merge remaining ones into it\n      log('This is `Array(args)` with either multiple args or a single non-number arg. Merge them:', callArgs.map(tstr).join(', '));\n      kindTid = mergeAll(locFrom, callArgs, store);\n    }\n    log('Resulting kind:', tstr(kindTid));\n    return playActionArr(locFrom, store, undefined, stack, kindTid);\n  }, [['from', 'Array.from'], ['isArray', 'Array.isArray'], ['of', 'Array.of']]);\n\n  createFunction(store, 'Boolean#toString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BOOLEAN_TOSTRING_ARGS', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'boolean') {\n      store.linter.check('BOOLEAN_TOSTRING_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Boolean#valueof', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'boolean') {\n      store.linter.check('BUILTIN_CONTEXT_BOOL', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('boolean'));\n    return 'boolean';\n  });\n  playActionBuiltinObj(store, 'Boolean.prototype', new Map([\n    ['__proto__', 'Object.prototype'],\n    ['length', 'number'],\n    ['toString', 'Boolean#toString'],\n    ['valueof', 'Boolean#valueof'],\n  ]));\n  createConstructor(store, 'Boolean', 'Boolean.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // No need to coerce the arg, that's the whole point of calling this function. Arguably this shouldn't be necessary.\n\n    return 'boolean';\n  });\n\n  createFunction(store, 'Error#toString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('ERROR_TOSTRING_ARGS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  playActionBuiltinObj(store, 'Error.prototype', new Map([\n    ['__proto__', 'Object.prototype'],\n    ['message', 'string'],\n    ['name', 'string'], // \"Error\"\n    ['stack', 'string'],\n    ['toString', 'Error#toString'],\n  ]));\n  createConstructor(store, 'Error', 'Error.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    // Without `new` do the same as if it had been called with `new`\n    if (!isNew) {\n      return playActionNew(locFrom, store, stack, spreadAt, 'Error', callArgs);\n    }\n\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount >= 1) {\n      if (callArgs[0] === 'string') {\n        // It is optional. If it is not given then the .message property is not set at all.\n        const tee = store.get(contextTid);\n        ASSERT(tee && tee.props, 'error context should be an object', tee);\n        tee.setProp('message', 'string');\n      } else {\n        store.linter.check('ERROR_STRING_ARG', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount >= 2) {\n      store.linter.check('ERROR_ARITY', locFrom, callerTee.tid);\n    }\n\n    return contextTid;\n  });\n\n  createFunction(store, 'Function#apply', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    log('Received args:', callArgs.map(tstr).join(', '));\n\n    // Context ought to be a callable of sorts\n    log('Context ought to be callable:', tstr(contextTid));\n    const calleeTee = store.get(contextTid);\n\n    // The first arg of the `f.call()` expression is the context of the actual call to `f`\n    const givenContext = argCount > 0 ? callArgs[0] : 'undefined';\n    log('Given context:', tstr(givenContext));\n    // The bound context cannot be overridden through .call, .apply, or .bind\n    const calleeContext = calleeTee.boundContext ? calleeTee.boundContext : givenContext;\n    if (calleeTee.boundContext) log('The function was bound to', tstr(calleeTee.boundContext));\n    log('The context of the .apply invocation will be:', tstr(calleeContext));\n\n    const arrTid = argCount > 1 ? callArgs[1] : 'undefined';\n\n    if (argCount > 2) {\n      // Drop the excessive args\n      store.linter.check('FUNCTION_APPLY_ARGCOUNT', locFrom, callerTee.tid);\n    }\n\n    // Get the kind of the array, assuming that's what it is. TODO: what about string and iterables?\n    const kindTid = argCount === 0 ? 'undefined' : playActionKind(locFrom, store, stack, arrTid);\n    log('The arguments will be:', tstr(kindTid));\n\n    const indentBefore = getIndent();\n\n    group('Now .call invoking the function...');\n    const returnTid = metaCall(locFrom, contextTid, calleeContext, false, stack, argCount > 1 ? 1 : 0, [kindTid], argCount >= 2 ? 0 : -1, store, '', store.instanceId, false);\n    log('The .apply resulted in', tstr(returnTid));\n    groupEnd();\n\n    ASSERT(indentBefore === getIndent(), 'indent should be same before and after call');\n\n    return returnTid;\n  });\n  createFunction(store, 'Function#bind', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    log('Args:', callArgs.map(tstr).join(', '));\n\n    // Context ought to be a callable of sorts\n    log('Context ought to be callable:', tstr(contextTid));\n    const callee = store.get(contextTid);\n    ASSERT(callee);\n\n    // The first arg of the `f.bind()` expression is the context of the actual call to `f`\n    const givenContext = argCount > 0 ? callArgs[0] : 'undefined';\n    log('Given context:', tstr(givenContext));\n    // The bound context cannot be overridden through .call, .apply, or .bind\n    const calleeContext = callee.boundContext ? callee.boundContext : givenContext;\n    if (callee.boundContext) log('The function was bound to', tstr(calleeTee.boundContext));\n    log('The context the function is .bind to will be:', tstr(calleeContext));\n\n    const isClass = callee.funcType.startsWith('class');\n\n    ASSERT(typeof callee.thisAccess === 'boolean', 'callee have this');\n    if (callee.thisAccess && calleeContext === 'undefined') {\n      store.linter.check('FUNCTION_BIND_BAD_CONTEXT', locFrom, callerTee.tid);\n    }\n    if (isClass) {\n      store.linter.check('FUNCTION_BIND_CLASS', locFrom, callerTee.tid);\n      if (calleeContext !== 'undefined') {\n        store.linter.check('FUNCTION_BIND_CLASS_CONTEXT', locFrom, callerTee.tid);\n      }\n    } else if (!callee.thisAccess && calleeContext !== 'undefined') {\n      // Note: global would be explicit since this is strict mode\n      log('This function does not contain the keyword `this` and the context is not `undefined`');\n      store.linter.check('FUNCTION_BIND_THISLESS_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    const boundParams = callArgs.slice(1); // Ignore first arg since that's the context\n    log('Bound params:', boundParams.map(tstr).join(', ') || '<none>');\n\n    // Do not bind more args than there are params\n    while (boundParams.length > callee.paramNames.length) {\n      boundParams.pop();\n    }\n\n    // const [funcName, paramNames, body] = data\n    const tid = (isClass ? 'CB' : 'FB') + String(++store.uid);\n\n    const props = new Map([ // This is fresh so do not copy it\n      // ['prototype', null], // TODO: bound functions cannot be `new`ed, but they can be `super`ed :/\n      ['__proto__', 'Function.prototype'],\n    ]);\n\n    if (callee.funcType.startsWith('method')) {\n      store.superStack.push(callee.superPropOwner);\n    }\n    const funcTid = playActionFunc(locFrom, {\n      store,\n      tid,\n      stack,\n      closure: callee.parentClosure, // This doesn't change. You can't change this.\n      callerContext: calleeContext,\n      nid: isClass ? 'class' : callee.nid,\n      funcName: callee.funcExprName,\n      paramNames: callee.paramNames || [], // Classes can be bound but have no params here\n      paramBindingNames: callee.paramBindingNames || [], // Classes can be bound but have no params here\n      hasRest: callee.hasRest,\n      minParamRequired: callee.minParamRequired,\n      body: callee.body,\n      funcType: callee.funcType + (callee.funcType.endsWith('-bound') ? '' : '-bound'),\n      thisAccess: callee.thisAccess,\n      reachableNames: callee.reachableNames,\n      ownerClass: callee.ownerClass, // Needed to resolve syntactical owner class for bound class\n      superClass: callee.superClass, // Edge case: the super bond survives a .bind(). I know, right.\n      boundContext: calleeContext,\n      boundParams: boundParams,\n      funcTokenIndex: undefined,\n      fromFilename: callee.fromFilename, // Actions are still corresponding to nodes in/from this file\n      fromColumn: callee.fromColumn,\n      fromLine: callee.fromLine,\n      userDesc: callee.userDesc + ', bound',\n      useProps: props,\n    });\n    if (callee.funcType.startsWith('method')) {\n      store.superStack.pop();\n    }\n\n    const btee = store.get(funcTid);\n    ASSERT(btee.tid === tid, 'should use passed on tid', btee.tid, tid);\n    btee._type = 'bind';\n    btee._clone = 'bind(' + btee.tid + ', ' + btee._clone + ')';\n\n    log('Created a bound function for', tstr(callee.tid), 'as', tstr(tid));\n\n    return funcTid;\n  });\n  createFunction(store, 'Function#call', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // Context ought to be a callable of sorts\n    log('Context ought to be callable:', tstr(contextTid));\n    const calleeTee = store.get(contextTid);\n\n    // The first arg of the `f.call()` expression is the context of the actual call to `f`\n    const givenContext = argCount > 0 ? callArgs[0] : 'undefined'\n    // The bound context cannot be overridden through .call, .apply, or .bind\n    const calleeContext = calleeTee.boundContext ? calleeTee.boundContext : givenContext;\n    log('The context of the .call invocation will be:', tstr(calleeContext));\n\n    group('Now .call invoking the function...');\n    const returnTid = metaCall(locFrom, contextTid, calleeContext, false, stack, Math.max(0, argCount - 1), callArgs.slice(1), -1, store, '', store.instanceId, false);\n    log('The .call resulted in', tstr(returnTid));\n    groupEnd();\n\n    return returnTid;\n  });\n  createFunction(store, 'Function#toString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('FUNCTION_TOSTRING_ARGS', locFrom, callerTee.tid);\n    }\n\n    const tee = store.get(contextTid);\n    if (tee.type !== 'F') {\n      store.linter.check('FUNCTION_TOSTRING_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  playActionBuiltinObj(store, 'Function.prototype', new Map([\n    ['__proto__', 'Object.prototype'],\n    ['apply', 'Function#apply'],\n    ['bind', 'Function#bind'],\n    ['call', 'Function#call'],\n    ['length', 'number'],\n    ['name', 'string'],\n    ['toString', 'Function#toString'],\n  ]));\n  createConstructor(store, 'Function', 'Function.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n    // The model cannot support this :shrug:\n    store.linter.check('TOFIX', locFrom, 'the model does not support dynamic Function creation');\n  });\n\n  createFunction(store, 'JSON.stringify', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n\n    if (argCount === 0) {\n      store.linter.check('JSON_STRINGIFY_ARGLESS', locFrom, callerTee.tid);\n    } else {\n      const tid = callArgs[0];\n      const tee = store.get(tid);\n      if (!isPrimitive(tid) && tee.type !== 'A' && tee.type !== 'O') {\n        store.linter.check('JSON_STRINGIFY_ARG1', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount >= 2) {\n      const arg2 = callArgs[1];\n      const tee2 = store.get(arg2);\n      if (arg2 !== 'null' && !(tee2.type === 'A' && (tee2.kind === 'string' || tee2.kind === 'number')) && tee2.type !== 'F') {\n        // TODO: we can do a more in depth validation of the function...\n        store.linter.check('JSON_STRINGIFY_ARG2', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount >= 3) {\n      const arg2 = callArgs[2];\n      if (arg2 !== 'null' && arg2.kind !== 'string' || arg2.kind !== 'number') {\n        store.linter.check('JSON_STRINGIFY_ARG3', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount > 3) {\n      store.linter.check('JSON_STRINGIFY_ARG4', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'JSON.parse', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n\n    if (argCount === 0) {\n      store.linter.check('JSON_PARSE_ARGLESS', locFrom, callerTee.tid);\n    } else {\n      const tid = callArgs[0];\n      if (tid !== 'string') {\n        store.linter.check('JSON_PARSE_ARG1', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount >= 2) {\n      const arg2 = callArgs[1];\n      const tee2 = store.get(arg2);\n      if (tee2.type === 'F') {\n        // TODO: we can do a more in depth validation of the function...\n        store.linter.check('JSON_PARSE_ARG2', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount > 2) {\n      store.linter.check('JSON_PARSE_ARG3', locFrom, callerTee.tid);\n    }\n\n    store.linter.check('JSON_PARSE_RETURN', locFrom, callerTee.tid);\n\n    // Best guess: an object of sorts.\n\n    log('Returning a fresh object because that seems to be the most likely');\n    const objTid = playActionObj(locFrom, store, undefined, stack, [], []);\n    log('->', tstr(objTid));\n    return objTid;\n  });\n  playActionBuiltinObj(store, 'JSON', new Map([\n    ['__proto__', 'Object.prototype'],\n    ['parse', 'JSON.parse'],\n    ['stringify', 'JSON.stringify'],\n  ]));\n\n  createFunction(store, 'Map#clear', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_MAP', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'undefined';\n    }\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Map#clear', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_MAP', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'undefined';\n    }\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Map#delete', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_MAP', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'boolean';\n    }\n\n    let keyKind = contextTee.keyKind;\n    ASSERT(keyKind, 'should have a placeholder or more', keyKind);\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    const arg = argCount > 0 ? callArgs[0] : 'undefined';\n    if (argCount > 0 && !testMerge(store, keyKind, arg)) {\n      store.linter.check('MAP_HAS_ARG1', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Merging the arg with the key kind');\n    contextTee.keyKind = merge(locFrom, store, keyKind, arg);\n\n    log('Returning', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Map#entries', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_MAP', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'undefined';\n    }\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Map#forEach', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('MAPSET_FOREACH_ARGLESS', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return 'undefined';\n    }\n\n    if (argCount > 2) {\n      store.linter.check('MAPSET_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    // Would be nice to support array-likes in the future...\n    if (contextTeeToUse.type === 'M') {\n      const keyKindTid = contextTeeToUse.keyKind;\n      ASSERT(typeof keyKindTid === 'string', 'kinds should be strings', keyKindTid);\n      const keyKindTee = store.get(keyKindTid);\n      if (keyKindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n\n      const valueKindTid = contextTeeToUse.kind;\n      ASSERT(typeof valueKindTid === 'string', 'kinds should be strings', valueKindTid);\n      const valueKindTee = store.get(valueKindTid);\n      if (valueKindTee.type === 'H') { // If placeholder then we haven't seen any mutations yet\n        store.linter.check('ARRAY_LAMBDA_ARR_KIND', locFrom, callerTee.tid);\n      }\n\n      if (keyKindTee.type === 'H' && valueKindTee.type === 'H') {\n        store.linter.check('MAP_FOREACH_MAP_KIND', locFrom, callerTee.tid);\n      } else if (keyKindTee.type === 'H') {\n        store.linter.check('MAP_FOREACH_MAP_KEY_KIND', locFrom, callerTee.tid);\n      } else if (valueKindTee.type === 'H') {\n        store.linter.check('MAP_FOREACH_MAP_VALUE_KIND', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('MAP_FOREACH_CONTEXT', locFrom, callerTee.tid);\n      // It's very unlikely that we can call the callback with reasonable args ...\n      // Should we ignore it or just call it with undefineds, anyways?\n    }\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('MAPSET_FOREACH_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke first arg so ignoring the call');\n      return 'undefined';\n    }\n\n    const keyKindTid = contextTeeToUse.kind || 'undefined'; // Note: key is the SECOND arg of the callback\n    const valueKindTid = contextTeeToUse.kind || 'undefined'; // Note: value is the FIRST arg of the callback\n\n    group('Now calling the callback with a', tstr(valueKindTid), 'and', tstr(keyKindTid), 'and the map being iterated:', tstr(contextTidToUse));\n    const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [valueKindTid, keyKindTid, contextTidToUse], -1, store, '', store.instanceId, true);\n    log('The Map#forEach lambda call resulted in', tstr(returnTid));\n    groupEnd();\n\n    // Ignore return value. And even though from a purist perspective it _ought_ to be undefined, we don't care.\n    return 'undefined';\n  });\n  createFunction(store, 'Map#get', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    const contextTee = store.get(contextTid);\n\n    log('- Called', tstr(contextTee.tid) + '.get(', tstr(callArgs[0]), ')');\n    log('- Current Map key tid:', tstr(contextTee.keyKind));\n    log('- Current Map value tid:', tstr(contextTee.kind));\n\n\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('MAP_GET_CONTEXT', locFrom, callerTee.tid);\n      \n      // As it stands we can't really do anything here so just return `undefined` as the safest possible value here.\n      return 'undefined';\n    }\n    \n    const keyKind = contextTee.keyKind;\n    const valueKind = contextTee.kind;\n    ASSERT(typeof keyKind === 'string', 'kinds are strings', keyKind);\n    ASSERT(typeof valueKind === 'string', 'kinds are strings', valueKind);\n\n    if (argCount === 0) {\n      store.linter.check('MAP_GET_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    const arg = argCount > 0 ? callArgs[0] : 'undefined';\n    if (argCount > 0 && !testMerge(store, keyKind, arg)) {\n      store.linter.check('MAP_GET_ARG1', locFrom, callerTee.tid);\n    }\n    \n    if (argCount > 1) {\n      store.linter.check('MAP_GET_ARG2', locFrom, callerTee.tid);\n    }\n\n    group('Merging the arg with the key kind');\n    contextTee.keyKind = merge(locFrom, store, keyKind, arg);\n    groupEnd();\n\n    const valueKindTee = store.get(valueKind);\n    if (valueKindTee.type === 'H') {\n      log('Reading the value of a Map that is undetermined. Now sealing it to', tstr('undefined'));\n      contextTee.kind = merge(locFrom, store, valueKind, 'undefined');\n    }\n\n    log('Returning the value kind:', tstr(contextTee.kind));\n    return contextTee.kind;\n  });\n  createFunction(store, 'Map#has', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n\n    log('- Called', tstr(contextTee.tid) + '.has(', tstr(callArgs[0]), ')');\n    log('- Current Map key tid:', tstr(contextTee.keyKind));\n    log('- Current Map value tid:', tstr(contextTee.kind));\n\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_MAP', locFrom, callerTee.tid);\n\n      // Ignore the key, leave a bool on the stack\n      return 'boolean';\n    }\n\n    // Get the arg\n    let arg = argCount > 0 ? callArgs[0] : 'undefined';\n    ASSERT_TID(contextTee.keyKind);\n\n    // Merge key kind with the arg\n    const keyKindTee = store.get(contextTee.keyKind);\n    if (keyKindTee.type === 'H') {\n      store.linter.check('ARRAY_SHIFT_EMPTY', locFrom, callerTee.tid);\n      log('Map key kind was undetermined. Setting it to the arg tid:', tstr(arg));\n      store.linkTo(keyKindTee, store.get(arg));\n      contextTee.keyKind = keyKindTee.alias.tid;\n    } else {\n      log('Merging the map key kind with the tid of the first arg:', tstr(keyKindTee.tid), tstr(arg));\n      ASSERT(keyKindTee, 'should have a tee', keyKindTee);\n      ASSERT_TID(arg);\n      contextTee.keyKind = merge(locFrom, store, keyKindTee.tid, arg);\n    }\n\n    log('Merging the arg with the key kind');\n    contextTee.keyKind = merge(locFrom, store, contextTee.keyKind, arg);\n\n    log('Returning', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Map#keys', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_MAP', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'undefined';\n    }\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Map#set', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('MAP_SET_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount === 1) {\n      store.linter.check('MAP_SET_ARG2', locFrom, callerTee.tid);\n    }\n    if (argCount > 2) {\n      store.linter.check('MAP_SET_ARG3', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n\n    log('- Called', tstr(contextTee.tid) + '.set(', tstr(callArgs[0]), ',', tstr(callArgs[1]), ')');\n    log('- Current Map key tid:', tstr(contextTee.keyKind));\n    log('- Current Map value tid:', tstr(contextTee.kind));\n\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('MAP_SET_CONTEXT', locFrom, callerTee.tid);\n\n      // As it stands we can't really do anything here so just return the context as the .set would\n      return contextTid;\n    }\n\n    const keyArg = argCount > 0 ? callArgs[0] : 'undefined';\n    log('Merging first arg', tstr(keyArg), 'with key kind:', tstr(contextTee.keyKind));\n    contextTee.keyKind = merge(locFrom, store, keyArg, contextTee.keyKind, false);\n\n    const valueArg = argCount > 1 ? callArgs[1] : 'undefined';\n    log('Merging second arg', tstr(valueArg), 'with value kind:', tstr(contextTee.kind));\n    contextTee.kind = merge(locFrom, store, valueArg, contextTee.kind, false);\n\n    log('Returning the context');\n    return contextTid;\n  });\n  createFunction(store, 'Map#values', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'M') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_MAP', locFrom, callerTee.tid);\n      // Just return a bool and ignore the call otherwise\n      return 'undefined';\n    }\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  playActionBuiltinObj(store, 'Map.prototype', new Map([\n    ['__proto__', 'Object.prototype'],\n    ['clear', 'Map#clear'],\n    ['delete', 'Map#delete'],\n    ['entries', 'Map#entries'],\n    ['forEach', 'Map#forEach'],\n    ['get', 'Map#get'],\n    ['has', 'Map#has'],\n    ['keys', 'Map#keys'],\n    ['set', 'Map#set'],\n    ['size', 'number'],\n    ['values', 'Map#values'],\n  ]));\n  createConstructor(store, 'Map', 'Map.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // A Map expects zero args or one arg that is an iterable (array, for now) of arrays of key:value tuples. That's not gonna work well in our model.\n    // Perhaps in the future we can track explicit tuples somehow. Maybe they can be promotable types, which start as tuples and can be locked or mutated but not both?\n\n    if (!isNew) {\n      // Runtime error\n      store.linter.check('MAP_WITHOUT_NEW', locFrom, callerTee.tid);\n    }\n\n    log('There are', argCount, 'args');\n    let keyKind;\n    let valueKind;\n\n    if (argCount > 0) {\n      const tid = callArgs[0];\n      log('First arg is', tstr(tid));\n      const tee = store.get(tid);\n      if (tee.type === 'A') {\n        // It has to be an array with zero or more arrays TODO: s/array/iterable\n        const outerKind = tee.kind;\n        const outerKindTee = store.get(outerKind);\n        log('- And its kind is:', tstr(outerKind));\n        if (outerKindTee.type === 'H') {\n          log('This is a read of the kind and it was undetermined. Seal the kind of the array to `undefined`');\n          store.linkTo(outerKindTee, store.get('undefined'));\n          tee.kind = 'undefined';\n          // Set key/value kind to fresh placeholders (below)\n          store.linter.check('MAP_EMPTY_ARRAY', locFrom, callerTee.tid);\n        } else {\n          // This ought to be a tuple so we got to check that now\n          // Due to limitation in this model we can only set key and value ot the same kind\n          // That's hardly ever what you want to do (besides string:string) so manual .set loop is the best workaround\n          if (outerKindTee.type !== 'A') {\n            store.linter.check('MAP_ARG1_SUB_ARR', locFrom, callerTee.tid);\n          } else {\n            const innerKind = outerKindTee.kind;\n            const innerKindTee = store.get(innerKind);\n            log('  - Kind of the inner array is', tstr(innerKind), '->', tstr(innerKindTee.tid));\n            if (innerKindTee.type === 'H') {\n              store.linter.check('MAP_EMPTY_ARRAY', locFrom, callerTee.tid);\n              log('Since this is \"reading\" the kind from the array, we will now seal the kind of the array to', tstr('undefined'));\n              store.linkTo(innerKindTee, store.get('undefined'));\n              outerKindTee.kind = 'undefined';\n              keyKind = 'undefined';\n              valueKind = 'undefined';\n            } else {\n              keyKind = innerKindTee.tid;\n              valueKind = innerKindTee.tid;\n            }\n          }\n        }\n      } else if (tee.type === 'M') {\n        log('A Map instance is a valid arg type. Share the key (', tstr(tee.keyKind), ') and value (', tstr(tee.kind), ') kinds');\n\n        const keyKindTee = store.get(tee.keyKind);\n        const valueKindTee = store.get(tee.kind);\n\n        if (keyKindTee.type === 'H') {\n          log('The map had an undetermined key kind; sharing the placeholder because why not', tstr(keyKindTee.tid));\n        }\n        if (valueKindTee.type === 'H') {\n          log('The map had an undetermined value kind; sharing the placeholder because why not', tstr(valueKindTee.tid));\n        }\n\n        keyKind = tee.keyKind;\n        valueKind = tee.kind;\n      } else {\n        store.linter.check('MAP_ARG1', locFrom, callerTee.tid);\n        // Whatever. The key/value kind will get fresh placeholders below.\n      }\n    }\n    log('Resolved key and value kinds based on arg:', tstr(keyKind), tstr(valueKind));\n\n    if (keyKind === undefined) {\n      keyKind = createPlaceholder(store, 'HMK', 'new Map() key');\n    }\n\n    if (valueKind === undefined) {\n      valueKind = createPlaceholder(store, 'HMV', 'new Map() value');\n    }\n\n    log('Final Resolved key and value kinds:', tstr(keyKind), tstr(valueKind));\n\n    if (argCount > 1) {\n      store.linter.check('MAP_ARG2', locFrom, callerTee.tid);\n    }\n\n    ASSERT_TID(keyKind);\n    ASSERT_TID(valueKind);\n\n    return playActionMap(locFrom, store, undefined, stack, keyKind, valueKind);\n  });\n\n  createFunction(store, 'Math.abs', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.acos', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.acosh', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.asin', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.asinh', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.atan', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.atanh', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.atan2', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount === 0 || callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount <= 1 || callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.cbrt', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.ceil', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.clz32', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.cos', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.cosh', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.exp', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.expm1', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.floor', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.fround', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.hypot', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount !== 1) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount === 1) {\n      store.linter.check('BUILTIN_ARG2_MISSING', locFrom, callerTee.tid);\n    }\n\n    callArgs.forEach((tid, i) => {\n      if (tid !== 'number') store.linter.check('MATH_ARG_NUMBER', locFrom, callerTee.tid, i);\n    });\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.imul', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount === 0 || callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount <= 1 || callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.log', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.log1p', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.log10', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.log2', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.max', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount === 1) {\n      store.linter.check('BUILTIN_ARG2_MISSING', locFrom, callerTee.tid);\n    }\n\n    callArgs.forEach((tid, i) => {\n      if (tid !== 'number') store.linter.check('MATH_ARG_NUMBER', locFrom, callerTee.tid, i);\n    });\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.min', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount !== 1) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount === 1) {\n      store.linter.check('BUILTIN_ARG2_MISSING', locFrom, callerTee.tid);\n    }\n\n    callArgs.forEach((tid, i) => {\n      if (tid !== 'number') store.linter.check('MATH_ARG_NUMBER', locFrom, callerTee.tid, i);\n    });\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.pow', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount === 0 || callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount <= 1 || callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.random', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.round', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.sign', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.sin', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.sinh', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.sqrt', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.tan', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.tanh', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'Math.trunc', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  playActionBuiltinObj(store, 'Math', new Map([\n    ['__proto__', 'Object.prototype'],\n    ['E', 'number'],\n    ['LN2', 'number'],\n    ['LN10', 'number'],\n    ['LOG2E', 'number'],\n    ['PI', 'number'],\n    ['SQRT1_2', 'number'],\n    ['SQRT2', 'number'],\n    ['abs', 'Math.abs'],\n    ['acos', 'Math.acos'],\n    ['acosh', 'Math.acosh'],\n    ['asin', 'Math.asin'],\n    ['asinh', 'Math.asinh'],\n    ['atan', 'Math.atan'],\n    ['atan2', 'Math.atan2'],\n    ['atanh', 'Math.atanh'],\n    ['cbrt', 'Math.cbrt'],\n    ['ceil', 'Math.ceil'],\n    ['clz32', 'Math.clz32'],\n    ['cos', 'Math.cos'],\n    ['cosh', 'Math.cosh'],\n    ['exp', 'Math.exp'],\n    ['expm1', 'Math.expm1'],\n    ['floor', 'Math.floor'],\n    ['fround', 'Math.fround'],\n    ['hypot', 'Math.hypot'],\n    ['imul', 'Math.imul'],\n    ['log', 'Math.log'],\n    ['log10', 'Math.log10'],\n    ['log1p', 'Math.log1p'],\n    ['log2', 'Math.log2'],\n    ['max', 'Math.max'],\n    ['min', 'Math.min'],\n    ['pow', 'Math.pow'],\n    ['random', 'Math.random'],\n    ['round', 'Math.round'],\n    ['sign', 'Math.sign'],\n    ['sin', 'Math.sin'],\n    ['sinh', 'Math.sinh'],\n    ['sqrt', 'Math.sqrt'],\n    ['tan', 'Math.tan'],\n    ['tanh', 'Math.tanh'],\n    ['trunc', 'Math.trunc'],\n  ]));\n\n  createFunction(store, 'Number#toExponential', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'number') {\n      store.linter.check('BUILTIN_CONTEXT_NUMBER', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Number#toFixed', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'number') {\n      store.linter.check('BUILTIN_CONTEXT_NUMBER', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Number#toLocaleString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // Not verifying the second param. Not worth the hassle for me.\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'number') {\n      store.linter.check('BUILTIN_CONTEXT_NUMBER', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Number#toPrecision', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'number') {\n      store.linter.check('BUILTIN_CONTEXT_NUMBER', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Number#toString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n    if (argCount > 1) {\n      store.linter.check('NUMBER_TOSTRING_ARGS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0) {\n      if (callArgs[0] !== 'number') {\n        store.linter.check('NUMBER_TOSTRING_NUM', locFrom, callerTee.tid);\n      }\n    }\n\n    if (contextTid !== 'number') {\n      store.linter.check('NUMBER_TOSTRING_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Number#valueOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'number') {\n      store.linter.check('BUILTIN_CONTEXT_NUMBER', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  playActionBuiltinObj(store, 'Number.prototype', new Map([\n    ['__proto__', 'Object.prototype'],\n    ['toExponential', 'Number#toExponential'],\n    ['toFixed', 'Number#toFixed'],\n    ['toLocaleString', 'Number#toLocaleString'],\n    ['toPrecision', 'Number#toPrecision'],\n    ['toSource', 'Number#toSource'],\n    ['toString', 'Number#toString'],\n    ['valueOf', 'Number#valueOf'],\n  ]));\n  createFunction(store, 'Number.isFinite', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('NUMBER_ISFINITE_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('NUMBER_ISFINITE_ARG1', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('NUMBER_ISFINITE_ARG2', locFrom, callerTee.tid);\n    }\n\n    log('Pushing a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Number.isInteger', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    // The second arg is not really locked down to number, but in that case shouldn't it be a typeof check?\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Pushing a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Number.isNaN', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    // Number.isNaN is not exactly the same as global.isNaN (unlike parseInt and parseFloat)\n\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    // The second arg is not really locked down to number, but in that case shouldn't it be a typeof check?\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Pushing a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Number.isSafeInteger', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    // The second arg is not really locked down to number, but in that case shouldn't it be a typeof check?\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Pushing a', tstr('boolean'));\n    return 'boolean';\n  });\n  createConstructor(store, 'Number', 'String.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    return 'number';\n  }, [\n    ['EPSILON', 'number'],\n    ['MAX_SAFE_INTEGER', 'number'],\n    ['MAX_VALUE', 'number'],\n    ['MIN_SAFE_INTEGER', 'number'],\n    ['MIN_VALUE', 'number'],\n    ['NaN', 'number'],\n    ['NEGATIVE_INFINITY', 'number'],\n    ['POSITIVE_INFINITY', 'number'],\n    ['isFinite', 'Number.isFinite'],\n    ['isInteger', 'Number.isInteger'],\n    ['isNaN', 'Number.isNaN'],\n    ['isSafeInteger', 'Number.isSafeInteger'],\n    ['parseFloat', 'global.parseFloat'],\n    ['parseInt', 'global.parseInt'],\n  ]);\n\n  // All the. Things.\n  createFunction(store, 'Object#hasOwnProperty', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Object#isPrototypeOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && isPrimitive(callArgs[0])) {\n      store.linter.check('BUILTIN_ARG1_OBJ', locFrom, callerTee.tid);\n      if (callArgs[0] === 'undefined' || callArgs[0] === 'null') {\n        log('Actually a runtime error on undefined or null');\n      }\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Object#propertyIsEnumerable', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Object#toLocaleString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      // This should be overridden by subclasses to have args\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Object#toString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'Object#valueOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  playActionBuiltinObj(store, 'Object.prototype', new Map([\n    // ['__proto__', 'null'], // has no __proto__ property\n    ['hasOwnProperty', 'Object#hasOwnProperty'],\n    ['isPrototypeOf', 'Object#isPrototypeOf'],\n    ['propertyIsEnumerable', 'Object#propertyIsEnumerable'],\n    ['toLocaleString', 'Object#toLocaleString'],\n    ['toSource', 'Object#toSource'],\n    ['toString', 'Object#toString'],\n    ['valueOf', 'Object#valueOf'],\n  ]), true);\n  createFunction(store, 'Object.assign', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n      log('Returning', tstr('undefined'));\n      return 'undefined';\n    }\n\n    if (argCount === 1) {\n      store.linter.check('BUILTIN_ARG2_MISSING', locFrom, callerTee.tid);\n      log('Nothing happens. Returning the first arg', tstr(argCount[0]));\n      return argCount[0];\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    // > Properties in the target object are overwritten by properties in the sources if they have the same key. Later sources' properties overwrite earlier ones.\n    // > only copies enumerable and own properties from a source object to a target object\n    // so we look at props and merge those. it woulnd't merge getters/setters but we don't support those anyways ^^\n\n    if (callArgs[0] === 'undefined' || callArgs[0] === 'null' || callArgs[1] === 'undefined' || callArgs[1] === 'null') {\n      // No error but nothing happens. Return the first arg.\n      log('Nothing happens for', tstr('null'), 'and', tstr('undefined'), ', returning the first arg:', tstr(callArgs[0]));\n      return callArgs[0];\n    }\n\n    const tee1 = store.get(callArgs[0]);\n    const tee2 = store.get(callArgs[1]);\n\n    ASSERT(tee1.props && tee2.props, 'both tees should have props of some sort now', tee1, tee2);\n\n    log('intersect the keys');\n    const inter = new Set([...tee1.props.keys(), ...tee2.props.keys()]);\n    log('- Intersection ->', [...inter].join(', '));\n    group('Merge those keys');\n    inter.forEach(key => {\n      log('- `' + key + '`', tstr(tee1.props.get(key)), tstr(tee2.props.get(key)));\n      const tid = merge(locFrom, store, tee1.props.get(key), tee2.props.get(key));\n      tee1.setProp(key, tid);\n      tee2.setProp(key, tid);\n    });\n    groupEnd();\n\n    log('Returning the first arg as is:', tstr(callArgs[0]));\n    return callArgs[0] || 'undefined';\n  });\n  createFunction(store, 'Object.create', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n      const objTid = playActionObj(locFrom, store, undefined, stack, [], []);\n      log('This is a runtime error but returning a fresh object regardless', tstr(objTid));\n      return objTid;\n    }\n\n    if (argCount === 1 && callArgs[0] !== 'null' && isPrimitive(callArgs[0])) {\n      store.linter.check('BUILTIN_ARG1_OBJ', locFrom, callerTee.tid);\n      const objTid = playActionObj(locFrom, store, undefined, stack, [], []);\n      log('This is a runtime error but returning a fresh object regardless', tstr(objTid));\n      return objTid;\n    }\n\n    if (argCount > 1) {\n      if (callArgs[1] === 'undefined') {\n        // ok. ignore\n      } else if (callArgs[1] === 'null') {\n        store.linter.check('BUILTIN_ARG1_OBJ', locFrom, callerTee.tid);\n        log('This is a runtime error, which we will ignore.');\n      } else if (isPrimitive(callArgs[1])) {\n        store.linter.check('BUILTIN_ARG1_OBJ', locFrom, callerTee.tid);\n        log('Primitives other than `null` will work but are effectively a noop.');\n      } else {\n        store.linter.check('TOFIX', locFrom, callerTee.tid);\n        log('Not supporting the second arg to object.create right now.');\n      }\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    // Create a new object with given first arg as prototype (or none, if that's a null)\n    // Ignore the second param as the model doesn't support that granularity yet. Too bad.\n\n    log('Returning new object with __proto__ set to', tstr(callArgs[0]));\n    return playActionObj(locFrom, store, undefined, stack, ['__proto__'], [callArgs[0]]);\n  });\n  createFunction(store, 'Object.defineProperties', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning first arg as-is', tstr(callArgs[0] || 'undefined'));\n    return callArgs[0] || 'undefined';\n  });\n  createFunction(store, 'Object.defineProperties', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning first arg as-is', tstr(callArgs[0] || 'undefined'));\n    return callArgs[0] || 'undefined';\n  });\n  createFunction(store, 'Object.entries', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'O') {\n      // TODO: what about map/set/etc? Do they call their .entries() instead? Or also own properties.\n      return 'undefined';\n    }\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n      log('Returning an array of', tstr('string'), 'because we know the keys will be strings and since arrays are monomorphic, the values must also be strings');\n      return playActionArr(locFrom, store, undefined, stack, 'string');\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    // Do not merge the property values. That's more likely to cause trouble than good. Instead try to merge with string and issue a lint warning otherwise.\n    const argTee = store.get(callArgs[0]);\n    if (argTee.props) {\n      let failed = false;\n      // Note: argTee is a Map so .some does not work :(\n      argTee.props.forEach((tid, key) => {\n        if (!testMerge(store, tid, 'string')) failed = true;\n      });\n      if (failed) {\n        store.linter.check('POLY_OTHER', locFrom, callerTee.tid);\n        log('At least one property value was not a', tstr('string'), 'but returning an array of strings anyways so the model is now broken.');\n      }\n    }\n\n    log('Returning an array of', tstr('string'), 'because it will be a tuple of <key, value> where key must be a string and arrays can only have one type');\n    return playActionArr(locFrom, store, undefined, stack, 'string');\n  });\n  createFunction(store, 'Object.freeze', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n      log('Returning', tstr('undefined'));\n      return 'undefined';\n    }\n\n    if (isPrimitive(callArgs[0])) {\n      store.linter.check('BUILTIN_ARG1_OBJ', locFrom, callerTee.tid);\n    }\n\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning the first arg as is:', tstr(callArgs[0]));\n    return callArgs[0] || 'undefined';\n  });\n  createFunction(store, 'Object.fromEntries', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    log('Returning a fresh empty object');\n    return playActionObj(locFrom, store, undefined, stack, [], []);\n  });\n  createFunction(store, 'Object.getOwnPropertyDescriptor', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Object.getOwnPropertyDescriptors', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Object.getOwnPropertyNames', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Object.getOwnPropertySymbols', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Object.getPrototypeOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && (callArgs[0] === 'undefined' || callArgs[0] === 'null')) {\n      store.linter.check('OBJECT_GETPROTOTYPEOF_NULL', locFrom, callerTee.tid);\n      log('Returning', tstr('undefined'), 'for it');\n      return 'undefined';\n    }\n\n    const argTee = store.get(callArgs[0]);\n    ASSERT(argTee.props, 'props on non-nullables should exist?');\n    if (argTee.type === 'H') store.linter.check('TOFIX', locFrom, 'todo_prototypeof_placeholder_yikes');\n\n    const proto = argTee.props.get('__proto__') || 'undefined';\n    log('Returning', tstr(proto));\n    return proto;\n  });\n  createFunction(store, 'Object.is', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    log('This should compare two values and they should have the same type so merging them now...');\n    merge(locFrom, store, callArgs[0] || 'undefined', callArgs[1] || 'undefined');\n\n    log('Returning', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Object.isExtensible', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Object.isFrozen', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Object.isSealed', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Object.keys', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('OBJECT_KEYS', locFrom, callerTee.tid);\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    log('Returning an array of', tstr('string'));\n    return playActionArr(locFrom, store, undefined, stack, 'string');\n  });\n  createFunction(store, 'Object.preventExtensions', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr(callArgs[0] || 'undefined'));\n    return callArgs[0] || 'undefined';\n  });\n  createFunction(store, 'Object.seal', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // I'm just going to not bother with this function\n    // The model doesn't support this meta layer yet\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning', tstr(callArgs[0] || 'undefined'));\n    return callArgs[0] || 'undefined';\n  });\n  createFunction(store, 'Object.setPrototypeOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n      log('Returning', tstr('undefined'));\n      return 'undefined';\n    }\n\n    if (argCount > 0 && isPrimitive(callArgs[0])) {\n      store.linter.check('BUILTIN_ARG1_OBJ', locFrom, callerTee.tid);\n      log('Runtime does not throw so just returning first arg', tstr(callArgs[0]));\n      return callArgs[0];\n    }\n\n    if (argCount <= 1 || (callArgs[1] !== 'null' && isPrimitive(callArgs[1]))) {\n      store.linter.check('BUILTIN_ARG2_OBJ', locFrom, callerTee.tid);\n      log('Will be a runtime error but still just returning first arg', tstr(callArgs[0]));\n      return callArgs[0];\n    }\n\n    // Do the update...\n    const argTee1 = store.get(callArgs[0]);\n    const argTee2 = store.get(callArgs[1]);\n\n    ASSERT(argTee1.props, 'we checked that it wasnt a primitive', argTee1);\n    log('Now setting the __proto__ of', tstr(argTee1.tid), 'to', tstr(argTee2.tid));\n    argTee1.setProp('__proto__', argTee2.tid);\n\n    store.linter.check('SET_PROTO', locFrom, callerTee.tid);\n\n    log('Returning', tstr(argTee1.tid));\n    return argTee1.tid;\n  });\n  createFunction(store, 'Object.values', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('OBJECT_VALUES', locFrom, callerTee.tid);\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    log('Returning an array of', tstr('undefined'));\n    return playActionArr(locFrom, store, undefined, stack, 'undefined');\n  });\n  createConstructor(store, 'Object', 'Object.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n    // Ignore args, push ... input if it was not a primitive, box input if it was...?\n\n    if (argCount === 0) {\n      if (isNew) {\n        log('This `new` call to `Object` had no args, pushing the context to the stack:');\n        log('->', tstr(contextTid));\n        return contextTid;\n      }\n\n      log('Call to `Object` had no args, create a new object and return it');\n      const objTid = playActionObj(locFrom, store, undefined, stack, [], []);\n      log('->', tstr(objTid));\n      return objTid;\n    }\n\n    const firstArgTid = callArgs[0];\n    log('First arg is', tstr(firstArgTid));\n\n    const argTee = store.get(firstArgTid);\n    log('- tee:', argTee);\n    if (isPrimitive(firstArgTid)) {\n      log('First arg was a primitive. Box it and return that.');\n      store.linter.check('TOFIX', locFrom, 'primitive boxing is not implemented');\n    }\n\n    log('First arg was not a primitive. Return as is.');\n    log('->', tstr(firstArgTid));\n    return firstArgTid;\n  }, [\n    ['assign', 'Object.assign'],\n    ['create', 'Object.create'],\n    ['defineProperties', 'Object.defineProperties'],\n    ['defineProperty', 'Object.defineProperty'],\n    ['entries', 'Object.entries'],\n    ['freeze', 'Object.freeze'],\n    ['fromEntries', 'Object.fromEntries'],\n    ['getOwnPropertyDescriptor', 'Object.getOwnPropertyDescriptor'],\n    ['getOwnPropertyDescriptors', 'Object.getOwnPropertyDescriptors'],\n    ['getOwnPropertyNames', 'Object.getOwnPropertyNames'],\n    ['getOwnPropertySymbols', 'Object.getOwnPropertySymbols'],\n    ['getPrototypeOf', 'Object.getPrototypeOf'],\n    ['is', 'Object.is'],\n    ['isExtensible', 'Object.isExtensible'],\n    ['isFrozen', 'Object.isFrozen'],\n    ['isSealed', 'Object.isSealed'],\n    ['preventExtensions', 'Object.preventExtensions'],\n    ['seal', 'Object.seal'],\n    ['setPrototypeOf', 'Object.setPrototypeOf'],\n    ['values', 'Object.values'],\n  ]);\n\n  // All the. Things. afmaken vooral\n  createFunction(store, 'RegExp#compile', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('REGEXP_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0) {\n      if (callArgs[0] !== 'string') {\n        store.linter.check('REGEXP_ARG1', locFrom, callerTee.tid);\n      }\n    }\n    if (argCount > 1) {\n      if (callArgs[1] !== 'string') {\n        store.linter.check('REGEXP_ARG2', locFrom, callerTee.tid);\n      }\n    }\n    if (argCount > 2) {\n      store.linter.check('REGEXP_ARG3', locFrom, callerTee.tid);\n    }\n\n    // Create a generic empty object that inherits from RegExp\n    // TODO: I think that this can get own properties under certain circumstances, but not from the constructor\n    const objRegexTid = playActionObj(locFrom, store, undefined, stack, ['__proto__'], ['RegExp.prototype']);\n    log('->', tstr(objRegexTid));\n    return objRegexTid;\n  });\n  createFunction(store, 'RegExp#exec', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'O' || contextTee.props.get('__proto__') !== 'RegExp.prototype') {\n      store.linter.check('BUILTIN_CONTEXT_REGEX', locFrom, callerTee.tid);\n    }\n\n    store.linter.check('REGEXP_EXEC_UNSAFE', locFrom, callerTee.tid);\n\n    log('Pushing an array of', tstr('string'));\n    return playActionArr(locFrom, store, undefined, stack, 'string');\n  });\n  createFunction(store, 'RegExp#test', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'O' || contextTee.props.get('__proto__') !== 'RegExp.prototype') {\n      store.linter.check('BUILTIN_CONTEXT_REGEX', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'RegExp#toString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'O' || contextTee.props.get('__proto__') !== 'RegExp.prototype') {\n      store.linter.check('BUILTIN_CONTEXT_REGEX', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  playActionBuiltinObj(store, 'RegExp.prototype', new Map([\n      ['__proto__', 'Object.prototype'],\n      ['compile', 'RegExp#compile'],\n      ['dotAll', 'boolean'],\n      ['exec', 'RegExp#exec'],\n      ['flags', 'string'],\n      ['global', 'boolean'],\n      ['ignoreCase', 'boolean'],\n      ['lastIndex', 'number'],\n      ['multiline', 'boolean'],\n      ['source', 'string'],\n      ['sticky', 'boolean'],\n      ['test', 'RegExp#test'],\n      ['toString', 'RegExp#toString'],\n      ['unicode', 'boolean'],\n    ]));\n  createConstructor(store, 'RegExp', 'RegExp.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    // RegExp has same behavior with and without `new`\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('REGEXP_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 0) {\n      if (callArgs[0] !== 'string') {\n        store.linter.check('REGEXP_ARG1', locFrom, callerTee.tid);\n      }\n    }\n    if (argCount > 1) {\n      if (callArgs[1] !== 'string') {\n        store.linter.check('REGEXP_ARG2', locFrom, callerTee.tid);\n      }\n    }\n    if (argCount > 2) {\n      store.linter.check('REGEXP_ARG3', locFrom, callerTee.tid);\n    }\n\n    // Create a generic empty object that inherits from RegExp\n    // TODO: I think that this can get own properties under certain circumstances, but not from the constructor\n    const objRegexTid = playActionObj(locFrom, store, undefined, stack, ['__proto__'], ['RegExp.prototype']);\n    log('->', tstr(objRegexTid));\n    return objRegexTid;\n  });\n\n  createFunction(store, 'Set#add', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n    if (argCount === 0) {\n      store.linter.check('SET_ADD_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type === 'S') {\n      const arg = argCount > 0 ? callArgs[0] : 'undefined';\n      ASSERT_TID(arg);\n      const kindTee = store.get(contextTee.kind);\n      const argTee = store.get(arg);\n      log('Merging first arg', tstr(argTee.tid), 'with kind of context', tstr(kindTee.tid));\n      // Merge this tid with the kind of the set\n      contextTee.kind = merge(locFrom, store, arg, contextTee.kind, false);\n    } else {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_SET', locFrom, callerTee.tid);\n    }\n\n    log('Pushing the context back onto the stack;', tstr(contextTid));\n    return contextTid;\n  });\n  createFunction(store, 'Set#clear', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'S') {\n      store.linter.check('BUILTIN_CONTEXT_SET', locFrom, callerTee.tid);\n    }\n\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Set#delete', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('SET_ADD_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type === 'S') {\n      const arg = argCount > 0 ? callArgs[0] : 'undefined';\n      log('Merging first arg', tstr(arg), 'with kind of context', tstr(contextTee.kind));\n      // Merge this tid with the kind of the set\n      contextTee.kind = merge(locFrom, store, arg, contextTee.kind, false);\n    } else {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_SET', locFrom, callerTee.tid);\n    }\n\n    log('Returning', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Set#entries', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'S') {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_MAP', locFrom, callerTee.tid);\n      // Just return undefined and ignore the call otherwise\n      return 'undefined';\n    }\n\n    if (argCount !== 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'Set#forEach', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('MAPSET_FOREACH_ARGLESS', locFrom, callerTee.tid);\n      log('Call had no args so there is no callback to call');\n      return 'undefined';\n    }\n\n    if (argCount > 2) {\n      store.linter.check('MAPSET_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    const funcTid = callArgs[0];\n    const contextTidToUse = argCount >= 2 ? callArgs[1] : contextTid;\n    log('callback:', tstr(funcTid), ', context:', tstr(contextTidToUse));\n\n    const funcTee = store.get(funcTid);\n    const contextTeeToUse = store.get(contextTidToUse);\n    ASSERT(funcTee && contextTeeToUse);\n\n    if (funcTee.type !== 'F') {\n      store.linter.check('MAPSET_FOREACH_FUNC_ARG', locFrom, callerTee.tid);\n      log('Cannot invoke this so ignoring the call');\n      return 'undefined';\n    }\n\n    let kind = 'undefined';\n    if (contextTeeToUse.type === 'S') {\n      const kindTee = store.get(contextTeeToUse.kind);\n      if (kindTee.type === 'H') {\n        // TODO: if we think we know a map is empty, should we bother pseudo-invoking its first argument? real JS wouldnt. then there would be no need to seal the set kind\n        store.linter.check('SET_FOREACH_SET_KIND', locFrom, callerTee.tid);\n        log('Now forcing the empty set kind to', tstr('undefined'),'because it is \"read\"');\n        store.linkTo(kindTee, store.get('undefined'));\n        contextTeeToUse.kind = 'undefined';\n      } else {\n        kind = kindTee.tid;\n      }\n    } else {\n      store.linter.check('SET_FOREACH_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    group('Now calling the callback with a', tstr(kind), 'and', tstr(kind), 'and the set being iterated:', tstr(contextTidToUse));\n    const returnTid = metaCall(locFrom, funcTee.tid, contextTeeToUse.tid, isNew, stack, 3, [kind, kind, contextTeeToUse.tid], -1, store, '', store.instanceId, true);\n    log('The Set#forEach lambda call resulted in', tstr(returnTid));\n    groupEnd();\n\n    // Ignore return value. And even though from a purist perspective it _ought_ to be undefined, we don't care.\n    return 'undefined';\n  });\n  createFunction(store, 'Set#has', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('SET_ADD_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type === 'S') {\n      const arg = argCount > 0 ? callArgs[0] : 'undefined';\n      log('Merging first arg', tstr(arg), 'with kind of context', tstr(contextTee.kind));\n      ASSERT_TID(arg);\n      ASSERT_TID(contextTee.kind);\n      // Merge this tid with the kind of the set\n      contextTee.kind = merge(locFrom, store, arg, contextTee.kind, false);\n    } else {\n      // I _think_ this can be made to work? But too much of an edge case to bother. PR's are welcome. Bring tests.\n      store.linter.check('BUILTIN_CONTEXT_SET', locFrom, callerTee.tid);\n    }\n\n    log('Returning', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'Set#values', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    const contextTee = store.get(contextTid);\n    if (contextTee.type !== 'S') {\n      store.linter.check('BUILTIN_CONTEXT_SET', locFrom, callerTee.tid);\n    }\n\n    store.linter.check('NO_ITERATORS', locFrom, callerTee.tid);\n\n    log('Returning', tstr('undefined'));\n    return 'undefined';\n  });\n  playActionBuiltinObj(store, 'Set.prototype', new Map([\n      ['__proto__', 'Object.prototype'],\n      ['add', 'Set#add'],\n      ['clear', 'Set#clear'],\n      ['delete', 'Set#delete'],\n      ['entries', 'Set#entries'],\n      ['forEach', 'Set#forEach'],\n      ['has', 'Set#has'],\n      ['size', 'number'],\n      ['values', 'Set#values'],\n    ]));\n  createConstructor(store, 'Set', 'Set.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // A Set expects zero args or one arg that is an iterable (array, for now) of elements\n\n    if (!isNew) {\n      // Runtime error\n      store.linter.check('SET_WITHOUT_NEW', locFrom, callerTee.tid);\n    }\n\n    log('There are', argCount, 'args');\n    let kind;\n    if (argCount > 0) {\n      const tid = callArgs[0];\n      log('First arg is', tstr(tid));\n      const tee = store.get(tid);\n      if (tee.type === 'A') {\n        log('- And its kind is:', tstr(tee.kind), '->', tstr(store.get(tee.kind)));\n        ASSERT(typeof tee.kind === 'string', 'kinds are strings', tee.kind);\n        const kindTee = store.get(tee.kind);\n\n        if (kindTee.type === 'H') {\n          store.linter.check('SET_EMPTY_ARRAY', locFrom, callerTee.tid);\n        }\n\n        kind = kindTee.tid;\n      } else {\n        store.linter.check('SET_ARG1', locFrom, callerTee.tid);\n      }\n      log('Preliminary kind after processing arg:', tstr(kind));\n    }\n\n    if (typeof kind !== 'string') {\n      kind = createPlaceholder(store, 'HSK', 'new Set()');\n    }\n\n    if (argCount > 1) {\n      store.linter.check('SET_ARG2', locFrom, callerTee.tid);\n    }\n\n    return playActionSet(locFrom, store, undefined, stack, kind);\n  });\n\n  createFunction(store, 'String#charCodeAt', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'String#codePointAt', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // Unlike charCodeAt, the codePointAt function may result in `undefined`, not `NaN`, for non-existing indexes. Meh\n    store.linter.check('STRING_CODEPOINTAT_UNSOUND', locFrom, callerTee.tid);\n\n    if (argCount === 0) {\n      store.linter.check('STRING_REPEAT_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'String#concat', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    // I guess they should all be strings...\n    mergeAll(locFrom, ['string', ...callArgs], store);\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#endsWith', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'String#indexOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'String#includes', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'String#lastIndexOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'String#localeCompare', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // :shrug:\n    store.linter.check('TOFIX', locFrom, callerTee.tid);\n\n    log('Returning a', tstr('boolean'));\n    return 'boolean';\n  });\n  createFunction(store, 'String#match', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0) {\n      const tid = callArgs[0];\n      const tee = store.get(tid);\n      if (tee.type !== 'O' || tee.props.get('__proto__') !== 'RegExp.prototype') {\n        log('First arg was:', tee);\n        store.linter.check('BUILTIN_ARG1_REGEX', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    // TODO: this function returns string or null and we can't determine this ahead of time because it depends on the regex and string being tested...\n    store.linter.check('STRING_MATCH_UNSAFE', locFrom, callerTee.tid);\n    log('Returning an array of', tstr('string'));\n    return playActionArr(locFrom, store, undefined, stack, 'string');\n  });\n  createFunction(store, 'String#matchAll', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0) {\n      const tid = callArgs[0];\n      const tee = store.get(tid);\n      if (tee.type !== 'O' || tee.props.get('__proto__') !== 'RegExp.prototype') {\n        log('First arg was:', tee);\n        store.linter.check('BUILTIN_ARG1_REGEX', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    // TODO: this function returns string or null and we can't determine this ahead of time because it depends on the regex and string being tested...\n    store.linter.check('STRING_MATCH_UNSAFE', locFrom, callerTee.tid);\n    log('Returning an array of', tstr('string'));\n    return playActionArr(locFrom, store, undefined, stack, 'string');\n  });\n  createFunction(store, 'String#normalize', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return '/home/ptr/proj/zetype/src/builtins.mjs';\n  });\n  createFunction(store, 'String#padStart', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'string') {\n      store.linter.check('BUILTIN_ARG2_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#padEnd', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'string') {\n      store.linter.check('BUILTIN_ARG2_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#padLeft', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'string') {\n      store.linter.check('BUILTIN_ARG2_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#padRight', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'string') {\n      store.linter.check('BUILTIN_ARG2_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#repeat', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('STRING_REPEAT_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#replace', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n      log('Just returning a', tstr('string'), 'now');\n      return 'string';\n    }\n\n    // First arg can be a string or regex\n    // Second arg can be string or callback\n    // The callback is unsafe since the arg count and its params depend on the regex matching which the model can't know\n\n    const argTee = store.get(callArgs[0]);\n    if (argTee.tid !== 'string' && (argTee.type !== 'O' || argTee.props.get('__proto__') !== 'RegExp.prototype')) {\n      store.linter.check('STRING_REPLACE_ARG1', locFrom, callerTee.tid);\n    }\n\n    if (argCount < 2) {\n      store.linter.check('BUILTIN_ARG2_MISSING', locFrom, callerTee.tid);\n      log('Returning a', tstr('string'));\n      return 'string';\n    }\n\n    if (callArgs[1] === 'string') {\n      log('Second arg is a string. Returning a', tstr('string'));\n      return 'string';\n    }\n\n    const argTee2 = store.get(callArgs[2]);\n    if (argTee2.type !== 'F') {\n      store.linter.check('STRING_REPLACE_ARG2', locFrom, callerTee.tid);\n      log('Second arg is crap. Returning a', tstr('string'));\n      return 'string';\n    }\n\n    // Invoke the callback with ... zero args? A string spread on zero?\n\n    store.linter.check('STRING_REPLACE_FUNC', locFrom, callerTee.tid);\n\n    log('Now calling callback as if there was a spread of array of strings from the first position. Might not be correct.');\n    const returnTid = metaCall(locFrom, argTee2.tid, 'undefined', false, stack, 1, ['string'], 0, store, '', store.instanceId, true);\n    if (returnTid !== 'string') {\n      store.linter.check('STRING_REPLACE_RETURN', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#replaceAll', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n      log('Just returning a', tstr('string'), 'now');\n      return 'string';\n    }\n\n    // First arg can be a string or regex\n    // Second arg can be string or callback\n    // The callback is unsafe since the arg count and its params depend on the regex matching which the model can't know\n\n    const argTee = store.get(callArgs[0]);\n    if (argTee.tid !== 'string' && (argTee.type !== 'O' || argTee.props.get('__proto__') !== 'RegExp.prototype')) {\n      store.linter.check('STRING_REPLACE_ARG1', locFrom, callerTee.tid);\n    }\n\n    if (argCount < 2) {\n      store.linter.check('BUILTIN_ARG2_MISSING', locFrom, callerTee.tid);\n      log('Returning a', tstr('string'));\n      return 'string';\n    }\n\n    if (callArgs[1] === 'string') {\n      log('Second arg is a string. Returning a', tstr('string'));\n      return 'string';\n    }\n\n    const argTee2 = store.get(callArgs[2]);\n    if (argTee2.type !== 'F') {\n      store.linter.check('STRING_REPLACE_ARG2', locFrom, callerTee.tid);\n      log('Second arg is crap. Returning a', tstr('string'));\n      return 'string';\n    }\n\n    // Invoke the callback with ... zero args? A string spread on zero?\n\n    store.linter.check('STRING_REPLACE_FUNC', locFrom, callerTee.tid);\n\n    log('Now calling callback as if there was a spread of array of strings from the first position. Might not be correct.');\n    const returnTid = metaCall(locFrom, argTee2.tid, 'undefined', false, stack, 1, ['string'], 0, store, '', store.instanceId, true);\n    if (returnTid !== 'string') {\n      store.linter.check('STRING_REPLACE_RETURN', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#search', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('STRING_SPLIT_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0) {\n      // split accepts a string or a regex\n      const tid = callArgs[0];\n      const tee = store.get(tid);\n      if ((tee.type !== 'O' || tee.props.get('__proto__') !== 'RegExp.prototype')) {\n        store.linter.check('BUILTIN_ARG1_REGEX', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return playActionArr(locFrom, store, undefined, stack, 'number');\n  });\n  createFunction(store, 'String#split', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('STRING_SPLIT_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0) {\n      // split accepts a string or a regex\n      const tid = callArgs[0];\n      const tee = store.get(tid);\n      if (tid !== 'string' && (tee.type !== 'O' || tee.props.get('__proto__') !== 'RegExp.prototype')) {\n        store.linter.check('STRING_SPLIT_ARG1', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning an array of', tstr('string'));\n    return playActionArr(locFrom, store, undefined, stack, 'string');\n  });\n  createFunction(store, 'String#slice', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#startsWith', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('BUILTIN_ARG1_STRING', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#substr', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#substring', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'number') {\n      store.linter.check('BUILTIN_ARG1_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('BUILTIN_ARG2_NUMBER', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('BUILTIN_ARG3_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#toLocaleLowerCase', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0) {\n      const argTee = store.get(callArgs[0]);\n      if (argTee.tid !== 'string' && (argTee.type !== 'A' || argTee.kind !== 'string')) {\n        store.linter.check('STRING_TLS_ARG1', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#toLocaleUpperCase', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('BUILTIN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0) {\n      const argTee = store.get(callArgs[0]);\n      if (argTee.tid !== 'string' && (argTee.type !== 'A' || argTee.kind !== 'string')) {\n        store.linter.check('STRING_TLS_ARG1', locFrom, callerTee.tid);\n      }\n    }\n\n    if (argCount > 1) {\n      store.linter.check('BUILTIN_ARG2_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#toLowerCase', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#toString', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n    if (argCount > 0) {\n      store.linter.check('STRING_TOSTRING_ARGS', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('STRING_TOSTRING_CONTEXT', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#toUpperCase', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#trim', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#trimLeft', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#trimStart', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#trimRight', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#trimEnd', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String#valueOf', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) {\n      // Runtime error **shrug**\n      store.linter.check('BUILTIN_FUNC_NOT_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount > 0) {\n      store.linter.check('BUILTIN_ARG1_TMI', locFrom, callerTee.tid);\n    }\n\n    if (contextTid !== 'string') {\n      store.linter.check('BUILTIN_CONTEXT_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  playActionBuiltinObj(store, 'String.prototype', new Map([\n      ['__proto__', 'Object.prototype'],\n      ['charCodeAt', 'String#charCodeAt'],\n      ['codePointAt', 'String#codePointAt'],\n      ['concat', 'String#concat'],\n      ['endsWith', 'String#endsWith'],\n      ['includes', 'String#includes'],\n      ['indexOf', 'String#indexOf'],\n      ['lastIndexOf', 'String#lastIndexOf'],\n      ['length', 'number'],\n      ['localeCompare', 'String#localeCompare'],\n      ['match', 'String#match'],\n      ['matchAll', 'String#matchAll'],\n      ['normalize', 'String#normalize'],\n      ['padEnd', 'String#padEnd'],\n      ['padStart', 'String#padStart'],\n      ['repeat', 'String#repeat'],\n      ['replace', 'String#replace'],\n      ['replaceAll', 'String#replaceAll'],\n      ['search', 'String#search'],\n      ['slice', 'String#slice'],\n      ['split', 'String#split'],\n      ['startsWith', 'String#startsWith'],\n      ['substring', 'String#substring'],\n      ['substr', 'String#substr'],\n      ['toLocaletoLowerCase', 'String#toLocaletoLowerCase'],\n      ['toLocaleUpperCase', 'String#toLocaleUpperCase'],\n      ['toLowerCase', 'String#toLowerCase'],\n      ['toString', 'String#toString'],\n      ['toUpperCase', 'String#toUpperCase'],\n      ['trim', 'String#trim'],\n      ['trimLeft', 'String#trimLeft'],\n      ['trimRight', 'String#trimRight'],\n      ['trimStart', 'String#trimStart'],\n      ['trimEnd', 'String#trimEnd'],\n      ['valueOf', 'String#valueOf'],\n    ]));\n  createFunction(store, 'String.fromCharCode', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('STRING_FCC_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    callArgs.forEach(tid => {\n      if (tid !== 'number') {\n        store.linter.check('STRING_FCC_ARGS', locFrom, callerTee.tid); // TODO: the loc should for the particular arg as it will just point to the call right now\n      }\n    });\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createFunction(store, 'String.fromCodePoint', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    if (argCount === 0) {\n      store.linter.check('STRING_FCP_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    callArgs.forEach(tid => {\n      if (tid !== 'number') {\n        store.linter.check('STRING_FCP_ARGS', locFrom, callerTee.tid); // TODO: the loc should for the particular arg as it will just point to the call right now\n      }\n    });\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  });\n  createConstructor(store, 'String', 'String.prototype', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    log('Returning a', tstr('string'));\n    return 'string';\n  }, [['fromCharCode', 'String.fromCharCode'], ['fromCodePoint', 'String.fromCodePoint']]);\n\n  createFunction(store, 'console.log', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    // if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented'); // I don't think this matters for .log?\n\n    // Ignore args, push an undefined\n    if (argCount === 0) {\n      store.linter.check('CONSOLE_LOG_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'console.warn', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    // if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented'); // I don't think this matters for .warn?\n\n    if (argCount === 0) {\n      store.linter.check('CONSOLE_WARN_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'console.error', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    // if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented'); // I don't think this matters for .error?\n\n    if (argCount === 0) {\n      store.linter.check('CONSOLE_ERROR_ARGLESS', locFrom, callerTee.tid);\n    }\n    // Ignore args, push an undefined\n    if (argCount > 1) {\n      store.linter.check('CONSOLE_ERROR_ARGS', locFrom, callerTee.tid);\n    }\n    if (argCount >= 1 && callArgs[0] !== 'string') {\n      store.linter.check('CONSOLE_ERROR_ARG_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'console.group', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    // if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented'); // I don't think this matters for .group?\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'console.groupEnd', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    // if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented'); // I don't think this matters for .groupEnd?\n\n    if (argCount > 0) {\n      store.linter.check('CONSOLE_GROUPEND_ARGS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'console.dir', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n\n    // Ignore args, push an undefined\n    if (argCount === 0) {\n      store.linter.check('CONSOLE_DIR_ARGLESS', locFrom, callerTee.tid);\n    }\n    if (argCount > 2) {\n      store.linter.check('CONSOLE_DIR_ARGS', locFrom, callerTee.tid);\n    }\n    if (argCount >= 2 && isPrimitive(callArgs[0])) {\n      store.linter.check('CONSOLE_DIR_ARGS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'console.trace', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // Ignore args, push an undefined\n    if (argCount > 1) {\n      store.linter.check('CONSOLE_TRACE_ARGS', locFrom, callerTee.tid);\n    }\n    if (argCount >= 1 && callArgs[0] !== 'string') {\n      store.linter.check('CONSOLE_TRACE_ARG_STRING', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'console.debug', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // Ignore args, push an undefined\n    if (argCount === 0) {\n      store.linter.check('CONSOLE_DEBUG_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'global.clearInterval', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // First arg should be a number. Over and underflows are ignored.\n    // TODO: I wonder if we could use some kind of opaque type to track a setTimeout result vs setInterval result vs other kind of number...\n\n    if (argCount < 1 || callArgs[0] !== 'number') {\n      store.linter.check('CLEARINTERVAL_NUM_ARG', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('CLEARINTERVAL_EXCESS_ARGS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  createFunction(store, 'global.clearTimeout', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // First arg should be a number. Over and underflows are ignored.\n    // TODO: I wonder if we could use some kind of opaque type to track a setTimeout result vs setInterval result vs other kind of number...\n\n    if (argCount < 1 || callArgs[0] !== 'number') {\n      store.linter.check('CLEARTIMEOUT_NUM_ARG', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1) {\n      store.linter.check('CLEARTIMEOUT_EXCESS_ARGS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('undefined'));\n    return 'undefined';\n  });\n  playActionBuiltinObj(store, 'global.console', new Map([\n      ['group', 'console.group'],\n      ['groupEnd', 'console.groupEnd'],\n      ['log', 'console.log'],\n      ['warn', 'console.warn'],\n      ['error', 'console.error'],\n      ['dir', 'console.dir'],\n      ['trace', 'console.trace'],\n      ['debug', 'console.debug'],\n    ]));\n  createFunction(store, 'global.setInterval', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // First arg should be a function of sorts. Second arg should be a number. Under or overflow is ignored.\n\n    if (argCount >= 1) {\n      const tee = store.get(callArgs[0]);\n      if (tee.tid === 'string') {\n        store.linter.check('SETINTERVAL_STRING_ARG', locFrom, callerTee.tid);\n      } else if (tee.type !== 'F') {\n        store.linter.check('SETINTERVAL_ARG_TYPE', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('SETINTERVAL_STRING_ARG', locFrom, callerTee.tid);\n    }\n\n    if (argCount < 2 || callArgs[1] !== 'number') {\n      store.linter.check('SETINTERVAL_NUM_ARG', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('SETINTERVAL_EXCESS_ARGS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'global.setTimeout', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // First arg should be a function of sorts. Second arg should be a number. Under or overflow is ignored.\n\n    if (argCount >= 1) {\n      const tee = store.get(callArgs[0]);\n      if (tee.tid === 'string') {\n        store.linter.check('SETTIMEOUT_STRING_ARG', locFrom, callerTee.tid);\n      } else if (tee.type !== 'F') {\n        store.linter.check('SETTIMEOUT_ARG_TYPE', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('SETTIMEOUT_STRING_ARG', locFrom, callerTee.tid);\n    }\n\n    if (argCount < 2 || callArgs[1] !== 'number') {\n      store.linter.check('SETTIMEOUT_NUM_ARG', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('SETTIMEOUT_EXCESS_ARGS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'global.parseFloat', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // First arg should be a string or number of sorts. Second arg is optionally a number. Under or overflow is ignored.\n\n    if (argCount >= 1) {\n      const tid = callArgs[0];\n      if (tid !== 'string') {\n        store.linter.check('PARSEFLOAT_ARG1', locFrom, callerTee.tid);\n      }\n\n      if (argCount >= 2) {\n        store.linter.check('PARSEFLOAT_ARG2', locFrom, callerTee.tid);\n      }\n    } else {\n      store.linter.check('PARSEFLOAT_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, 'global.parseInt', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (isNew) store.linter.check('TOFIX', locFrom, 'new on a non-constructor builtin is not implemented but probably an error');\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n\n    // First arg should be a string or number of sorts. Second arg is optionally a number. Under or overflow is ignored.\n\n    if (argCount === 0) {\n      store.linter.check('PARSEINT_ARGLESS', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 0 && callArgs[0] !== 'string') {\n      store.linter.check('PARSEINT_ARG1', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 1 && callArgs[1] !== 'number') {\n      store.linter.check('PARSEINT_ARG2', locFrom, callerTee.tid);\n    }\n\n    if (argCount > 2) {\n      store.linter.check('PARSEINT_ARG3', locFrom, callerTee.tid);\n    }\n\n    log('Returning a', tstr('number'));\n    return 'number';\n  });\n  createFunction(store, '#constructor_sans_super', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n    if (!isNew) {\n      store.linter.check('CANNOT_CALL_BUILTIN_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n\n    if (argCount) {\n      store.linter.check('CALL_ARG_ARITY', locFrom, callerTee.tid);\n    }\n\n    log('This is a noop constructor. Returning the context:', tstr(contextTid));\n    return contextTid;\n  });\n  createFunction(store, '#constructor_with_super', (locFrom, callerTee, contextTid, argCount, callArgs, spreadAt, stack, store, closure, isNew, ownerClass) => {\n    if (spreadAt >= 0) store.linter.check('TOFIX', locFrom, 'spread on builtin not implemented');\n    if (!isNew) {\n      store.linter.check('CANNOT_CALL_BUILTIN_CONSTRUCTOR', locFrom, callerTee.tid);\n    }\n\n    // This is implicit es6 class constructor `constructor(...args) { super(...args); }`\n    // Note: I think there's currently a typo in the spec since v8 and spidermonkey _return_ the super call value. So let's go with that.\n    log('Calling super(...args) on superClass', tstr(ownerClass), 'with', argCount, 'args and returning the current context:', tstr(contextTid));\n\n    // This `super()` is determined by the own `__proto__` value of this class\n    // `class X {constructor(){ log('A'); }; f(){}} class Y extends X { } new Y(); Y.__proto__ = Object; new Y();`\n    // `class X {constructor(){ log('A'); }; f(){}} class Y extends X { constructor(){ super() } } new Y(); Y.__proto__ = Object; new Y();`\n    // Both print A for the first `new` and nothing for the second one.\n\n    if (ownerClass === 'Function.prototype') log('The owner class is ' + tstr('Function.prototype') + ' so the parent constructor is ' + tstr('Object'));\n\n    const ownerClassTee = store.get(ownerClass === 'Function.prototype' ? 'Object' : ownerClass);\n    // log('ownerClassTee:', ownerClassTee)\n    const actualProtoTid = ownerClassTee.props.get('__proto__');\n    const targetProtoTid = actualProtoTid === 'Function.prototype' || actualProtoTid === undefined ? 'Object' : actualProtoTid;\n    log('The class.__proto__ (super class) is', tstr(actualProtoTid), actualProtoTid !== targetProtoTid ? '(this means the parent class is ' + tstr(targetProtoTid) + ')' : '');\n    const protoTee = store.get(targetProtoTid === 'Function.prototype' ? 'Object' : targetProtoTid);\n    // log('The proto tee:', protoTee)\n\n    let constructTid = targetProtoTid;\n    if (protoTee.type !== 'C' && protoTee.type !== 'F') {\n      log('The super class is an illegal value (a lint should have been issued for this already):', tstr(protoTee.tid));\n      return 'undefined';\n    }\n\n    if (protoTee.funcType === 'class') {\n      log('The super class is an es6 class. Getting the constructor');\n      const prototypeTid = protoTee.props.get('prototype');\n      ASSERT(prototypeTid !== null, 'i dont think i allow this to happen anymore');\n      if (prototypeTid === undefined || prototypeTid === 'null') {\n        store.linter.check('CONSTRUCTOR_NULL_PARENT', locFrom, callerTee.tid);\n      }\n      log('- .prototype:', tstr(prototypeTid));\n      ASSERT(prototypeTid, 'the prototype of a constructor can not be cleared', prototypeTid, protoTee);\n      const prototypeTee = store.get(prototypeTid);\n      const constructorTid = prototypeTee.props.get('constructor');\n      ASSERT(constructorTid, 'the constructor on an es6 class must always exist, explicitly or implicitly', constructorTid);\n      log('- .prototype.constructor:', tstr(constructTid));\n\n      constructTid = constructorTid;\n    } else if (protoTee.funcType.startsWith('class')) {\n      // A bound class cannot be extends because it has no proto\n      log('The superClass value is actually a bound class and this has no prototype which is a runtime error');\n      return 'undefined';\n    } else {\n      log('The super class is an es5 class, so just call it');\n    }\n\n    // invoke constructTid as a new call but forcing context as the context... Return whatever it returns.\n    group('invoking now');\n    const returnTid = metaCall(locFrom, constructTid, contextTid, true, stack, argCount, callArgs, -1, store, targetProtoTid, store.instanceId, false);\n    groupEnd();\n\n    // Counter to spec but conform to real world; return the return value\n    return returnTid;\n  });\n}\nfunction createFunction(store, tid, callback) {\n  const props = new Map([['__proto__', 'Function.prototype']]);\n  store.set(tid, {\n    tid,\n    type: 'F',\n    superPropOwner: NO_SUPER_PROP_FOR_BUILTINS,\n    digest(color) { return color ? tstr(tid) : tid; },\n    fromFilename: '<builtin>',\n    fromColumn: 0,\n    fromLine: 0,\n    funcType: 'func-builtin',\n    builtin: true,\n    builtinCode: callback,\n    reachableNames: new Map,\n    props,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map,\n  });\n}\nfunction createConstructor(store, tid, prototype, callback, staticProps = []) {\n\n  const props = new Map([\n    ['__proto__', 'Function.prototype'],\n    ['prototype', prototype],\n  ]);\n  staticProps.forEach(([name, tid]) => props.set(name, tid));\n\n  store.set(tid, {\n    tid,\n    type: 'F',\n    superPropOwner: NO_SUPER_PROP_FOR_BUILTINS,\n    digest(color) { return color ? tstr(tid) : tid; },\n    fromFilename: '<builtin>',\n    fromColumn: 0,\n    fromLine: 0,\n    funcType: 'func-builtin',\n    builtin: true,\n    builtinCode: callback,\n    reachableNames: new Map,\n    props,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map,\n  });\n}\n","~/proj/zetype/src/tools.mjs":"import {\n  ASSERT,\n  ASSERT_LOC,\n  ASSERT_TID,\n  ASSERT_SUPER_PROP_OWNER,\n  BOLD,\n  DIM,\n  getIndent,\n  group,\n  groupEnd,\n  log,\n  RESET,\n  tstr,\n  WHITE_BLACK,\n  YELLOW, NO_SUPER_VALUE, createPlaceholder\n} from \"./utils.mjs\"\n\nexport function merge(locFrom, store, a, b, testing = false, recur = new Set) {\n  // returns resulting tid after merge, does not read/write the stack\n  ASSERT(arguments.length === 4 || arguments.length === 5 || arguments.length === 6, 'arg count to merge');\n  locFrom === null || ASSERT_LOC(locFrom); // testMerge will set this to null\n\n  log((testing ? 'Test-' : '') + 'Merging', tstr(a), 'with', tstr(b));\n  ASSERT_TID(a);\n  ASSERT_TID(b);\n\n  const A = store.get(a);\n  const B = store.get(b);\n\n  // store.get will have resolved aliases\n  a = A.tid;\n  b = B.tid;\n\n  if (a === b) {\n    log('Same tid, nothing to do');\n    return a;\n  }\n\n  const pair = a + ':' + b;\n  if (recur.has(pair)) {\n    log('A and B are already being merged. There is recursion in their model. Ignoring this and returning A');\n    return a;\n  }\n  recur.add(pair);\n\n  const tidA = A.tid;\n  const tidB = B.tid;\n\n  if (tidA === tidB) {\n    log('Same tid, nothing to do');\n    return a;\n  }\n\n  if (A.type === 'H') {\n    log('Merging a placeholder A', tstr(A.tid), 'to', tstr(tidB));\n    if (B.type === 'H') {\n      log('Merging two placeholders...');\n    }\n\n    if (A.props.size) {\n      if (!testing && isPrimitive(b)) {\n        store.linter.check('POLY_PRIMITIVE_TO_PLACEHOLDER_WITH_PROPS', locFrom, tidA, tidB);\n      }\n      mergeProps(locFrom, store, tidB, B, tidA, A, testing, recur);\n    }\n\n    if (!testing) {\n      store.linkTo(A, B);\n    }\n\n    return tidB;\n  }\n\n  if (B.type === 'H') {\n    log('Merging a placeholder B', tstr(B.tid), 'to', tstr(tidA));\n    if (!testing) {\n      store.linkTo(B, A);\n    }\n    return tidA;\n  }\n\n  if (isPrimitive(tidA) || isPrimitive(tidB)) {\n    if (testing) throw 1;\n    store.linter.check('POLY_PRIMITIVES', locFrom, tidA, tidB);\n    if (tidA === 'undefined') {\n      log('- Since A is `undefined`, B is more likely to be relevant (under assumption that the model is no longer sound, anyways)');\n      return tidB;\n    }\n    return tidA;\n  }\n\n  if (A === B) {\n    log('Since A and B are equal while they are different tids, cosnidering them merged to:', tstr(A.tid))\n    // Note: A.tid may not be tidA nor tidB\n    return A.tid;\n  }\n\n  if (A.builtin && B.builtin) {\n    if (testing) throw 2;\n    store.linter.check('POLY_BUILTINS', locFrom);\n    return tidA;\n  }\n\n  if (A.builtin) {\n    // We can merge plain objects with builtin objects...\n    if (A.type === 'O' && B.type === 'O') {\n      return mergeObjects(locFrom, store, tidA, A, tidB, B, testing, recur);\n    }\n\n    // Technically we could try to merge a builtin array with user array but I'm not sure there are valid use cases here\n    // These aren't primitives\n    // Merging functions / classes / constructors is tbd\n\n    if (testing) throw 3;\n    store.linter.check('POLY_BUILTIN_ARRAY', locFrom);\n    return tidA;\n  }\n\n  if (B.builtin) {\n    // We can merge plain objects with builtin objects...\n    if (B.type === 'O' && tidA[0] === 'O') {\n      return mergeObjects(locFrom, store, tidB, B, tidA, A, testing, recur);\n    }\n\n    // Technically we could try to merge a builtin array with user array but I'm not sure there are valid use cases here\n    // These aren't primitives\n    // Merging functions / classes / constructors is tbd\n\n    if (testing) throw 32;\n    store.linter.check('POLY_BUILTIN_ARRAY', locFrom);\n    return tidA;\n  }\n\n  if (A.type === 'A' && B.type === 'A') { // arrays\n    return mergeIterables(locFrom, store, tidA, A, tidB, B, testing, recur);\n  }\n\n  if (A.type === 'O' && B.type === 'O') { // objects\n    return mergeObjects(locFrom, store, tidA, A, tidB, B, testing, recur);\n  }\n\n  if (A.type === 'F' || B.type === 'F') {\n\n    // log(A.parentClosure.digest(true))\n    // log(B.parentClosure.digest(true))\n    // if (A.nid === B.nid && A.parentClosure.digest() === B.parentClosure.digest()) {\n    //   log('yeees?')\n    // }\n    //\n    // log('Merging two functions?');\n    // log(A.nid, B.nid)\n    // log(A)\n    // log(B)\n    if (testing) throw 64;\n    store.linter.check('FUNCTION_MERGE', locFrom);\n  }\n\n  if (A.type === 'S' && B.type === 'S') {\n    return mergeIterables(locFrom, store, tidA, A, tidB, B, testing, recur);\n  }\n\n  if (A.type === 'M' && B.type === 'M') {\n    return mergeMaps(locFrom, store, tidA, A, tidB, B, testing, recur);\n  }\n\n  if (testing) throw 4;\n  store.linter.check('POLY_OTHER', locFrom);\n\n  store.linter.check('TOFIX', locFrom, 'this is an unknown merge kind and it is not implemented');\n  return tidA;\n}\nfunction mergeIterables(locFrom, store, tidA, A, tidB, B, testing, recur) {\n  log('Merging two iterables, so compare their `kind`:', tstr(A.kind), 'vs', tstr(B.kind));\n\n  ASSERT(A.type === B.type, 'should already have been checked to be the same');\n\n  if (A.kind === B.kind) {\n    log('Hack: Iterables with same kind, setting B to A');\n    if (!testing) {\n      store.linkTo(B, A);\n    }\n    mergeProps(locFrom, store, tidA, A, tidB, B, testing, recur);\n    return tidA;\n  }\n\n  const kindTeeA = store.get(A.kind);\n  const kindTeeB = store.get(B.kind);\n\n  if (kindTeeA.type === 'H') {\n    log('The kind of A was undetermined so setting A to B');\n    if (!testing) {\n      if (kindTeeA !== kindTeeB) {\n        store.linkTo(kindTeeA, kindTeeB);\n      }\n      A.kind = kindTeeB.tid;\n      store.linkTo(A, B);\n    }\n    mergeProps(locFrom, store, tidB, B, tidA, A, testing, recur);\n    return tidB;\n  }\n\n  if (kindTeeB.type === 'H') {\n    log('The kind of B was undetermined so setting B to A');\n    if (!testing) {\n      if (kindTeeA !== kindTeeB) {\n        store.linkTo(kindTeeB, kindTeeA);\n      }\n      B.kind = kindTeeA.tid;\n      store.linkTo(B, A);\n    }\n    mergeProps(locFrom, store, tidA, A, tidB, B, testing, recur);\n    return tidA;\n  }\n\n  log('A and B kind are set and different; merging them');\n\n  if (!testing) A.kind = B.kind = merge(locFrom, store, A.kind, B.kind, testing, recur);\n  if (!testing) {\n    store.linkTo(B, A);\n  }\n\n  mergeProps(locFrom, store, tidA, A, tidB, B, testing, recur);\n\n  log('Iterables merged. Pointing B to A.');\n\n  if (!testing) {\n    store.linkTo(B, A);\n  }\n\n  return tidA;\n}\nfunction mergeMaps(locFrom, store, tidA, A, tidB, B, testing, recur) {\n  log('Merging two maps, so compare their key and value kinds. Key: ', tstr(A.keyKind), 'vs', tstr(B.keyKind), '. Value: ', tstr(A.kind), 'vs', tstr(B.kind));\n\n  ASSERT(A.type === B.type, 'should already have been checked to be the same');\n\n  if (A.keyKind === B.keyKind && A.kind === B.kind) {\n    log('Hack: Map with same key and value kinds, setting B to A');\n    if (!testing) {\n      store.linkTo(B, A);\n    }\n    mergeProps(locFrom, store, tidA, A, tidB, B, testing, recur);\n    return tidA;\n  }\n\n  const keyKindTeeA = store.get(A.keyKind);\n  const keyKindTeeB = store.get(B.keyKind);\n  const valueKindTeeA = store.get(A.kind);\n  const valueKindTeeB = store.get(B.kind);\n\n  if (keyKindTeeA.type === 'H' && valueKindTeeA.type === 'H') {\n    log('The key and value kinds of A were undetermined so setting A to B');\n    if (!testing) {\n      if (keyKindTeeA !== keyKindTeeB) {\n        store.linkTo(keyKindTeeA, keyKindTeeB);\n      }\n      if (valueKindTeeA !== valueKindTeeB) {\n        store.linkTo(valueKindTeeA, keyKindTeeB);\n      }\n      A.keyKind = keyKindTeeB.tid;\n      A.kind = valueKindTeeB.tid;\n      store.linkTo(A, B);\n    }\n    mergeProps(locFrom, store, tidB, B, tidA, A, testing, recur);\n    return tidB;\n  }\n\n  if (keyKindTeeB.type === 'H' && valueKindTeeB.type === 'H') {\n    log('The key and value kinds of B was undetermined so setting B to A');\n    if (!testing) {\n      if (keyKindTeeA !== keyKindTeeB) {\n        store.linkTo(keyKindTeeB, keyKindTeeA);\n      }\n      if (valueKindTeeA !== valueKindTeeB) {\n        store.linkTo(valueKindTeeB, keyKindTeeA);\n      }\n      B.keyKind = keyKindTeeA.tid;\n      B.kind = valueKindTeeA.tid;\n      store.linkTo(B, A);\n    }\n    mergeProps(locFrom, store, tidA, A, tidB, B, testing, recur);\n    return tidA;\n  }\n\n  log('A and B key or value kinds are set and differently; merging them');\n\n  if (!testing) {\n    A.keyKind = B.keyKind = merge(locFrom, store, A.keyKind, B.keyKind, testing, recur);\n    A.kind = B.kind = merge(locFrom, store, A.kind, B.kind, testing, recur);\n    store.linkTo(B, A);\n  }\n\n  mergeProps(locFrom, store, tidA, A, tidB, B, testing, recur);\n\n  log('Maps merged. Pointing B to A.');\n\n  if (!testing) {\n    store.linkTo(B, A);\n  }\n\n  return tidA;\n}\nfunction mergeObjects(locFrom, store, tidA, A, tidB, B, testing, recur) {\n  log('Merging two objects');\n  log('A.props is', A.props);\n  log('B.props is', B.props);\n\n  ASSERT(A !== B);\n  ASSERT(!B.builtin);\n\n  mergeProps(locFrom, store, tidA, A, tidB, B, testing, recur);\n\n  log('Arrays merged. Replacing', tidB, 'in store with the Tee of', tidA);\n\n  if (!testing) {\n    store.linkTo(B, A);\n  }\n\n  return tidA;\n}\nfunction mergeProps(locFrom, store, tidA, A, tidB, B, testing, recur) {\n  ASSERT(!B.builtin, 'A may be built-in but B should not be because that is basically being replaced', A, B);\n  ASSERT(A.props && B.props, 'A and B ought to have properties', A, B);\n  ASSERT(A !== B);\n\n  // TODO: merge seen as well...????\n\n  // Merge the props of B into the props of A\n  B.props.forEach((b, name) => {\n    log('- Merging prop', [name]);\n    const a = A.props.get(name);\n    if (a !== b) {\n      if (!testing) {\n        if (name === '__proto__') store.linter.check('PROTO_MERGE', locFrom);\n        if (name === 'prototype') store.linter.check('PROTO_MERGE', locFrom);\n      }\n\n      if (a === undefined) {\n        if (!testing) A.setProp(name, b);\n      } else if (b !== undefined) {\n        if (!testing) A.setProp(name, merge(locFrom, store, a, b, testing, recur));\n      }\n    }\n  });\n}\n\nexport function testMerge(store, tidA, tidB) {\n  // This merge should be side effect free. It's not quite \"free\" so take care.\n  try {\n    merge(null, store, tidA, tidB, true);\n    return true;\n  } catch (v) {\n    log('- Test merge threw:', v);\n    ASSERT(typeof v === 'number', 'the test merge ought to only throw codes, this one threw something else', v);\n    return false;\n  }\n}\n\nexport function mergeAll(locFrom, tids, store) {\n  ASSERT(tids.length, 'do not call this with an empty array', tids);\n  tids.forEach(tid => ASSERT_TID(tid));\n\n  log('mergeAll with tids:', tids.map(tstr).join(', '));\n\n  let tid = tids[0];\n  for (let i=1; i<tids.length; ++i) {\n    tid = merge(locFrom, store, tid, tids[i]);\n  }\n\n  log('-> mergeAll result:', tstr(tid));\n\n  return tid;\n}\nexport function mergeTestAll(locFrom, tids, store) {\n  ASSERT(tids.length, 'do not call this with an empty array', tids);\n  tids.forEach(tid => ASSERT_TID(tid));\n\n  log('mergeAll with tids:', tids.map(tstr).join(', '));\n\n  const tid = tids[0];\n  for (let i=1; i<tids.length; ++i) {\n    if (!testMerge(store, tid, tids[i])) {\n      log('-> mergeTestAll result:', false);\n      return false;\n    }\n  }\n\n  log('-> mergeTestAll result:', true);\n\n  return true;\n}\n\nlet abc = 0;\nexport function fencedCloneToolDebug(fence, tid, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, root, debugDesc) {\n  ASSERT(typeof fence === 'number', 'fence is an number', fence);\n  ASSERT_TID(tid);\n  ASSERT(store);\n  ASSERT(recur instanceof Map, 'recur is a map', recur);\n  ASSERT(Array.isArray(arrInputs), 'arrInputs is an array', arrInputs);\n  ASSERT(mapReversedInputs instanceof Map, 'recur is a map', mapReversedInputs);\n  ASSERT(Array.isArray(deltaMutators), 'arrInputs is an array', deltaMutators);\n  ASSERT(deltaMutators.every(a => Array.isArray(a)), 'arrInputs is an array of arrays', deltaMutators);\n  ASSERT(Array.isArray(currentInputs), 'arrInputs is an array', currentInputs);\n  ASSERT(typeof debugDesc === 'string', 'debugDesc is an string', debugDesc);\n\n  if (isPrimitive(tid)) return tid;\n\n  let indentBefore = getIndent();\n\n  if (root) fenceStart(tid, store);\n  let r = '<crash>';\n  try {\n    r = fencedCloneTool(fence, tid, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc);\n    ASSERT(indentBefore === getIndent(), 'indent should be same if the process didnt crash', indentBefore, getIndent());\n    return r;\n  } finally {\n    if (root) fenceStop(tid, r, store);\n  }\n}\nexport function fenceStart(tid, store) {\n  return; // enable to debug some cloning\n\n  const tee = store.get(tid);\n  console.log('----', ++abc, tstr(tid), tee.tid !== tid ? '--> ' + tstr(tee.tid) : '');//, store.get(tid));\n\n  console.time('print time');\n  const s = tidToString(tid, store);\n  console.timeEnd('print time');\n\n  console.log('Input tee:');\n  console.log(s);\n\n  console.time('fence time');\n}\nexport function fenceStop(inputTid, cloneTid, store) {\n  return; // enable to debug some cloning\n\n  console.timeEnd('fence time');\n  if (cloneTid === '<crash>') return;\n\n  console.time('print time');\n  const t = tidToString(cloneTid, store);\n  console.timeEnd('print time');\n\n  console.log('Clone tee:');\n  console.log(t);\n}\nexport function fencedCloneTool(fence, inpTid, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc) {\n  ASSERT(typeof fence === 'number', 'fence is an number', fence);\n  ASSERT_TID(inpTid);\n  ASSERT(store);\n  ASSERT(recur instanceof Map, 'recur is a map', recur);\n  ASSERT(Array.isArray(arrInputs), 'arrInputs is an array', arrInputs);\n  ASSERT(mapReversedInputs instanceof Map, 'recur is a map', mapReversedInputs);\n  ASSERT(Array.isArray(deltaMutators), 'arrInputs is an array', deltaMutators);\n  ASSERT(deltaMutators.every(a => Array.isArray(a)), 'arrInputs is an array of arrays', deltaMutators);\n  ASSERT(Array.isArray(currentInputs), 'arrInputs is an array', currentInputs);\n  ASSERT(typeof debugDesc === 'string', 'debugDesc is an string', debugDesc);\n\n  log('- fencedCloneTool(', tstr(inpTid), ', ' + debugDesc + ')');\n  ASSERT(fencedCloneTool.length === arguments.length, 'arg count');\n  ASSERT(inpTid, 'should receive a tid', inpTid, arguments);\n  const tee = store.get(inpTid);\n  ASSERT(tee);\n  const tid = tee.tid;\n\n  if (tee.builtin) {\n    log('  -> builtin, not cloning');\n    return tee.tid;\n  }\n  if (tee.type === 'H') {\n    const pid = createPlaceholder(store, tee.tid + 'CL', 'cloning placeholder ' + tee.tid);\n    log('  -> placeholder; cloned to', tstr(pid)); // It is a bug if you don't\n    return pid;\n  }\n\n  const alreadyCloned = recur.get(tid);\n  if (alreadyCloned) {\n    // It may not have finished cloning (for recursive / cycles) or it may have (same refs in siblings branches)\n    log('This tid was already cloned so returning the tid of that clone:', tstr(alreadyCloned));\n    return alreadyCloned;\n  }\n\n  ASSERT(tee.iid, 'non-builtins should have an iid', tee);\n  if (tee.iid <= fence) {\n    group();\n    log('-> created before fence, not cloning. Need to find input tid for this of the current call and return that tid (not the initial call that got cached)');\n    log('-> Cached input tid:', tstr(tee.tid), ', now need to find the index');\n    log('- mapReversedInputs:', mapReversedInputs.size > 20 ? '<many>' : mapReversedInputs);\n    // Find the \"index\" of this tid\n    const index = mapReversedInputs.get(tee.tid);\n    // If the tid is not mapped then it's a closure.\n\n    //probleem: een closure kan ook een andere waarde hebben afhankelijk van de closure. MAar de digest zou dit moeten afvangen voor ons.\n    if (index === undefined) {\n      log('No index so this must be a closure (or a bug..). Returning the cached tid', tstr(tee.tid));\n      groupEnd();\n      return tee.tid;\n    }\n\n    // Return the input tid of the current call at the same index\n    const currentTee = store.get(currentInputs[index]);\n    log('Current input tid:', tstr(currentTee.tid));\n    const mutators = deltaMutators[index];\n    ASSERT(Array.isArray(mutators), 'each index should be a set of zero or more mutator functions', mutators);\n    mutators.forEach(mutator => mutator(store, currentTee.tid, currentInputs));\n    groupEnd();\n    return currentTee.tid;\n  }\n\n  // Note: the returned tid may not exist in the store yet (in case of recursion)\n  const ctid = tee.fencedClone(fence, recur, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs);\n  log('  -> cloned to', tstr(ctid));\n\n  return ctid;\n}\n\nexport function isPrimitive(inp) {\n  const tid = typeof inp !== 'string' ? inp.tid : inp;\n  ASSERT(typeof tid === 'string', 'gimme tees or strings', inp);\n  return ['undefined', 'null', 'boolean', 'number', 'string'].includes(tid);\n}\n\nexport function isPlaceholder(inp, store) {\n  const tid = typeof inp !== 'string' ? inp.tid : inp;\n  ASSERT(typeof tid === 'string', 'gimme tees or strings', inp);\n  const tee = store.get(tid);\n  return tee.type === 'H';\n}\n\nexport function digest(inTee, store, color, printFuncDigest, isCallee, depth = 0, recur = new Map) {\n  ASSERT(inTee, 'get tee', inTee);\n  ASSERT(store);\n  ASSERT_TID(typeof inTee === 'string' ? inTee : inTee.tid);\n  const tee = store.get(typeof inTee === 'string' ? inTee : inTee.tid);\n  console.log(' '.repeat(depth) + '| digest:', tstr(tee.tid), tidToString(tee.tid, store, true, depth * 2));\n  const r = _digest(tee, store, color, printFuncDigest, isCallee, depth+2, recur);\n  console.log(' '.repeat(depth) + '|-', r);\n  return r;\n}\nfunction _digest(tee, store, color, printFuncDigest, isCallee, depth = 0, recur) {\n\n  if (tee.builtin) {\n    if (color) return isCallee ? YELLOW + tee.tid + RESET : tstr(tee.tid);\n    return tee.tid;\n  }\n\n  if (recur.has(tee.tid)) return '^' + recur.get(tee.tid);\n  recur.set(tee.tid, recur.size);\n\n  if (depth > 20) {\n    if (depth > 100) {\n      // Print a bunch before bailing permanently\n      ASSERT(false, 'very large digest? this is probably a recursion problem...? (increase count to verify)'); // it may be legit. :/\n    }\n  }\n  ASSERT(tee, 'input should be a tee or the tid of a string, and it wasnt', arguments);\n\n  ASSERT(tee.props, 'all non-builtins have properties', tee);\n  let props = [];\n\n  tee.props.forEach((tid, key) => {\n    const tee = store.get(tid);\n    ASSERT(tee, 'tid should exist', tid, tee);\n    ASSERT(tee.builtin || tee.locFrom, 'non-builtin tees should have a locFrom', tid, tee);\n\n    if (key === '__proto__') {\n      if (tee.type === 'A' && tid === 'Array.prototype') return;\n      if (tee.type === 'C' && tid === 'Function.prototype') return;\n      if (tee.type === 'F' && tid === 'Function.prototype') return;\n      if (tee.type === 'O' && tid === 'Object.prototype') return;\n      if (tee.type === 'M' && tid === 'Map.prototype') return;\n      if (tee.type === 'S' && tid === 'Set.prototype') return;\n      props.push('__proto__:' + tid); // Let's not traverse inherited properties\n      return;\n    }\n\n    props.push(key + ':' + digest(tid, store, color, undefined, undefined, depth + 1, recur))\n  })\n  props = props.filter(Boolean);\n  if (!tee.props.has('__proto__')) props.push('__proto__:<none>');\n\n  const d = color ? DIM : '';\n  const y = color ? YELLOW : '';\n  const r = color ? RESET : '';\n\n  switch (tee.type) {\n    case 'A': { // array\n      return y + 'Array' + r + '['+(tee.kind ? digest(tee.kind, store, color, undefined, undefined, depth + 1, recur) : '??')+']<'+props.join(',')+'>';\n    }\n    case 'C': { // class\n      const bound = tee.tid[1] === 'B';\n      return y + 'Class' + (bound?'.bind':'') + r + '<'+props.join(',')+'>';\n    }\n    case 'F': { // function\n      const bound = tee.tid[1] === 'B';\n      const propsPart = unchangedConstructor(tee, store) ? '!!' : props.join(', ');\n      const ownDigest = (printFuncDigest ? '{' + d + tee.parentClosure.digest() + RESET + '}' : '');\n      const scopeDigest = [];\n      tee.reachableNames.forEach((newName, oldName) => {\n        scopeDigest.push(oldName+'='+tee.parentClosure.get(oldName));\n      });\n\n      return y + 'Func' + (bound?'.bind':'') + '['+tee.nid+']' + r + '<'+propsPart+'><'+scopeDigest.join(',')+'>' + ownDigest;\n    }\n    case 'O': { // object\n      return y + 'Object' + r + '<' + props.join(',') + '>';\n    }\n    case 'H': { // placeholder\n      // This is tricky but for now return the place holder tid as a way of guaranteeing uniqueness.\n      return tee.tid;\n    }\n    case 'S': { // Set\n      return y + 'Set' + r + '<' + (tee.kind ? digest(tee.kind, store, color, undefined, undefined, depth + 1, recur) : '??') + '>';\n    }\n    case 'M': { // Map\n      return y + 'Map' + r + '<' + (tee.keyKind ? digest(tee.keyKind, store, color, undefined, undefined, depth + 1, recur) : '??') + ', ' + (tee.kind ? digest(tee.kind, store, color, undefined, undefined, depth + 1, recur) : '??') + '>';\n    }\n    default:\n      log(tee);\n      store.linter.check('TOFIX', {filename: '<unknown>', column: 0, line: 0}, 'new tee type not yet implemented');\n  }\n}\n\nexport function unchangedConstructor(tee, store) {\n  const props = tee.props;\n  if (props.size !== 2) return false;\n  const prototype = props.get('prototype');\n  if (prototype === undefined) return false;\n  const proto = props.get('__proto__');\n  if (proto === undefined) return false;\n\n  const p = store.get(prototype);\n  if (!p || !p.props) return false;\n  if (p.props.size !== 1) return false;\n  if (p.props.get('__proto__') !== 'Object.prototype') return false;\n\n  if (proto !== 'Function.prototype') return false;\n\n  return true;\n}\n\nfunction ind(indent, extra) {\n  if (indent === -1) return '';\n  return ' '.repeat(indent + extra);\n}\n\nexport function tidToString(_tid, store, digest = false, indent = 0, depth = 0, recur = new Map, recurId = new Map) {\n  ASSERT_TID(_tid, NO_SUPER_VALUE);\n  // If indent is -1 then do not indent or space\n\n  if (_tid === NO_SUPER_VALUE) return 'NO_SUPER_VALUE';\n\n  const tee = store.get(_tid);\n  const tid = tee.tid;\n\n  if (tee.builtin) return tid;\n  const ref = recur.get(tid);\n  if (typeof ref === 'number') return '<cycle['+( tid)+']^'+ref+'>';\n  else if (ref) return '<same-ref['+( tid)+']>';\n  recur.set(tid, depth);\n  recurId.set(tid, recurId.size);\n  const r = _tidToString(tee, tid, store, digest, indent, depth, recur, recurId);\n  recur.set(tid, r);\n  return r;\n}\nfunction _tidToString(tee, tid, store, digest, indent , depth, recur, recurId) {\n  const nl = ~indent ? '\\n' : '';\n  const printid = tid // digest ? recurId.get(tid) : tid;\n\n  switch (tee.type) {\n    case 'A': // Array\n      return 'Array('+printid+')<' + nl +\n        ind(indent, 2) + tidToString(tee.kind, store, digest, ~indent ? indent + 2 : indent, depth + 1, recur, recurId) + nl +\n        ind(indent, 0) + '>' + tidToStringProps(tee, store, digest, indent, depth + 1, recur, recurId);\n    case 'C': // Class\n      return 'Class('+printid+', ' + tidToString(tee.superClass, store, digest, indent, depth + 1, recur) + ')' + tidToStringProps(tee, store, indent, depth + 1, recur, recurId);\n    case 'F': // Function\n      return 'Function('+printid+')' + tidToStringProps(tee, store, digest, indent, depth + 1, recur, recurId);\n    case 'H': // PlaceHolder\n      return 'PlaceHolder('+printid+')' + tidToStringProps(tee, store, digest, indent, depth + 1, recur, recurId);\n    case 'M': // Map\n      return 'Map('+printid+')<' + nl +\n        ind(indent, 2) + tidToString(tee.keyKind, store, digest, ~indent ? indent + 2 : indent, depth + 1, recur, recurId) + ',' + nl +\n        ind(indent, 2) + tidToString(tee.kind, store, digest, ~indent ? indent + 2 : indent, depth + 1, recur, recurId) + nl +\n        ind(indent, 0) + '>' + tidToStringProps(tee, store, digest, indent, depth + 1, recur, recurId);\n    case 'O': // Object\n      return 'Object('+printid+')' + (tidToStringProps(tee, store, digest, indent, depth + 1, recur, recurId) || '<{}>');\n    case 'S': // Set\n      return 'Set('+printid+')<' + nl +\n        ind(indent, 2) + tidToString(tee.kind, store, digest, ~indent ? indent + 2 : indent, depth + 1, recur, recurId) + nl +\n        ind(indent, 0) + '>' + tidToStringProps(tee, store, digest, indent, depth + 1, recur, recurId);\n    default: \n      console.log(tee);\n      ASSERT(false, 'need to implement new tee type', tee);\n  }\n}\nexport function tidToStringProps(tee, store, digest, indent, depth, recur, recurId) {\n  let s = [];\n  tee.props.forEach((tid, key) => {\n    if (key === '__proto__') {\n      // Hide the __proto__ if it's the default (most of the time that's the case)\n      // Be explicit when there is no __proto__\n      if ([\n        'A:Array.prototype',\n        'C:Function.prototype',\n        'F:Function.prototype',\n        'M:Map.prototype',\n        'O:Object.prototype',\n        'S:Set.prototype',\n      ].includes(tee.type + ':' + tid)) return; // omit\n    }\n    s.push(key + (~indent ? ': ' : ':') + tidToString(tid, store, digest, ~indent ? indent + 2 : indent, depth, recur, recurId));\n  });\n  if (!tee.props.has('__proto__')) s.push('__proto__' + (~indent ? ': ' : ':') + '<none>');\n  if (tee.type !== 'H' && !tee.props.has('__proto__')) {\n    s.push('__proto__: <none>');\n  }\n  if (!s.length) return '';\n  const nl = ~indent ? '\\n' : '';\n  const sp = ~indent ? ' ' : '';\n  return '<+{' + nl +\n    s\n      .map(s => ind(indent, 2) + s + nl)\n      .join(~indent ? '' : ',') +\n    ind(indent, 0) +\n  '}>';\n}\n","~/proj/zetype/src/actions.mjs":"import {\n  ASSERT,\n  ASSERT_LOC,\n  ASSERT_TID,\n  WHITE_BLACK,\n  RED,\n  BLUE,\n  RESET,\n  BOLD,\n  GREEN,\n  PURPLE,\n  DIM,\n\n  SUPER_PROP_OWNER_NOT_FOR_CLASS,\n  SUPER_PROP_OWNER_NOT_FOR_GLOBAL,\n  SUPER_PROP_OWNER_NOT_A_METHOD,\n  ASSERT_SUPER_PROP_OWNER,\n\n  NO_DEFAULT_VALUE,\n  NO_SUPER_VALUE,\n\n  createPlaceholder,\n  createArrayTid,\n  createClassTid,\n  createFuncoTid,\n  createMapTid,\n  createObjectTid,\n  createSetTid,\n  dir,\n  getIndent,\n  group,\n  groupEnd,\n  log,\n  printNode,\n  tstr, YELLOW,\n} from \"./utils.mjs\"\nimport {\n  digest,\n  fencedCloneTool,\n  fencedCloneToolDebug,\n  isPrimitive,\n  merge,\n  fenceStart,\n  fenceStop,\n  testMerge,\n  mergeAll,\n  mergeTestAll,\n  tidToString\n} from \"./tools.mjs\"\nimport * as Tenko from '../node_modules/tenko/build/tenko.prod.mjs'; // This way it works in browsers and nodejs ... :/\n\nexport function playActions(locFrom, store, actions, calleeTee, callerContext, closure, stack) {\n\n  ASSERT(calleeTee.fromFilename, 'every callable should have a fromFilename', calleeTee);\n\n  const filename = calleeTee.fromFilename;\n\n  const indentBefore = getIndent();\n\n  // TOP: callee context\n  // OVER: first arg (if any)\n  // ROT: second arg (if any)\n  let returnValue = undefined;\n  actions.forEach(([action, column, line, data]) => {\n\n    const indentBefore = getIndent();\n    const r = playAction({filename, column, line}, action, data, store, calleeTee, callerContext, closure, stack);\n    ASSERT(indentBefore === getIndent(), 'indent should be same before/after action', action);\n\n    if (action === '@return') {\n      if (returnValue === undefined) returnValue = r;\n      else returnValue = merge(locFrom, store, returnValue, r);\n    }\n  });\n\n  ASSERT(indentBefore === getIndent(), 'indent should be same before/after rolling actions');\n\n  if (returnValue === undefined) {\n    log('This call did not explicitly return, so it implicitly returns `undefined`');\n    returnValue = 'undefined';\n  }\n\n  return returnValue;\n}\n\nfunction pushTlog(token, obj) {\n  if (!token.tlog) token.tlog = [];\n  token.tlog.push(obj);\n}\n\nfunction playAction(locFrom, action, data, store, actionCalleeTee, callerContext, closure, stack) {\n  group('-- ', BLUE + action + RESET, DIM + locFrom.column + ':' + locFrom.line + RESET, data, ' '.repeat(50), stack ? '[' + stack.map(tstr).join(', ') + ']' : '<no stack>');\n\n  ASSERT(locFrom.filename === actionCalleeTee.fromFilename, 'filename ought to be the file where the actions are located', locFrom, actionCalleeTee);\n  stack.forEach(tid => ASSERT_TID(tid, NO_DEFAULT_VALUE, NO_SUPER_VALUE));\n\n  const fileState = store.fileData.get(locFrom.filename);\n\n  let returns = undefined; // Only used by @return\n  switch (action) {\n    case '@arguments': {\n      const objTid = playActionObj(locFrom, store, undefined, stack, ['length'], ['number']);\n      playActionBinding(locFrom, store, stack, closure, 'arguments', 'lex', objTid);\n      store.get(objTid).builtin = true; // prevents cloning problems\n      log('Created', tstr(objTid), 'as `arguments` object');\n      break;\n    }\n\n    case '@arr': {\n      const [elementCount] = data;\n\n      const tids = [];\n      for (let i=0; i<elementCount; ++i) {\n        tids.push(stack.pop());\n      }\n\n      log('Array elements (' + tids.length + '):', tids.map(tstr).join(', '));\n\n      let canMerge = true;\n      if (tids.length > 0) {\n        if (!mergeTestAll(locFrom, tids, store)) {\n          store.linter.check('ARR_MONO_KIND', locFrom);\n          log('Will just use first element as the kind without merging the others:', tstr(tids[0]));\n          canMerge = false;\n        }\n      }\n\n      let kind = tids.length > 0 ? (canMerge ? mergeAll(locFrom, tids, store) : tids[0]) : createPlaceholder(store, 'HAK', 'array kind for empty array literal');\n\n      const arrTid = playActionArr(locFrom, store, undefined, stack, kind);\n      log('--> Arr is:', tstr(arrTid));\n      stack.push(arrTid);\n\n      break;\n    }\n\n    case '@assign': {\n      // TODO: clean up\n      const [name, op, tokenOpIndex] = data;\n      ASSERT(typeof tokenOpIndex === 'number' && tokenOpIndex >= -1, 'tokenOp num', tokenOpIndex);\n      const tokenOp = fileState.tokens[tokenOpIndex];\n      ASSERT(tokenOp && tokenOp.tlog);\n\n      log('Assignment to `' + name + '`');\n      const bindingTid = closure.find(name, locFrom);\n      log('Which resolves to tid:', tstr(bindingTid));\n      const right = stack.pop();\n      if (op !== '=') {\n        ASSERT(op[0] !== '=' && op[0] !== '!' && op[op.length - 1] === '=', 'meh');\n        if (op === '+=') {\n          if (bindingTid !== right || (bindingTid !== 'number' && bindingTid !== 'string')) {\n            store.linter.check('COMPOUND_ASSIGN_PLUS', locFrom);\n          }\n        } else if (right !== 'number' || bindingTid !== 'number') {\n          store.linter.check('COMPOUND_ASSIGN_TYPE', locFrom);\n        }\n      }\n      tokenOp.tlog.push({wat: '#binop', left: bindingTid, right});\n\n      log('Which gets this value assigned now:', tstr(right));\n      const result = merge(locFrom, store, bindingTid, right);\n      if (bindingTid === 'undefined' && result !== 'undefined') {\n        log('Updating the binding tid for `' + name + '` to', tstr(result), 'because it was undefined and the merge returned something else. Model is broken, anyways.');\n        closure.set(name, result);\n      }\n      log('Resulting in', tstr(result));\n      stack.push(result);\n\n      break;\n    }\n\n    case '@binding': {\n      const [name, kind] = data;\n\n      ASSERT(locFrom.filename, 'filename should be known?', locFrom);\n\n      const tid = stack.pop();\n\n      playActionBinding(locFrom, store, stack, closure, name, kind, tid);\n      break;\n    }\n\n    case '@binop': {\n      const [operator, tokenOpIndex] = data;\n\n      const left = stack[stack.length - 2];\n      const right = stack[stack.length - 1];\n\n      const tokenOp = fileState.tokens[tokenOpIndex];\n      tokenOp.tlog.push({wat: '#binop', left, right});\n\n      break;\n    }\n\n    case '@body_start': {\n      const [] = data;\n\n      // Start of a function body\n      // if (actionCalleeTee.funcTokenIndex >= 0) {\n      // TODO\n      //   const funcTokenIndex = actionCalleeTee.funcTokenIndex;\n      //   const fromFilename = actionCalleeTee.fromFilename;\n      //   const funcToken = store.fileData.get(fromFilename).tokens[funcTokenIndex];\n      //   ASSERT(funcToken.tlog, 'should be set in phase2', funcToken);\n      //   funcToken.tlog[funcToken.tlog.length - 1].paramTidDesc = actionCalleeTee.paramBindingNames.map(name => name + ': ' + closure.get(name)).reverse().join(', ') || '<none>';\n      // }\n\n      break;\n    }\n\n    case '@call': {\n      const [argCount, spreadAt] = data;\n\n      // Stack, from top to bottom:\n      // - tid to call\n      // - tid to be context according to syntax (may be ignored)\n      // - args + default, tid pairs (first from the top is arg, second is default) from first to last\n\n      const calleeTid = stack.pop();\n      log('Stack has this tid to call:', tstr(calleeTid));\n      const calleeTee = store.get(calleeTid);\n\n      // Figure out context. Depends on a few factors like callee AST node and whether function is bound at all.\n      const contextOnStack = stack.pop();\n      log('Stack has this tid for context:', tstr(contextOnStack));\n\n      const contextTid = calleeTee.boundContext ? calleeTee.boundContext : contextOnStack;\n      if (calleeTee.boundContext) log('Callee context is bound to', tstr(calleeTee.boundContext), 'so ignoring context from stack');\n\n      log('Did this call have a spread? spreadAt =', spreadAt);\n\n      // Get args, and also remove them from the stack\n\n      const callArgs = argCount ? stack.slice(-argCount) : [];\n      stack.length -= argCount;\n      log('Fetched the', argCount, 'args from the stack:', callArgs.map(tstr).join(', '), 'it now has', stack.length, 'items left');\n\n      const indentBefore = getIndent();\n\n      group('invoking now from', locFrom.filename+':'+locFrom.column+':'+locFrom.line);\n      const returnTid = metaCall(locFrom, calleeTid, contextTid, false, stack, argCount, callArgs, spreadAt, store, '', store.instanceId, false);\n      stack.push(returnTid);\n      groupEnd();\n\n      const locFunc = {filename: calleeTee.fromFilename, column: calleeTee.fromColumn, line: calleeTee.fromLine};\n      locToToken(store, locFrom).tlog.push({wat: '#invoke', locCall: locFrom, locFunc, calleeTid, argCount, callArgs, contextTid, returned: returnTid});\n\n      log('End of call to', tstr(calleeTid));\n\n      ASSERT(indentBefore === getIndent(), 'indent should be same before and after call');\n\n      break;\n    }\n\n    case '@class': {\n      // Top on the stack is the prototype object to use (super property access relies on this)\n      // Second of stack is the value that the class extends, or `null` if it doesn't extend at all\n      // The rest of the stack consists of the methods for this class, in reversed methodNames order\n\n      const [nid, className, methodTypes, methodNames, userDesc] = data;\n\n      const prototypeTid = stack.pop();\n      const superClassTid = stack.pop();\n\n      const prototypeTee = store.get(prototypeTid);\n\n      // The stack should have all the method ids, in order of methodNames. Top of stack was last method in class.\n      // We collect the static methods to set as own props and record all prototype methods straight on the prototype.\n\n      const staticMethods = []; // In reverse order of appearance (don't think this matters)\n      let hasConstructor = false;\n      methodNames.forEach((name, i) => {\n        const type = methodTypes[i];\n        if (type === 'static') {\n          log('- Recording static method `' + name + '` as', tstr(stack[stack.length - 1]));\n          staticMethods.push([name, stack.pop()]);\n        } else {\n          // Set directly on the prototype object\n          if (name === 'constructor') {\n            // parser ensures this does not happen twice\n            log('- Recording `constructor` as', tstr(stack[stack.length - 1]));\n            hasConstructor = true;\n          } else {\n            log('- Recording instance method `' + name + '` as', tstr(stack[stack.length - 1]));\n          }\n          prototypeTee.setProp(name, stack.pop())\n        }\n      });\n\n      if (!hasConstructor) {\n        log('Has no explicit constructor, creating a dud now');\n        // Implicit class constructors come in two types: either one that is a noop and returns the instance or one\n        // that calls `super()` and then returns the instance (but not the result of `super()`). Depends on `extends`.\n\n        prototypeTee.setProp('constructor', superClassTid === NO_SUPER_VALUE ?  '#constructor_sans_super' : '#constructor_with_super');\n      }\n\n      const classTid = playActionClass(locFrom, store, undefined, stack, nid, className, staticMethods, closure, userDesc, prototypeTid, superClassTid);\n      stack.push(classTid);\n\n      break;\n    }\n\n    case '@condition': {\n      let [] = data;\n\n      const tid = stack.pop();\n      log('Checking whether', tstr(tid), 'is a boolean because it is used in a statement condition or logical expression');\n\n      if (tid !== 'boolean') {\n        // When you use a non-bool like string or number as the condition for `if` or `while`, etc.\n        // Doesn't break our model so a lint works too\n\n        if (tid === 'undefined') {\n          store.linter.check('TEST_UNDEF', locFrom);\n        } else  if (tid === 'null') {\n          store.linter.check('TEST_NULL', locFrom);\n        } else if (tid === 'number' || tid === 'string') {\n          store.linter.check('TEST_NUMSTR', locFrom);\n        } else {\n          ASSERT(!isPrimitive(tid));\n          store.linter.check('TEST_OBJ', locFrom);\n        }\n      }\n\n      break;\n    }\n\n    case '@defaults': {\n      let [] = data;\n\n      // Given two tids on the stack, default and then given, determine whether the given value is undefined and\n      // that the default value is not null, in that case push the default value back on the stack. Otherwise verify\n      // that the default value can be merged to the given value (but do not actually merge) and use the given value.\n\n      const defaultValue = stack.pop();\n      const givenValue = stack.pop();\n\n      if (givenValue === 'undefined' && defaultValue !== NO_DEFAULT_VALUE) {\n        stack.push(defaultValue);\n      } else {\n        if (defaultValue !== NO_DEFAULT_VALUE) {\n          group('There was an explicit pattern value so default value is not used here. Will do a test merge for linting purposes:');\n          if (!testMerge(store, givenValue, defaultValue)) {\n            store.linter.check('UNUSED_DEFAULT_ARG_POLY', locFrom);\n          }\n          groupEnd();\n        }\n        stack.push(givenValue);\n      }\n\n      log('Value:', tstr(givenValue), ', default:', tstr(defaultValue), '--> result:', tstr(stack[stack.length - 1]));\n\n      break;\n    }\n\n    case '@drop': {\n      stack.pop();\n      break;\n    }\n\n    case '@dup': {\n      stack.push(stack[stack.length - 1]);\n      break;\n    }\n\n    case '@dyn_get': {\n\n      const [depth] = data;\n\n      const prop = store.final(stack.pop());\n      const arrOrStrTee = store.get(stack.pop());\n      log('Prop:', prop, ', obj:', arrOrStrTee.tid);\n\n      if (arrOrStrTee.type === 'O' && arrOrStrTee.kind !== false && (prop === 'string' || prop === 'number')) {\n        ASSERT_TID(arrOrStrTee.kind);\n        log('Dynamic property access on a plain object as if it were a Map. Object has kind', tstr(arrOrStrTee.kind));\n\n        const teeKind = store.get(arrOrStrTee.kind);\n        if (teeKind.type === 'H') {\n          store.linter.check('DYNAMIC_INDEX_ACCESS_EMPTY_OBJECT', locFrom);\n          log('Changing the kind of object from undetermined to ', tstr('undefined'), 'now');\n          store.linkTo(teeKind, store.get('undefined'));\n          arrOrStrTee.kind = 'undefined';\n          stack.push('undefined');\n        } else {\n          store.linter.check('DYNAMIC_ACCESS_OBJECT_AS_MAP', locFrom);\n          log('This was dynamic property access on an object-as-map, returning its kind', tstr(teeKind.tid));\n          stack.push(teeKind.tid);\n        }\n        log('Dynamic lookup on Object-as-Map:', tstr(arrOrStrTee.tid), '--> kind:', tstr(stack[stack.length - 1]));\n      } else if (arrOrStrTee.tid === 'string' && prop === 'number') {\n        log('Indexed access on a string probably returns a', tstr('string')); // Although, `''[0] === undefined`\n        store.linter.check('DYNAMIC_INDEX_ACCESS_STRING', locFrom);\n        stack.push('string');\n      } else if (arrOrStrTee.type === 'A' && prop === 'number') {\n        log('The tee is an array and the property a number; return the kind', tstr(arrOrStrTee.kind));\n        const teeKind = store.get(arrOrStrTee.kind);\n        if (teeKind.type === 'H') {\n          store.linter.check('DYNAMIC_INDEX_ACCESS_EMPTY_ARRAY', locFrom);\n          log('Changing the kind of array from undetermined to ', tstr('undefined'), 'now');\n          store.linkTo(teeKind, store.get('undefined'));\n          arrOrStrTee.kind = 'undefined';\n          stack.push('undefined');\n        } else {\n          store.linter.check('DYNAMIC_INDEX_ACCESS_ARRAY', locFrom);\n          log('This was numbered access on an array, returning its kind', tstr(arrOrStrTee.kind));\n          stack.push(arrOrStrTee.kind);\n        }\n        log('Indexed lookup on Array:', tstr(arrOrStrTee.tid), '--> kind:', tstr(stack[stack.length - 1]));\n      } else {\n        store.linter.check('DYNAMIC_PROP_ACCESS', locFrom, 'phase3, step' + depth);\n        stack.push('undefined');\n        log('Dynamic property lookup on non-array:', tstr(arrOrStrTee.tid), '-->', tstr('undefined'));\n      }\n\n      break;\n    }\n\n    case '@dyn_set': {\n\n      const [tokenOpIndex] = data;\n\n      const propTee = store.get(stack.pop());\n      const propTid = propTee.tid;\n      const objTee = store.get(stack.pop());\n      const objTid = objTee.tid;\n      const valueTee = store.get(stack.pop());\n\n      log('key:', propTid, ', obj:', objTid);\n\n      if (isPrimitive(objTid)) {\n        if (objTid === 'undefined' || objTid === 'null') {\n          store.linter.check('PROP_SET_ON_NULL_UNDEF', locFrom);\n        } else {\n          store.linter.check('PROP_SET_ON_PRIMITIVE', locFrom);\n        }\n      } else if (objTee.type === 'A' && propTid === 'number') {\n        // We can do this, even if we do have to issue a warning for it.\n        store.linter.check('DYNAMIC_INDEX_ACCESS_ARRAY', locFrom);\n        log('Merging the kind of the array,', tstr(objTee.kind),', with the value being assigned')\n        objTee.kind = merge(locFrom, store, objTee.kind, valueTee.tid);\n\n        if (tokenOpIndex >= 0) {\n          const tokenOp = fileState.tokens[tokenOpIndex];\n          ASSERT(tokenOp && tokenOp.tlog);\n          tokenOp.tlog.push({wat: '#set', arrTid: objTid, name: 'kind', valueTid: valueTee.tid});\n        }\n      } else if (objTee.type === 'O' && objTee.kind !== false && (propTid === 'number' || propTid === 'string')) {\n        ASSERT_TID(objTee.kind);\n        // This is object-as-a-map and we tentatively support this under objection.\n\n        if (testMerge(store, objTee.kind, valueTee.tid)) {\n          objTee.kind = merge(locFrom, store, objTee.kind, valueTee.tid);\n          store.linter.check('DYNAMIC_ACCESS_OBJECT_AS_MAP', locFrom);\n          log('The object kind is the same as the value being assigned. The model kind of supports this.');\n        } else {\n          store.linter.check('DYNAMIC_PROP_ACCESS', locFrom);\n          log('The kind of the object does not match the value being assigned so this object cannot be used as a map.');\n          objTee.kind = false;\n        }\n\n        if (tokenOpIndex >= 0) {\n          const tokenOp = fileState.tokens[tokenOpIndex];\n          ASSERT(tokenOp && tokenOp.tlog);\n          tokenOp.tlog.push({wat: '#set', arrTid: objTid, name: 'kind', valueTid: valueTee.tid});\n        }\n      } else {\n        // Not much we can do about this. We don't track the value of the key so we don't know what property is\n        // being updated here. Typically you would consider to use a Map here, although there are plenty of legit\n        // cases for not doing that. Plus real world code is still riddled with this. Maybe some typing DSL could\n        // solve this for us but so far I've not found a way to statically determine this properly.\n        store.linter.check('DYNAMIC_PROP_ACCESS', locFrom);\n      }\n\n      stack.push(valueTee.tid);\n\n      break;\n    }\n\n    case '@export_as': {\n\n      const [name] = data;\n\n      ASSERT(typeof name === 'string');\n\n      const top = stack.pop();\n      ASSERT_TID(top);\n\n      log('Recording `' + locFrom.filename + '` to be exporting symbol `' + name + '` with type', tstr(top));\n      fileState.exports.set(name, top);\n\n      break;\n    }\n\n    case '@func': {\n      const [nid, funcName, paramNames, paramBindingNames, hasRest, minParamRequired, body, funcType, thisAccess, reachableNames, funcTokenIndex, fromFilename, fromColumn, fromLine, userDesc] = data\n\n      const funcTid = playActionFunc(locFrom, {\n        store,\n        tid: undefined,\n        stack,\n        closure,\n        callerContext,\n        nid,\n        funcName,\n        paramNames,\n        paramBindingNames,\n        hasRest,\n        minParamRequired,\n        body,\n        funcType,\n        thisAccess,\n        reachableNames,\n        ownerClass: undefined,\n        superClass: undefined,\n        boundArgs: undefined,\n        boundContext: undefined,\n        funcTokenIndex,\n        fromFilename,\n        fromColumn,\n        fromLine,\n        userDesc,\n      });\n      stack.push(funcTid);\n\n      break;\n    }\n\n    case '@func_expr_name': {\n      const [name] = data\n      // Hack to create local binding of the name of a function expression\n      // At compile time (phase 2) we won't know the func reference yet so we can't bind it and when the function\n      // gets called we can't really push another reference every time we call just in case, so instead this hack\n      // allows me to grab the internal reference of the current calleeTee and bind it to the local binding for its name\n      ASSERT(typeof closure.calleeTid === 'string', 'all closures ought to have a reference to the tid that was called when they were created', closure);\n      log('Pushing the closure.calleeTid to the stack to create the binding:', tstr(closure.calleeTid));\n\n      playActionBinding(locFrom, store, stack, closure, name, 'var', closure.calleeTid);\n\n      break;\n    }\n\n    case '@get': {\n      const [propName, hasDefault] = data\n      let tee = store.get(stack.pop());\n      const tid = tee.tid;\n      log('Getting property `' + propName + '` from', tstr(tid));\n\n      if (tid === 'undefined' || tid === 'null') {\n        store.linter.check('PROP_ON_NULL_UNDEF', locFrom, propName);\n        stack.push('undefined');\n      } else {\n        let ind = '';\n\n        ASSERT(tee);\n        let props = tee.props;\n        if (isPrimitive(tee.tid)) {\n          log(tstr(tee.tid), 'is a primitive, redirecting to box class');\n          let next = '';\n          switch (tee.tid) {\n            case 'undefined':\n              store.linter.check('PROP_ON_NULL_UNDEF', locFrom);\n              next = 'undefined';\n              break;\n            case 'null':\n              store.linter.check('PROP_ON_NULL_UNDEF', locFrom);\n              next = 'undefined';\n              break;\n            case 'boolean':\n              next = 'Boolean.prototype';\n              break;\n            case 'number':\n              next = 'Number.prototype';\n              break;\n            case 'string':\n              next = 'String.prototype';\n              break;\n            default:\n              ASSERT(false, 'there are only 5 primitives');\n          }\n\n          log('=>', tstr(next));\n          ind += '  ';\n          tee = store.get(next);\n          props = tee.props;\n        }\n\n        ASSERT(props, 'icanhaz props?', [tee]);\n\n        function dig(props, propName) {\n          group();\n          log('- dig', propName, '{ '+[...props.entries()].map(([k, v]) => k + ':' + tstr(v)).join(', ')+' }');\n          const prop = props.get(propName);\n          if (prop !== undefined) {\n            log(' - Found! ===>', tstr(prop));\n            groupEnd();\n            return prop;\n          }\n\n          const proto = props.get('__proto__');\n          if (proto === undefined) {\n            log('- Not found in proto chain, resolving to', tstr('undefined'));\n            if (hasDefault) {\n              store.linter.check('PROP_NOT_FOUND_HAS_DEFAULT', locFrom, propName);\n            } else {\n              store.linter.check('PROP_NOT_FOUND', locFrom, propName);\n            }\n            groupEnd();\n            return 'undefined';\n          }\n\n          log('=>', tstr(proto));\n\n          const protoTee = store.get(proto);\n          ASSERT(protoTee, 'proto should exist', [proto, protoTee]);\n          ASSERT(protoTee.props); // This isn't a guarantee, but as long as no test case violates this ...\n\n          const found = dig(protoTee.props, propName);\n          if (protoTee.seen.has(propName)) {\n            const before = protoTee.seen.get(propName);\n            log('Merging resolved property with tee that was already observed on this proto:', tstr(before));\n            merge(locFrom, store, found, before);\n          } else {\n            log('Property not observed before. Marking resolved tid as observed for this property on this proto');\n            ASSERT_TID(found);\n            protoTee.seen.set(propName, String(found));\n          }\n\n          groupEnd();\n          return found;\n        }\n\n        const propTid = dig(props, propName);\n        if (tee.seen.has(propName)) {\n          const before = tee.seen.get(propName);\n          log('Merging found tid', tstr(propTid), 'with what was already observed for property `' + propName + '`:', tstr(before));\n          merge(locFrom, store, propTid, before);\n        } else {\n          log('Property not observed before. Marking resolved tid as being observed on this object');\n          ASSERT_TID(propTid);\n          tee.seen.set(propName, String(propTid));\n        }\n\n        stack.push(propTid || 'undefined'); // TODO: resolve cache\n      }\n\n      locToToken(store, locFrom).tlog.push({wat: '#prop', tid: stack[stack.length - 1]});\n      break;\n    }\n\n    case '@in': {\n      const [node] = data\n\n      const left = stack.pop();\n      const right = stack.pop();\n\n      // TODO: for a minifier approach, we should be able to replace this with a true or false\n\n      // switch (left) {\n      //   case 'boolean':\n      //     if (right !== 'Boolean') {\n      //       store.linter.check('INSTANCEOF_FAIL', locFrom);\n      //     }\n      //     break;\n      //   case 'number':\n      //     if (right !== 'Number') {\n      //       store.linter.check('INSTANCEOF_FAIL', locFrom);\n      //     }\n      //     break;\n      //   case 'string':\n      //     if (right !== 'String') {\n      //       store.linter.check('INSTANCEOF_FAIL', locFrom);\n      //     }\n      //     break;\n      //   default:\n      //     todo // solidify support\n      // }\n\n      break;\n    }\n\n    case '@instanceof': {\n      const [] = data\n\n      const left = stack.pop();\n      const right = stack.pop();\n      stack.push('boolean');\n\n      // TODO: for a minifier approach, we should be able to replace this with a true or false.\n\n      break;\n    }\n\n    case '@ident': {\n      const [name] = data;\n      const tid = closure.find(name, locFrom);\n      log('->', tstr(tid));\n      ASSERT(tid, 'ident should receive a tid', tid);\n      stack.push(tid);\n      // console.log('actionCalleeTee:', actionCalleeTee)\n      // console.log('Current file where the call is invoked from?', filename, ', file where current callee is from?', actionCalleeTee.fromFilename)\n      // console.log('This token is at', column, line, 'which yields', locToToken(store, filename, column, line))\n      locToToken(store, locFrom).tlog.push({wat: '#ident', tid});\n      // resolve the ident in the current scope to get its tid and push it\n      break;\n    }\n\n    case '@import_binding': {\n\n      const [localName, exportedName, fromFilename] = data;\n\n      ASSERT(typeof localName === 'string');\n      ASSERT(typeof fromFilename === 'string');\n\n      if (store.fileData.has(fromFilename)) {\n        log('Importing `' + exportedName + '` from `' + fromFilename + '`');\n        const tid = store.fileData.get(fromFilename).exports.get(exportedName);\n        if (tid === undefined) {\n          log('The symbol `' + exportedName + '` was not found in the exports for `' + fromFilename + '`. Assuming `undefined` instead.');\n          log('The exports object for that file:', store.fileData.get(fromFilename).exports);\n          store.linter.check('IMPORT_UNKNOWN', locFrom, '`' + exportedName + '` from ' + fromFilename);\n          closure.set(localName, 'undefined');\n        } else {\n          log('-->', tstr(tid));\n          ASSERT_TID(tid);\n          ASSERT(store.get(tid), 'todo: different modules should still record to the same store overall...?');\n\n          ASSERT(!closure.has(localName), 'parser should ensure the import binding is unique');\n          closure.set(localName, tid);\n        }\n      } else {\n        console.log('Tried to import a symbol `' + exportedName + '` from a file `' + fromFilename + '` but this file is unknown to the system so going to ignore it and assume `undefined` for it.');\n        store.linter.check('IMPORT_FILE_UNKNOWN', locFrom, fromFilename, localName);\n        closure.set(localName, 'undefined');\n      }\n\n      break;\n    }\n\n    case '@import_star': {\n\n      const [localName, fromFilename] = data;\n\n      ASSERT(typeof localName === 'string');\n      ASSERT(typeof fromFilename === 'string');\n\n      if (store.fileData.has(fromFilename)) {\n        const fileData = store.fileData.get(fromFilename);\n        log('Importing star from `' + fromFilename + '` for which we registered', fileData.exports.size, 'exported symbols');\n        log('Star export objects has these symbols: [', [...fileData.exports.entries()].map(([symbol, tid]) => symbol + ': ' + tstr(tid)).join(', '), ']');\n\n        const propNames = [...fileData.exports.keys()];\n        const propTids = [...fileData.exports.values()];\n        const objTid = playActionObj(locFrom, store, undefined, stack, propNames, propTids);\n        log('Registering star export to name `' + localName + '`');\n        closure.set(localName, objTid);\n      } else {\n        log('Tried to import star from a file `' + fromFilename + '` but this file is unknown to the system so going to ignore it and assume `{}` for it.');\n        store.linter.check('IMPORT_FILE_UNKNOWN', locFrom, fromFilename, localName);\n        const objTid = playActionObj(locFrom, store, undefined, stack, [], []);\n        log('Registering empty star export to name `' + localName + '`');\n        closure.set(localName, objTid);\n      }\n\n      break;\n    }\n\n    case '@kind': {\n      const [defaultTidOrTrue, desc] = data;\n\n      const arrTid = stack.pop();\n\n      const kindTid = playActionKind(locFrom, store, stack, arrTid);\n      stack.push(kindTid);\n\n      break;\n    }\n\n    case '@lint': {\n      const [condition, msg] = data;\n\n      const have = stack[stack.length - 1];\n      if (condition === 'primitive') {\n        if (isPrimitive(have)) store.linter.check(msg, locFrom);\n      } else {\n        if (have === condition) store.linter.check(msg, locFrom);\n      }\n\n      break;\n    }\n\n    case '@lint-inv': {\n      const [condition, msg] = data;\n\n      const have = stack[stack.length - 1];\n      if (condition === 'primitive') {\n        if (!isPrimitive(have)) store.linter.check(msg, locFrom);\n      } else {\n        if (have !== condition) store.linter.check(msg, locFrom);\n      }\n\n      break;\n    }\n\n    case '@log': {\n      // We already print the arg anyways so no need to repeat it\n      // const [...args] = data;\n      // log('Log:', ...args);\n      break;\n    }\n\n    case '@logical': {\n      const [operator] = data;\n\n      const right = stack.pop();\n      const left = stack.pop();\n      ASSERT_TID(left);\n      ASSERT_TID(right);\n\n      log('Logical operator (`'+operator+'`) found with', tstr(left), 'and', tstr(right));\n\n      switch (left+':'+right) {\n        case 'boolean:boolean':\n          // This is the norm\n          stack.push('boolean');\n          break;\n\n        case 'undefined:undefined':\n        case 'null:null':\n        case 'number:number':\n        case 'string:string':\n          // This is not the norm but because both sides are the same, the return type must be the same\n          store.linter.check('LOGICAL_OPERANDS_SAME_PRIMITIVE', locFrom, left, operator, right);\n          stack.push(left);\n          break;\n\n        case 'undefined:null':\n        case 'undefined:boolean':\n        case 'undefined:number':\n        case 'undefined:string':\n        case 'null:undefined':\n        case 'null:boolean':\n        case 'null:number':\n        case 'null:string':\n          // Because we can guarantee a is falsy, we can determine the result based on the operator\n          store.linter.check('LOGICAL_OPERANDS_NULL_UNDEF_LEFT', locFrom, left, operator, right);\n          if (operator === '&&') {\n            log(tstr(left), 'left of `&&` must mean it returns left');\n            stack.push(left);\n          } else {\n            log(tstr(left), 'left of `||` must mean it returns right:', tstr(right));\n            stack.push(right);\n          }\n          break;\n\n        // case 'boolean:undefined':\n        // case 'boolean:null':\n        // case 'boolean:number':\n        // case 'boolean:string':\n        // case 'number:undefined':\n        // case 'number:null':\n        // case 'number:boolean':\n        // case 'number:string':\n        // case 'string:undefined':\n        // case 'string:null':\n        // case 'string:boolean':\n        // case 'string:number':\n\n        default:\n          if (isPrimitive(left)) {\n            ASSERT(left !== right, 'all other cases should have been checked', left, right);\n            log('Cannot safely determine return type so model is broken now. Will arbitrarily return the left type.');\n            store.linter.check('LOGICAL_OPERANDS_PRIM_LEFT', locFrom, left, operator, right);\n            stack.push(left);\n          } else {\n            // This must be an object of sorts. That's always truthy. So if it's left, then return that, otherwise\n            // it depends on the type of a whether we can guarantee soundness.\n            store.linter.check('LOGICAL_OPERANDS_OBJ_LEFT', locFrom, left, operator, right);\n            // This does not even warrant a merge since it always returns the same side\n            if (operator === '&&') {\n              log(tstr(left), 'left of `&&` must mean it returns right:', tstr(right));\n              stack.push(right);\n            } else {\n              log(tstr(left), 'left of `||` must mean it returns left');\n              stack.push(left);\n            }\n          }\n          break;\n      }\n\n      break;\n    }\n\n    case '@merge': {\n      const [] = data;\n\n      const tidA = stack.pop();\n      const tidB = stack.pop();\n      const tid = merge(locFrom, store, tidA, tidB);\n      stack.push(tid);\n      break;\n    }\n\n    case '@new': {\n      const [argCount, spreadAt] = data;\n\n      const wrapperClassTid = stack.pop();\n\n\n      const callArgs = argCount ? stack.slice(-argCount) : [];\n      stack.length -= argCount;\n\n      const newTid = playActionNew(locFrom, store, stack, spreadAt, wrapperClassTid, callArgs);\n      stack.push(newTid);\n\n      break;\n    }\n\n    case '@obj': {\n      const [propNames] = data;\n\n      const propCount = propNames.length;\n      const propTids = propCount ? stack.slice(-propCount) : [];\n      stack.length -= propCount;\n      // propNames.forEach(name => {\n      //   propTids.push(stack.pop());\n      // });\n\n      const objTid = playActionObj(locFrom, store, undefined, stack, propNames, propTids);\n      stack.push(objTid);\n      break;\n    }\n\n    case '@obj_init': {\n      const [propNames, spreads] = data;\n\n      // Top of the stack should be an object, probably clean apart from a __proto__\n      // After that, there ought to be as many values on the stack as there are property names passed on\n\n      const tid = stack.pop(); // Get it out of the way. We'll push it back on afterwards.\n      const objTee = store.get(tid);\n\n      log('Object to initialize:', tstr(tid));\n      log('Properties to init:', propNames);\n\n      group('Processing properties');\n      propNames.forEach((name, i) => {\n        ASSERT(typeof spreads[i] === 'boolean', 'spreads should be a 1:1 flag for each arg', propNames, spreads);\n        if (spreads[i]) {\n          // There can be multiple spreads. Their props override the props in this new object\n          const tee = store.get(stack.pop());\n          log('Prop', i, 'was a spread so copy the props of', tstr(tee.tid));\n\n          // undefined and null are not errors here\n          // string is the exception here since that will splat the string into numbered props. which we cant track. :(\n          if (isPrimitive(tee.tid)) {\n            // This case is unlikely but a noop, except for the string case, which we can't support and causes unsoundness\n            if (tee.tid === 'string') {\n              store.linter.check('OBJ_SPREAD_STRING', locFrom);\n            }\n          } else {\n            // So how does this work in our model with forward updating props? I guess it works well. Hope I'm not wrong.\n            ASSERT(tee.props);\n            tee.props.forEach((tid, name) => {\n              log('- copying', name, 'as', tstr(tid), 'for spreading');\n              objTee.setProp(name, tid);\n            });\n          }\n        } else {\n          log('Adding', name, 'as', tstr(stack[stack.length - 1]));\n          objTee.setProp(name, stack.pop());\n        }\n      });\n      groupEnd();\n\n      log('->', tstr(tid));\n      stack.push(tid);\n      break;\n    }\n\n    case '@of': {\n      // Get the kind of the type on the stack\n      // The stack type is the rhs of a for-of loop. Should be a proper iterable but for the moment we'll limit\n      // ourselves to strings and arrays. TODO: improve coverage\n      const tid = stack.pop();\n      ASSERT_TID(tid);\n      if (tid === 'string') {\n        // Strings are iterable and iterate over each character as an individual string\n        log('The kind of a', tstr('string'), 'is a string');\n        stack.push('string');\n      } else {\n        const tee = store.get(tid);\n\n        // TODO: map, set\n        if (tee.type !== 'A' && tid !== 'string') {\n          store.linter.check('FOR_OF_NON_ARRAY', locFrom);\n          log('Pushing `undefined` as the \"kind\" of this non-array');\n          stack.push('undefined');\n        } else {\n          log('The kind of', tstr(tid), 'is', tstr(tee.kind));\n          stack.push(tee.kind);\n        }\n      }\n      break;\n    }\n\n    case '@objrest': {\n      const [excludedPropNames] = data;\n\n      // Take the object from the stack and create a new, default, object that has all the owh properties of\n      // this object, except those passed on in the `excludedPropNames` list. This is how object rest works.\n      // (Note: this also does not seem to copy a `__proto__`, if it exists. This is part of the list already.)\n\n      const objTid = stack.pop();\n      log('Creating a rest object from the current object:', tstr(objTid), ', without these names:', excludedPropNames);\n\n      const objTee = store.get(objTid);\n      ASSERT(objTee);\n\n      const newObjPropNames = [];\n      const newObjPropTids = [];\n\n      if (objTee.props) {\n        objTee.props.forEach((tid, name) => {\n          if (!excludedPropNames.includes(name)) {\n            newObjPropTids.push(tid);\n            newObjPropNames.push(name);\n          }\n        })\n      } else if (objTid === 'undefined' || objTid === 'null') {\n        store.linter.check('PROP_ON_NULL_UNDEF', locFrom);\n      } else if (isPrimitive(objTid)) {\n        store.linter.check('OBJ_REST_ON_PRIMITIVE', locFrom);\n      } else {\n        ASSERT(false, 'what is being spread here that as no props and is no primitive? null?', objTee); // TODO: array kind null\n      }\n      // For the sake of most-likely-to-break-lest; create an object object regardless\n\n      const newObjTid = playActionObj(locFrom, store, undefined, stack, newObjPropNames, newObjPropTids);\n\n      log('Rest result:', tstr(newObjTid));\n      stack.push(newObjTid);\n\n      break;\n    }\n\n    case '@param_binding': {\n      const [name] = data;\n\n      ASSERT(typeof name === 'string', 'name is a string, not a node', name);\n\n      log('Setting param `' + name + '`');\n      ASSERT(!closure.has(name), 'the param name should not yet be bound at this point', name, closure);\n\n      const defaultValue = stack.pop();\n      ASSERT_TID(defaultValue, NO_DEFAULT_VALUE);\n\n      const argValue = stack.pop();\n      ASSERT_TID(argValue);\n\n      log('- Arg value is', tstr(argValue));\n      log('- Default value:', tstr(defaultValue));\n\n      // If there was no default then we don't need to do anything here\n      if (defaultValue === NO_DEFAULT_VALUE) {\n        log('This param has no default value, initialize param to whatever the arg value was');\n        closure.set(name, argValue);\n      } else if (argValue === 'undefined') {\n        log('Overriding the binding with the default value');\n        closure.set(name, defaultValue);\n      } else {\n        group('There was an explicit arg value so default value is not used here. Will do a test merge for linting purposes:');\n        // TODO: this may need some more thought since `function f({X = 1} = {x: 'y'}) {}` is probably lintable with some careful code but is missed right now\n        if (!testMerge(store, argValue, defaultValue)) {\n          store.linter.check('UNUSED_DEFAULT_ARG_POLY', locFrom);\n        }\n        groupEnd();\n        closure.set(name, argValue);\n        log('Initialized `' + name + '` to', tstr(argValue));\n      }\n\n      const tokenIdent = getFirstToken(store, locFrom);\n      const report = {wat: '#init', tid: closure.get(name), name};\n      pushTlog(tokenIdent, report);\n\n      break\n    }\n\n    case '@plus': {\n      const [] = data;\n\n      // The stack will contain two values\n\n      const right = stack.pop();\n      const left = stack.pop();\n      if (left === 'string' && right === 'string') {\n        log('A', tstr('string'), '+', tstr('string'), 'is a', tstr('string'));\n        stack.push(left);\n      } else if (left === 'number' && right === 'number') {\n        log('A', tstr('number'), '+', tstr('number'), 'is a', tstr('number'));\n        stack.push(left);\n      } else if ((left === 'string' && right === 'number') || (right === 'string' && left === 'number')) {\n        log('A', tstr(left), '+', tstr(right), 'is turning a number into a string');\n        store.linter.check('PLUS_MERGE_NUM_STR', locFrom, left, right);\n        // By far most likely this ends up a string\n        stack.push('string');\n      } else if ((left === 'string' && isPrimitive(right)) || (right === 'string' && isPrimitive(left))) {\n        const nonString = left === 'string' ? right : left;\n        log('A', tstr(left), '+', tstr(right), 'is turning a', tstr(nonString), 'into a string');\n        store.linter.check('PLUS_MERGE_STR_PRIM', locFrom, left, right);\n        // By far most likely this ends up a string\n        stack.push('string');\n      } else if ((left === 'number' && isPrimitive(right)) || (right === 'number' && isPrimitive(left))) {\n        const nonString = left === 'number' ? right : left;\n        switch (nonString) {\n          case 'undefined':\n            store.linter.check('PLUS_MERGE_NUM_UNDEF', locFrom, left, right);\n            break;\n          case 'null':\n            store.linter.check('PLUS_MERGE_NUM_NULL', locFrom, left, right);\n            break;\n          case 'boolean':\n            store.linter.check('PLUS_MERGE_NUM_BOOL', locFrom, left, right);\n            break;\n          case 'number':\n          case 'string':\n            return ASSERT(false);\n          default:\n            ASSERT(false, 'wat primitive?', nonString);\n\n        }\n        log('A', tstr(left), '+', tstr(right), 'is turning a', tstr(nonString), 'into a string');\n        store.linter.check('PLUS_MERGE_STR_PRIM', locFrom, left, right);\n        // By far most likely this ends up a string TODO: but it may not (with valueOf hacks)\n        stack.push('string');\n      } else {\n        // TODO: we can improve these heuristics and support hacks where this still leads to a number. not worth much tho.\n        log('A', tstr(left), '+', tstr(right), 'is bad and probably ends up as a', tstr('number'));\n        store.linter.check('PLUS_MERGE_TYPE', locFrom, right, right);\n        // By far most likely this ends up a string\n        merge(locFrom, store, left, right);\n        stack.push('string');\n      }\n\n      break;\n    }\n\n    case '@push': {\n      const [tid] = data;\n      stack.push(tid);\n      break;\n    }\n\n    case '@regex': {\n      const [] = data;\n\n      const regexObjTid = playActionObj(locFrom, store, undefined, stack, ['__proto__'], ['RegExp.prototype']);\n      stack.push(regexObjTid);\n\n      break;\n    }\n\n    case '@return': {\n      const [] = data;\n      // TODO: validate this return value against all other return values, and possibly an implicit return value\n      const tid = stack.pop();\n      returns = tid;\n\n      break;\n    }\n\n    case '@set': {\n      const [name, tokenOpIndex] = data;\n      ASSERT(typeof tokenOpIndex === 'number' && tokenOpIndex >= -1, 'tokenOp num', tokenOpIndex);\n\n      const _objTid = stack.pop();\n      const _valueTid = stack.pop();\n      ASSERT_TID(_objTid);\n      ASSERT_TID(_valueTid);\n      const valueTid = store.final(_valueTid);\n      const objTee = store.get(_objTid);\n      const objTid = objTee.tid;\n\n      if (tokenOpIndex >= 0) {\n        const tokenOp = fileState.tokens[tokenOpIndex];\n        ASSERT(tokenOp && tokenOp.tlog);\n        tokenOp.tlog.push({wat: '#set', objTid, name, valueTid});\n      }\n\n      log('Assigning to property `' + name + '` on', tstr(objTid));\n      log('- Current value is:', !isPrimitive(objTid) && objTee.props.has(name) ? tstr(objTee.props.get(name)) : '<does not have this prop>');\n      log('- Seen before as:', isPrimitive(objTee.tid) ? '(irrelevant for primitive)' : objTee.seen.has(name) ? tstr(objTee.seen.get(name)) : '<not observed before>');\n      log('- Value to assign:', tstr(valueTid));\n\n      if (isPrimitive(objTid)) {\n        if (objTid === 'null' || objTid === 'undefined') {\n          store.linter.check('PROP_SET_ON_NULL_UNDEF', locFrom, name);\n        } else {\n          store.linter.check('PROP_SET_ON_PRIMITIVE', locFrom, name);\n        }\n        log('Ignoring the attempt to set property `' + name + '` to a ' + tstr(valueTid) + ' on a primitive value, as JS would');\n        stack.push(valueTid); // JS does return the same value, not the resulting value\n      } else {\n        const prop = objTee.props.get(name);\n        const saw = objTee.seen.get(name);\n\n        if (objTee.props.has(name)) {\n          if (name === 'prototype') {\n            // This voids the sound-and-completeness :shrug:\n            // By changing the .prototype you could in retrospect change the result of reading certain properties for\n            // an arbitrary object (existing instances that inherit from this prototype). I think we can support this\n            // in full at some point, like by tracking history of properties read on an object at any time.\n            store.linter.check('SET_PROTOTYPE', locFrom);\n\n            // TODO: object merge\n\n            objTee.setProp('prototype', valueTid);\n            stack.push(valueTid);\n          } else if (name === '__proto__') {\n            // This voids the sound-and-completeness :shrug:\n            // Changing the __proto__ has a bunch of unforseen consequences that are currently ignored. So if you\n            // ignore this lint, the onus is on you :)\n            store.linter.check('SET_PROTO', locFrom);\n\n            // TODO: object merge\n\n            objTee.setProp('__proto__', valueTid);\n            stack.push(valueTid);\n          } else {\n            log('Object already had this property, merging them');\n            const tid = merge(locFrom, store, objTee.props.get(name), valueTid);\n            stack.push(tid);\n          }\n        } else {\n          // Note: the seen map still has to merge with the value so may still reject this `set` entirely\n          log('Object did not have this property yet');\n          if (objTee.seen.has(name)) {\n            log('But have observed (seen) this before as a:', tstr(saw));\n            // A little silly, but let's ignore assignments of `undefined` in this case.\n            // Not likely to that case legit in the wild but no need to warn against it either.\n            if (valueTid !== 'undefined') {\n              store.linter.check('SET_NEW_BUT_SEEN_PROP', locFrom);\n            }\n          } else {\n            store.linter.check('SET_NEW_UNSEEN_PROP', locFrom, name);\n          }\n          group('Now setting prop `' + name + '` to', tstr(valueTid));\n\n          const resultTid = objTee.setProp(name, valueTid);\n          ASSERT_TID(resultTid, 'each setProp should return the tid', resultTid);\n          ASSERT(objTee.props.get(name) === resultTid, 'the prop should now have the returned tid', objTee.props.get(name), resultTid);\n          stack.push(resultTid);\n          groupEnd();\n        }\n\n        if (objTee.seen.has(name)) {\n\n          // If prop === seen then we already did that merge above\n          if (prop !== saw) {\n            const before = objTee.seen.get(name);\n            log('Previously observed this property to be:', tstr(before), 'merging it with the new value:', tstr(valueTid));\n            const result = merge(locFrom, store, valueTid, before);\n            ASSERT_TID(result);\n            objTee.seen.set(name, String(result));\n          }\n          const tid = stack[stack.length - 1];\n          ASSERT_TID(tid);\n          objTee.seen.set(name, tid);\n        } else {\n          log('This property was not observed before. Marking it as observed now'); // TODO: we will probably want a read/write check as well, in which case we should skip this \"observe\" because it's only relevant when actually read.\n          ASSERT_TID(valueTid);\n          objTee.seen.set(name, valueTid);\n        }\n\n        log('-> prop=', tstr(objTee.props.get(name)), ', seen=', tstr(objTee.seen.get(name)), ', kind=', tstr(objTee.kind));\n      }\n\n      break;\n    }\n\n    case '@super_call': {\n      const [argCount, spreadAt] = data;\n      if (spreadAt !== -1) store.linter.check('TOFIX', locFrom, 'super spread');\n\n      // Top of the stack is the `extends` value of the class to which the construct that contains this `super()`\n      // belongs, followed by the arg+default pairs, first to last, arg goes first, default goes second\n\n      const superClassTid = stack.pop();\n      ASSERT_TID(superClassTid);\n      if (superClassTid === 'null') {\n        store.linter.check('SUPER_NULL', locFrom);\n      }\n      log('The `extends` value to use is:', tstr(superClassTid));\n\n      const callArgs = argCount ? stack.slice(-argCount) : [];\n      stack.length -= argCount;\n\n      log('Arguments:', callArgs.map(tstr).join(', '));\n\n      if (superClassTid === NO_SUPER_VALUE) {\n        // The AST has no node for this meaning the class did not have an `extends` part, different from `extends null`\n        store.linter.check('SUPER_CALL_WITHOUT_SUPER', locFrom);\n      } else {\n        const superClassTee = store.get(superClassTid);\n        // TODO: validate that the tee is a valid constructor (not arrow, non-class-bind, builtin funcs, etc)\n\n        // Top of the stack now ought to be the super() args in reverse order. There is no callee since we must manually\n        // resolve the constructor function to call.\n\n        // We must now call the constructor-function of the class that is being extended, which is available in the\n        // `superClassTee` tee. The `super()` \"production\" is syntactically restricted to es6 class constructors, so at\n        // least that's an invariant.\n        // Using `superClassTee` we can go three ways:\n        // - the value is not a constructor -> runtime error, already thrown above\n        // - the value is an es5 class -> invoke it as a function\n        // - the value is an es6 class -> dynamically resolve its constructor and invoke it\n        // Context remains the same (ought to be an instance of the caller, subclass of the next callee\n\n        let constructTid = superClassTid;\n\n        if (isPrimitive(superClassTid)) {\n          store.linter.check('SUPER_PRIMITIVE', locFrom);\n          break;\n        }\n\n        // Class may be result of `.bind()`, but that does not change how `super()` resolves here\n        if (superClassTee.funcType === 'class' || superClassTee.funcType.startsWith('class-')) {\n          log('Resolving the constructor of an es6 class');\n          const prototypeTid = superClassTee.props.get('prototype');\n          log('.prototype.prototype:', tstr(prototypeTid));\n          ASSERT(prototypeTid, 'es6 classes cannot have their prototype stripped');\n          const prototypeTee = store.get(prototypeTid);\n          ASSERT(prototypeTee, 'should exist');\n          const constructorTid = prototypeTee.props.get('constructor');\n          ASSERT(constructorTid, 'es6 classes must have a constructor, explicit or implicit', constructorTid);\n          constructTid = constructorTid;\n          log('.prototype.constructor:', tstr(constructorTid));\n        } else {\n          log('Value is not a class, calling it as an ES5 class');\n        }\n\n        log('Passing on the callerContext as-is:', tstr(callerContext));\n\n        group('invoking now');\n        const returnTid = metaCall(locFrom, constructTid, callerContext, true, stack, argCount, callArgs, spreadAt, store, superClassTid, store.instanceId, false);\n        stack.push(returnTid);\n        groupEnd();\n      }\n\n      break;\n    }\n\n    case '@super_prop': {\n      const [] = data; // this action is supposed to push the value of `super` onto the stack. regular member expression happens based on that.\n\n      // For classes and properties, the property is indirectly bound to the `<owner>.__proto__` where owner is the\n      // prototype of a class or an object literal which in source code contained the method containing the super\n      // property access. We had to use a special stack to track this because it's a runtime reference.\n\n      const superPropOwnerTid = closure.superPropOwner;\n      log('- owner:', tstr(superPropOwnerTid));\n      ASSERT(superPropOwnerTid, 'The parser should restrict where super properties are allowed, causing an invariant where this must always be something');\n      ASSERT_SUPER_PROP_OWNER(superPropOwnerTid);\n\n      if (typeof superPropOwnerTid === 'number') {\n        store.linter.check('SUPER_INVALID', locFrom);\n        stack.push('undefined');\n        break;\n      }\n\n      const superOwnerTee = store.get(superPropOwnerTid);\n      ASSERT(superOwnerTee, 'must exist');\n\n      log('superOwnerTee.funcType:', superOwnerTee.funcType);\n\n      if (superOwnerTee.type === 'O') {\n        log('Owner is an Object, resolve `owner.__proto__`');\n\n        const protoTid = superOwnerTee.props.get('__proto__');\n        log('- owner.__proto__:', tstr(protoTid));\n\n        stack.push(protoTid);\n      } else {\n        log('Owner is a Class, resolve `owner.prototype`');\n\n        const protoTid = superOwnerTee.props.get('prototype');\n        log('- owner.prototype:', tstr(protoTid));\n\n        // The protoTee is what we want to get properties from so that's what we'll leave on the stack\n        stack.push(protoTid);\n      }\n\n      break;\n    }\n\n    case '@super_stack_push': {\n\n      const [] = data;\n\n      const objTid = stack.pop();\n\n      ASSERT_TID(objTid, NO_SUPER_VALUE);\n      store.superStack.push(objTid);\n\n      log('super prop owner stack now:', store.superStack.map(tstr).join(', '));\n      log('Stack now:', stack.map(tstr).join(', '));\n\n      break;\n    }\n\n    case '@super_stack_pop': {\n      const [] = data;\n\n      stack.push(store.superStack.pop());\n\n      log('super prop owner stack now:', store.superStack.map(tstr).join(', '));\n      log('Stack now:', stack.map(tstr).join(', '));\n\n      break;\n    }\n\n    case '@this': {\n      const [] = data;\n\n      ASSERT(locFrom.filename, 'filename should be known', locFrom);\n\n      const tid = stack.pop();\n\n      playActionBinding(locFrom, store, stack, closure, 'this', 'lex', tid);\n      break;\n    }\n\n    default:\n      log('todo: implement action:', action);\n      ASSERT(false, 'need to implement action ' + action);\n  }\n  groupEnd();\n\n  return returns;\n}\n\nfunction mapInput(store, tid, arr, map) {\n  ASSERT(store);\n  ASSERT_TID(tid);\n  ASSERT(Array.isArray(arr), 'should receive an array to put tids into', arr);\n  ASSERT(map instanceof Map, 'should receive a map for the reverse lookup', map);\n  // Add the tid to the arr and its index to the map\n  // Walk any properties and kinds, do the same.\n  // Ignore builtins (TODO: should also ignore anything that's newer than the fence... but that'll only lead to unnecessary computation, I think of default args. No problem right now.)\n\n  const tee = store.get(tid);\n  if (tee.builtin) return; // We can ignore globals for this case\n  if (map.has(tee.tid)) return; // the arr should contain unique tids\n  const i = arr.length;\n  arr.push(tee.tid);\n  map.set(tee.tid, i); // Reverse lookup: <tid, index> -> key is tid and maps to arr index\n  // Walk through props. It can't be a primitive (-> builtin) so it must have props\n  tee.props.forEach(tid => mapInput(store, tid, arr, map));\n  if (tee.type === 'A') {\n    mapInput(store, tee.kind, arr, map);\n  } else if (tee.type === 'S') {\n    mapInput(store, tee.kind, arr, map);\n  } else if (tee.type === 'M') {\n    mapInput(store, tee.keyKind, arr, map);\n    mapInput(store, tee.kind, arr, map);\n  }\n\n  // I don't think we need to care about anything else? bound stuff, functions, super?\n}\nfunction getSimpleState(store, tid, arr) {\n  ASSERT(store);\n  ASSERT_TID(tid);\n  ASSERT(arr === null || Array.isArray(arr), 'arr should be an array or explicitly null', arr);\n\n  const tee = store.get(tid);\n  if (tee.builtin) {\n    return {\n      props: new Map,\n      keyKind: undefined,\n      valueKind: undefined,\n      alias: null,\n    };\n  }\n  ASSERT(isPrimitive(tee.tid) || tee.alias === null, 'should get unaliased tees here', tee.tid, tee);\n  ASSERT(tee.alias === null || typeof tee.alias === 'object', 'tee.alias is null or a tee', tee);\n  const details = {\n    props: new Map(tee.props),\n    keyKind: undefined,\n    valueKind: undefined,\n    alias: tee.alias,\n  };\n  if (tee.type === 'A') {\n    details.valueKind = tee.kind;\n  } else if (tee.type === 'S') {\n    details.valueKind = tee.kind;\n  } else if (tee.type === 'M') {\n    details.keyKind = tee.keyKind;\n    details.valueKind = tee.kind;\n  }\n\n  if (arr) arr.push(details);\n  return details;\n}\nfunction getDelta(instanceFence, outputDetails, inputDetails, arrInputs, mapReversedInputs, allDeltaMutators) {\n  // Properties are only added so we only need to check them one way\n  ASSERT(typeof instanceFence === 'number', 'fence is an number', instanceFence);\n  ASSERT(outputDetails && typeof outputDetails === 'object', 'outputDetails is a details object', outputDetails);\n  ASSERT(inputDetails && typeof inputDetails === 'object', 'inputDetails is a details object', inputDetails);\n  ASSERT(Array.isArray(arrInputs), 'inputDetails is an array', arrInputs);\n  ASSERT(mapReversedInputs instanceof Map, 'mapReversedInputs is a map', mapReversedInputs);\n\n  let mutators = [];\n  outputDetails.props.forEach((addedTid, name) => {\n    if (!inputDetails.props.has(name)) {\n      // Add mutator\n      mutators.push((store, tid, currentInputs) => {\n        const tee = store.get(tid); // This is a \"current call input tid\"\n\n        store.linter.suppress(true); // Should disable linting to prevent duplicate messages due to cloning\n        const cachedTid = fencedCloneToolDebug(instanceFence, addedTid, store, new Map, arrInputs, mapReversedInputs, allDeltaMutators, currentInputs, false, '<cloning a prop for updating delta>');\n        store.linter.suppress(false);\n\n        tee.setProp(name, cachedTid);\n      });\n    }\n  });\n\n  if (outputDetails.keyKind !== undefined) {\n    // Add mutator\n    mutators.push((store, tid, currentInputs) => {\n      const tee = store.get(tid); // This is a \"current call input tid\"\n\n      store.linter.suppress(true); // Should disable linting to prevent duplicate messages due to cloning\n      const cachedTid = fencedCloneToolDebug(instanceFence, outputDetails.keyKind, store, new Map, arrInputs, mapReversedInputs, allDeltaMutators, currentInputs, false, '<cloning the key kind for updating delta>');\n      store.linter.suppress(false);\n\n      tee.keyKind = cachedTid;\n    });\n  }\n\n  if (outputDetails.valueKind !== undefined) {\n    // Add mutator\n    mutators.push((store, tid, currentInputs) => {\n      const tee = store.get(tid); // This is a \"current call input tid\"\n\n      store.linter.suppress(true); // Should disable linting to prevent duplicate messages due to cloning\n      const cachedTid = fencedCloneToolDebug(instanceFence, outputDetails.valueKind, store, new Map, arrInputs, mapReversedInputs, allDeltaMutators, currentInputs, false, '<cloning the value kind for updating delta>');\n      store.linter.suppress(false);\n\n      // Same for array, map, and set (it finally pays off!)\n      tee.kind = cachedTid;\n    });\n  }\n\n  ASSERT(inputDetails.alias === null, 'the alias should not yet be set (always initialized to null)', inputDetails);\n  ASSERT(outputDetails.alias === null || typeof outputDetails.alias === 'object', 'alias is a null or a tee', outputDetails);\n  if (outputDetails.alias !== null) {\n    // Add mmutator\n    mutators.push((store, tid, currentInputs) => {\n      const tee = store.get(tid); // This is a \"current call input tid\"\n\n      store.linter.suppress(true); // Should disable linting to prevent duplicate messages due to cloning\n      const cachedTid = fencedCloneToolDebug(instanceFence, outputDetails.alias.tid, store, new Map, arrInputs, mapReversedInputs, allDeltaMutators, currentInputs, false, '<cloning the alias for updating delta>');\n      store.linter.suppress(false);\n\n      // Same for array, map, and set (it finally pays off!)\n      store.linkTo(tee, store.get(cachedTid)); // A little tricky :/\n    })\n  }\n\n  return mutators;\n}\nfunction getDeltas(store, instanceFence, arrInputs, befores, mapReversedInputs) {\n  ASSERT(store);\n  ASSERT(typeof instanceFence === 'number', 'instance fence is a number', instanceFence);\n  ASSERT(Array.isArray(arrInputs), 'arrInputs is an array', arrInputs);\n  ASSERT(Array.isArray(befores), 'befores is an array', befores);\n  ASSERT(mapReversedInputs instanceof Map, 'mapReversedInputs is a map', mapReversedInputs);\n\n  // Find differences in props and kinds and return a list of callbacks that, given a store and tid, will apply the\n  // delta to that tid as well (add properties / set kinds / set alias).\n  const deltaMutators = [];\n  for (let i=0; i<arrInputs.length; ++i) {\n    const state = getSimpleState(store, store.final(arrInputs[i]), null);\n    const mutators = getDelta(instanceFence, state, befores[i], arrInputs, mapReversedInputs, deltaMutators);\n    deltaMutators.push(mutators);\n  }\n  return deltaMutators;\n}\nfunction scanInputs(store, tids) {\n  const arrInputs = [];\n  const mapReversedInputs = new Map;\n\n  tids.forEach(tid => {\n    mapInput(store, tid, arrInputs, mapReversedInputs);\n  });\n\n  const befores = []; // \"simple\" data structure with the relevant tids per tid: props, kinds. recursively (?)\n  arrInputs.forEach(tid => getSimpleState(store, store.final(tid), befores));\n\n  return {arrInputs, mapReversedInputs, befores};\n}\n\nexport function metaCall(\n  locFrom, // Filename with actual code that triggered this call (indirectly for stuff coming from builtins)\n  calleeTid,\n  contextTid,\n  isNew,\n  stack,\n  initialArgCount,\n  initialCallArgs,\n  spreadAt,\n  store,\n  classTid,\n  instanceFence,\n  lambdaCallback, // For lambda callbacks; suppress lint errors if more args were passed than params and context for arrows\n) {\n  // Should not use the stack anymore. Args and context should be passed on explicitly.\n\n  // The instanceFence is used to determine whether the returned value (recursively) should be cloned or returned as is.\n  // The idea is that a reference that already existed before calling the current function is passed on, perhaps\n  // indirectly (as a property for example) and when using a cached return value, should not be cloned.\n  // If the value has a newer instance id then it was created during the call to this function and if we are to use\n  // it from the cache, the returned tee should be cloned, recursively applying this heuristic to any properties or\n  // other tees the cached tee may reference.\n  // Functions and classes are tbd in this but I think can get the same treatment.\n\n  log('metaCall(' + tstr(calleeTid) + ') with', initialArgCount, 'args, last arg' + (spreadAt>=0?'':' NOT')+' being a '+(spreadAt>=0?BOLD:'')+'spread'+RESET);\n  ASSERT(locFrom && locFrom.filename, 'metaCall should have an origin, or the builtin placeholder', locFrom);\n\n  log('Initial args: [', initialCallArgs.map(tstr).join(', '), ']');\n  log('Resolving callee:', tstr(calleeTid));\n  if (isNew) {\n    log('This is `new` on', tstr(classTid));\n    ASSERT(classTid, 'new should receive the classTid');\n  }\n  // Resolve tid\n  const calleeTee = store.get(calleeTid);\n  ASSERT(calleeTee);\n\n  let tokenData;\n  if (calleeTee.funcTokenIndex >= 0) {\n    const funcTokenIndex = calleeTee.funcTokenIndex;\n    const fromFilename = calleeTee.fromFilename;\n    const funcToken = store.fileData.get(fromFilename).tokens[funcTokenIndex];\n    ASSERT(funcToken.tlog, 'should be set in phase2', funcToken);\n    tokenData = {\n      wat: isNew ? '#new' : '#call',\n      locFrom,\n      inputArgTids: initialArgCount ? initialCallArgs.slice(0) : [],\n      finalArgTids: undefined,\n      paramTidDesc: calleeTee.builtin ? '<not tracked for builtins>' : calleeTee.paramNames.length ? undefined : '<none>', // map paramBindingNames to their resolved tids at the start of the call\n      contextTid,\n      spreadAt,\n      returnValue: undefined,\n    };\n    funcToken.tlog.push(tokenData);\n  }\n\n  log('Callee tee.type:', calleeTee.type);\n  if (calleeTee.type !== 'F' && calleeTee.type !== 'C') {\n    store.linter.check('CALLED_UNCALLABLE', locFrom);\n    log('Not a callable tee. Ignoring the call. Returning `undefined`');\n\n    if (tokenData) {\n      tokenData.finalArgTids = '<unchecked>';\n      tokenData.returnValue = 'undefined';\n    }\n\n    return 'undefined';\n  }\n\n  // Each builtin handler should deal with arg count themselves\n  // Rest param counts as a param too (just not as min required)\n  const paramCount = calleeTee.builtin ? initialArgCount : calleeTee.paramNames.length;\n\n  function fullDigest(color) {\n    // log('Generating callee digest', tstr(calleeTid))\n    const digestCallee = (isNew ? (color ? BOLD + 'new' + RESET + ' ' : 'new ') : '') + digest(calleeTid, store, color, false, true);\n    // log('Generating args digest', [...initialCallArgs, ...new Array(paramCount).fill('undefined')].slice(0, paramCount).map(tstr).join(', '))\n    const digestArgs = [...initialCallArgs, ...new Array(paramCount).fill('undefined')].slice(0, paramCount).map((tid, i) => digest(tid, store, color, true)).join(', ');\n    // log('Generating context digest', tstr(contextTid))\n    const digestContext = contextTid === 'global' ? (color ? tstr('G') : 'G') : digest(contextTid, store, color, true);\n    // log('Generating super digest', tstr(classTid))\n    const digestSuper = classTid && digest(classTid, store, color, true);\n\n    // This was an attempt at creating a different digest but I think it only made things worse\n    // const digestCallee = (isNew ? (color ? BOLD + 'new' + RESET + ' ' : 'new ') : '') + tidToString(calleeTid, store, true, -1);\n    // // const digestCallee = (isNew ? (color ? BOLD + 'new' + RESET + ' ' : 'new ') : '') + digest(calleeTid, store, color, false, true);\n    //\n    // const digestArgs = [...initialCallArgs, ...new Array(paramCount).fill('undefined')].slice(0, paramCount).map(tid => tidToString(tid, store, true, -1)).join(',');\n    // // const digestArgs = [...initialCallArgs, ...new Array(paramCount).fill('undefined')].slice(0, paramCount).map((tid, i) => digest(tid, store, color, true)).join(', ');\n    //\n    // const digestContext = contextTid === 'global' ? (color ? tstr('G') : 'G') : tidToString(contextTid, store, true, -1);\n    // // const digestContext = contextTid === 'global' ? (color ? tstr('G') : 'G') : digest(contextTid, store, color, true);\n    //\n    // const digestSuper = classTid && tidToString(classTid, store, true, -1);\n    // // const digestSuper = classTid && digest(classTid, store, color, true);\n\n    return `${calleeTee.builtin ? (color ? YELLOW + 'G' + RESET : 'G') : calleeTee.parentClosure.digest(color)}  ${color?DIM:''}###${color?RESET:''}  ${digestCallee} :: [${digestArgs}] :: ${digestContext} :: ${digestSuper}`;\n  }\n\n  const callDigestColor = fullDigest(true);\n  log('Digest:', callDigestColor);\n\n  const callDigest = fullDigest(false);\n\n  const hasRest = calleeTee.hasRest;\n\n  const nettoArgCount = (calleeTee.boundParams ? calleeTee.boundParams.length : 0) + initialArgCount;\n  if (!calleeTee.builtin && (nettoArgCount < calleeTee.minParamRequired) || (!lambdaCallback && !hasRest && nettoArgCount > paramCount)) {\n    // Issue this before cache check because it will digest ignores arg count and makes no difference between `undefined` arg and implicit value\n    store.linter.check('CALL_ARG_ARITY', locFrom);\n  }\n\n  const callCache = store.callCache;\n  if (callCache.has(callDigest)) {\n    const {cachedTid, cachedFence, arrInputs: cachedInputs, mapReversedInputs, deltaMutators, ...rest} = callCache.get(callDigest);\n    const resolvedTee = store.get(cachedTid, true);\n    const resolvedTid = resolvedTee.tid;\n\n    if (resolvedTee.iid > calleeTee.cachedFence) store.linter.check('TOFIX', locFrom, 'I dont know what this means');\n\n    log('Digest cached:', callDigest);\n    log('Result:', tstr(cachedTid), '-->', tstr(resolvedTid));\n    log(WHITE_BLACK + 'Returning cached call result!' + RESET);\n    log('Closure has instance fence at:', cachedFence, ', cached return value has iid:', resolvedTee.builtin ? 'builtin' : resolvedTee.iid, 'so', cachedFence < resolvedTee.iid ? 'AM' : 'NOT', 'cloning the return value');\n    // log('Cached artifacts:');\n    // log('- cachedInputs:', cachedInputs.length > 20 ? '<big>' : cachedInputs);\n    // log('- mapReversedInputs:', mapReversedInputs.size > 20 ? '<big>' : mapReversedInputs);\n    // log('- deltaMutators:', deltaMutators.size > 20 ? '<big>' : deltaMutators);\n\n    ASSERT(JSON.stringify(rest) === '{}');\n\n    const currentInputs = [];\n    [...initialCallArgs, contextTid].forEach(tid => mapInput(store, tid, currentInputs, new Map)); // We don't need the map\n\n    // We need to clone the object, recursively for any object found that was created after the fence\n    // Any object that was created before the fence needs to use the tid of the current call in the same position\n    // That's what we use the arrInputs, mapReversedInputs, and deltaMutators for.\n\n    store.linter.suppress(true); // Should disable linting to prevent duplicate messages due to cloning\n    const returnedTid = fencedCloneTool(cachedFence, resolvedTee.tid, store, new Map, cachedInputs, mapReversedInputs, deltaMutators, currentInputs, 'for call cache');\n    store.linter.suppress(false);\n\n    log('Fenced clone:', tstr(returnedTid));\n\n    if (tokenData) {\n      tokenData.finalArgTids = '<cached>';\n      tokenData.returnValue = returnedTid;\n    }\n\n    return returnedTid;\n  }\n\n  const pid = createPlaceholder(store, 'H', 'return value to represent return value for recursive calls');\n\n  log('Not cached. Placeholder tid for cached call:', tstr(pid));\n  callCache.set(callDigest, {\n    cachedTid: pid,\n    cachedFence: instanceFence,\n    arrInputs: [],\n    mapReversedInputs: new Map,\n    deltaMutators: [],\n  });\n\n  // We should be able to keep the stack as is but we could add guards to prevent stack underflows. That's not\n  // something that could be forced by bugs in user code but only through bugs in our code.\n  const stackSizeBefore = stack.slice(0);\n  log('Stack size before:', stackSizeBefore.length, ', stack:', stack.map(t => tstr(t)).join(', '));\n\n  log('- Owner class:', tstr(classTid), [classTid]);\n  log('- Owner class parent:', classTid ? tstr(store.get(classTid).superClass) : 'not a class');\n  log('- Context:', tstr(contextTid));\n  log('- superPropOwner:', tstr(calleeTee.superPropOwner), calleeTee.tid === '#constructor_with_super' ? '(dynamically resolved by default constructor)' : calleeTee.tid === '#constructor_sans_super' ? '(should not need it)' : ''); // undefined for the autogenerated default constructors\n  log('- funcType:', calleeTee.funcType);\n  log('- loc:', calleeTee.fromFilename + ':' + calleeTee.fromLine + ':' + calleeTee.fromColumn);\n  log('- instanceFence:', instanceFence, ', store iid:', store.instanceId);\n\n  ASSERT_SUPER_PROP_OWNER(calleeTee.superPropOwner);\n\n  // Make the current closure that of the function itself (caller closure is irrelevant for the call)\n  const newClosure = new Map;\n  const closureFilename = calleeTee.fromFilename;\n  const calleeClosure = {\n    class: 'closure',\n    type: 'call',\n    digest(color) {\n      return color ? callDigestColor : callDigest;\n    },\n    get(name) { return newClosure.get(name); },\n    set(name, tid) { return newClosure.set(name, tid); },\n    has(name) { return newClosure.has(name); },\n    str() {\n      const arr = [];\n      newClosure.forEach((tid, key) => arr.push(key + ':' + tstr(tid)));\n      return (calleeTee.parentClosure ? calleeTee.parentClosure.str() + ' >> ' : '') + arr.join(', ');\n    },\n    find(name, locFrom) {\n      ASSERT(typeof name === 'string', 'must find a name', name);\n      ASSERT_LOC(locFrom);\n\n      log('Looking for `' + name + '` in function scope');\n      let closure = calleeClosure;\n      do {\n        log('checking:', closure.type);\n        if (closure.has(name)) return closure.get(name);\n        log('- Not found in ' + closure.type + ' closure, ' + (closure.parentClosure ? 'checking parent ' + closure.parentClosure.type + ' scope...' : 'has no parent scope so this is an error'));\n        closure = closure.parentClosure;\n      } while (closure);\n\n      store.linter.check('USED_BINDING_BEFORE_DECL', locFrom, name);\n      log('Marking `' + name + '` as an implicit global in', closureFilename);\n      store.fileData.get(closureFilename).implicitGlobals.add(name);\n      newClosure.set(name, 'undefined'); // I guess\n      return 'undefined'; // Let it poly out\n    },\n    parentClosure: calleeTee.parentClosure,\n    superPropOwner: calleeTee.superPropOwner,\n    instanceFence, // Any iid higher than this was created after this closure\n    calleeTid,\n    filename: closureFilename,\n  };\n\n  log('- Local scope:', calleeClosure.str());\n\n  if (calleeTee.builtin) {\n    group('Calling a builtin [' + tstr(calleeTee.tid) + ']:');\n    if (calleeTee.boundContext) store.linter.check('TOFIX', locFrom, 'do we need to resolve bound context/params before going into');\n    if (calleeTee.boundParams) store.linter.check('TOFIX', locFrom, 'do we need to resolve bound context/params before going into');\n\n    // Record details of the inputs before going into the builtin. In this case we have to check all the args, as is.\n    const {arrInputs, mapReversedInputs, befores} = scanInputs(store, [...initialCallArgs, contextTid]);\n\n    const updateTo = calleeTee.builtinCode(locFrom, calleeTee, contextTid, initialArgCount, initialCallArgs, spreadAt, stack, store, calleeClosure, isNew, classTid);\n\n    // Now record any changes to the input tids for posterity. And to replay them on cached calls.\n    const deltaMutators = getDeltas(store, instanceFence, arrInputs, befores, mapReversedInputs);\n\n    log('Merging', tstr(updateTo), 'to the call placeholder', tstr(pid), 'after calling a builtin');\n    merge(locFrom, store, updateTo, pid);\n\n    if (updateTo) {\n      group('Making sure the cache gets a fenced clone for', tstr(updateTo), 'in case the instance was generated _inside_ the builtin call');\n      // We need to make sure the cache retains a copy of the object \"as it was returned\", such that later mutations are\n      // not reflected by the copy if it was created during the call. For instances that were created before the call,\n      // those should be shared by reference since they are closures (globals/builtins are closures too, in a way)\n      // If `updateTo` is `undefined` and not a tid then we skip this step... TODO\n\n      let cachedTid = updateTo;\n      if (!isPrimitive(cachedTid)) {\n        store.linter.suppress(true); // Should disable linting to prevent duplicate messages due to cloning\n        cachedTid = fencedCloneToolDebug(instanceFence, updateTo, store, new Map, arrInputs, mapReversedInputs, deltaMutators, arrInputs, true, '<cloning returned value for call cache>');\n        store.linter.suppress(false);\n      }\n\n      log('Updating call cache for', tstr(cachedTid),':');\n      // log('- cachedFence:', instanceFence);\n      // log('- cachedInputs:', arrInputs)\n      // log('- mapReversedInputs:', mapReversedInputs);\n      // log('- deltaMutators:', deltaMutators);\n\n      callCache.set(callDigest, {\n        cachedTid,\n        cachedFence: instanceFence,\n        arrInputs,\n        mapReversedInputs,\n        deltaMutators,\n      });\n\n      groupEnd();\n    }\n\n    if (tokenData) {\n      tokenData.finalArgTids = '<builtin>';\n      tokenData.returnValue = updateTo;\n    }\n\n    groupEnd();\n    return updateTo;\n  }\n\n  if (calleeTee.funcExprName) {\n    log('Initializing the func expr name `' + calleeTee.funcExprName + '` to ', tstr(calleeTid));\n    newClosure.set(calleeTee.funcExprName, calleeTid);\n  }\n\n  ASSERT(typeof calleeTee.thisAccess === 'boolean', 'callables have this');\n  // It's easy and often benign to trigger this lint (member expression) so let's not for now\n  // if (!isNew && !calleeTee.thisAccess && contextTid !== 'undefined' && contextTid !== 'global') {\n  //   store.linter.check('CONTEXT_NO_THIS', locFrom);\n  // }\n  if (calleeTee.thisAccess && contextTid === 'undefined') {\n    store.linter.check('CONTEXT_MISSING', locFrom);\n  }\n  if (!lambdaCallback && calleeTee.funcType === 'arrow' && contextTid !== 'undefined') { // Note: if context is global it must be explicit\n    store.linter.check('ARROW_WITH_CONTEXT', locFrom);\n  }\n\n  const contextTee = store.get(contextTid);\n  ASSERT(contextTee);\n\n  // Get actions for that function\n  const actions = calleeTee.body;\n\n  log('- Param count:', paramCount, ', last rest?', hasRest, ', arg count:', initialArgCount, ', bound arg count:', (calleeTee.boundParams ? calleeTee.boundParams.length : 0), ', min args expected:', calleeTee.minParamRequired);\n  log('- Args: [', initialCallArgs.map(tstr).join(', '), ']', spreadAt < 0 ? ', without spread' : ', with spread at arg' + spreadAt);\n  log('- Bound args:', (calleeTee.boundParams ? calleeTee.boundParams.map(tstr).join(', ') : '<none>'));\n\n  const args = [];\n\n  if (calleeTee.boundParams) {\n    calleeTee.boundParams.forEach(tid => args.push(tid));\n  }\n  initialCallArgs.forEach(tid => args.push(tid));\n  log('Concrete args before pruning ->', args.map(tstr).join(', '));\n  args.forEach(a => ASSERT_TID(a));\n\n  if (spreadAt >= 0) {\n    group('spread arg');\n    ASSERT(spreadAt === args.length - 1, 'the model should only allow to pass through a spread into call args when its the last arg', spreadAt, args);\n    log('Check if the arg position of the spread starts at least _after_ all non-rest params.');\n    log('Spread is at', spreadAt, ', param count:', paramCount, ', is last rest param?', hasRest);\n\n    if (spreadAt < (paramCount - 1)) {\n      store.linter.check('SPREAD_BEFORE_REST', locFrom);\n      // That said, we can sure assume that it worked as it might\n      // Take the spread arg from the list, pad the args to match the param list (also cover the rest param because why not)\n      const spreadArg = args.pop();\n      log('Mapping the array being spread onto any remaining uncovered param, acting as if they were all given a', tstr(spreadArg));\n      while (args.length < paramCount) args.push(spreadArg);\n      log('The new args after extrapolating the spreaded arg:', args.map(tstr).join(', '));\n    }\n\n    groupEnd();\n  }\n\n  log('Final call args before trimming/padding:', args.map(tstr).join(', '));\n\n  if (hasRest) {\n    group('Rest');\n    log('This has a rest');\n    log('- initialArgCount:', initialArgCount);\n    log('- args.length:', args.length);\n    log('- params:', calleeTee.paramNames.length);\n    log('- excess args to merge into rest:', args.slice(calleeTee.paramNames.length - 1));\n\n    if (calleeTee.paramNames.length <= args.length) {\n      // The last param is a rest. Create an array for the rest. Merge any param in excess of the (param count - 1) to\n      // the kind of the rest.\n      let kind = args.pop();\n      ASSERT_TID(kind);\n\n      log('Merging excess args with the rest param');\n      while (args.length >= calleeTee.paramNames.length) {\n        ASSERT_TID(args[args.length - 1]);\n        kind = merge(locFrom, store, kind, args.pop());\n      }\n\n      // Put the rest-kind into the arg position. The restAt parameter will cause the func to interpret that\n      // arg as the rest-kind, so no need to create an array with it here.\n      args.push(kind);\n\n      log('Setting rest param kind to', tstr(kind));\n    }\n    groupEnd();\n  }\n\n  if (paramCount !== args.length) {\n    // Well that's awkward. Either we need to drop args or pad args.\n\n    // todo: de arg filler kijkt naar param count maar moet special casen voor rest param. niet zomaar undefined maar een leeg array\n\n    if (paramCount > args.length) {\n      log('Function actually has', paramCount, 'params and we end up with', args.length, 'args, so padding the rest with `undefined`');\n      // There are more params than args passed on. Pad the remaining params with `undefined`. (TODO: arg defualts?)\n      while (args.length < paramCount) {\n        log('- appending `undefined`');\n        args.push('undefined');\n      }\n      if (hasRest) {\n        // Create an empty array\n        const pid = createPlaceholder(store, 'HRA', 'function rest param without args to cover them');\n        args[args.length - 1] = pid;\n      }\n    } else if (paramCount < args.length) {\n      log('Function only has', paramCount, 'params and we end up with', args.length, 'args, so trimming the excess');\n      // There are fewer params than args passed on. Drop all args that can not be mapped to a param because we\n      // can't inspect them anyways and as such they're irrelevant to the model.\n      while (args.length > paramCount) {\n        args.pop();\n      }\n    } else {\n      ASSERT(false);\n    }\n  } else {\n    log('Number of args was equal to the number of params');\n  }\n\n  log('Final call args:', args.map(tstr).join(', '));\n\n  // Put the normalized arg list back onto the stack (in reverse order!)\n  for (let i=args.length - 1; i>=0; --i) {\n    stack.push(args[i]);\n  }\n\n  if (tokenData) {\n    tokenData.finalArgTids = args.slice(0);\n  }\n\n  // Push context to use for this call. All function bodies should start with a @binding of `this` and setup of `arguments`\n  ASSERT(actions.length, 'should at least setup this/arguments to consume the context on the stack');\n  log('The context of this call is:', tstr(contextTid));\n  stack.push(contextTid);\n\n  const {arrInputs, mapReversedInputs, befores} = scanInputs(store, [...args, contextTid]);\n\n  const indentBefore = getIndent();\n\n  // Replay (recursively)\n  group('Start of ' + actions.length + ' playActions() (stack.length=' + stack.length + ', initialArgCount=' + initialArgCount + ', args.length=' + args.length + ', top of stack is context. Stack: [ ' + stack.map(tstr).join(', ') + ' ])');\n  const returnedTid = playActions(locFrom, store, actions, calleeTee, contextTid, calleeClosure, stack);\n  groupEnd();\n\n  log('Stack size after:', stack.length, ', expecting it to be', stackSizeBefore.length, ', stack: [', stack.map(t => tstr(t)).join(', '), ']');\n  ASSERT(indentBefore === getIndent(), 'group()/groupEnd() indentation changed. fixme');\n\n  // The call should pop for each param it has and once for context\n  ASSERT(stackSizeBefore.length === stack.length, 'should only pop param count and not change the stack otherwise (return value is pushed after this assert)', 'before:', stackSizeBefore, 'after:', stack);\n\n  // TODO: fix this. this will be bad for references, mutations of args, and a whole lot of other things. (same for builtin path)\n  let updateTo = isNew && isPrimitive(returnedTid) ? contextTid : returnedTid;\n\n  // If we return a cached call result then for every tid that existed before the call (instance fence) find its index\n  // and apply the delta to the tid of the current call. If any.\n  const deltaMutators = getDeltas(store, instanceFence, arrInputs, befores, mapReversedInputs);\n\n  if (updateTo === pid) {\n    store.linter.check('INFINITE_RECURSION_MAYBE', locFrom);\n    log('Infinite recursion detected... I think?');\n  } else {\n\n// fixme\n    const arrOutput = [];\n    const mapReversedOutput = new Map;\n    mapInput(store, updateTo, arrOutput, mapReversedOutput);\n\n\n    log('Merging', tstr(updateTo), 'to placeholder', tstr(pid));\n    merge(locFrom, store, updateTo, pid);\n\n    if (updateTo) {\n      // We need to make sure the cache retains a copy of the object \"as it was returned\", such that later mutations are\n      // not reflected by the copy if it was created during the call. For instances that were created before the call,\n      // those should be shared by reference since they are closures (globals/builtins are closures too, in a way)\n      // If `updateTo` is `undefined` and not a tid then we skip this step... TODO\n\n      group('Making sure the cache gets a fenced clone for', tstr(updateTo), 'in case the instance was generated _inside_ the call');\n      store.linter.suppress(true); // Should disable linting to prevent duplicate messages due to cloning\n      const cachedTid = fencedCloneToolDebug(instanceFence, updateTo, store, new Map, arrInputs, mapReversedInputs, deltaMutators, arrInputs, true, '<cloning returned value for call cache>');\n      store.linter.suppress(false);\n\n      log('Updating call cache for', tstr(cachedTid),':');\n      // log('- cachedFence:', instanceFence);\n      // log('- cachedInputs:', arrInputs)\n      // log('- mapReversedInputs:', mapReversedInputs);\n      // log('- deltaMutators:', deltaMutators);\n\n      callCache.set(callDigest, {\n        cachedTid,\n        cachedFence: instanceFence,\n        arrInputs,\n        mapReversedInputs,\n        deltaMutators,\n      });\n      groupEnd();\n    }\n  }\n\n  if (tokenData) {\n    tokenData.returnValue = updateTo;\n  }\n\n  log('Function call returned:', tstr(updateTo));\n\n  return updateTo;\n}\n\nexport function playActionArr(locFrom, store, tid = createArrayTid(store), stack, kind) {\n  // There ought to be elementCount values on the stack to be the kind of this array\n  // Store ought to be global (but I may want to reconsider my choice of putting the uid counter in there...)\n\n  ASSERT_TID(kind);\n  const props = new Map([\n    ['__proto__', 'Array.prototype'],\n  ]);\n  store.set(tid, {\n    _class: 'arr',\n    _clone: '#',\n    tid,\n    type: 'A',\n    kind,\n    iid: ++store.instanceId,\n    props,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map(props),\n    alias: null,\n    locFrom,\n    fencedClone(fence, recur = new Map, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs) {\n      const tid = store.final(this.tid);\n      // if (root) fenceStart(tid, store);\n      group('arr.fencedClone(' + fence + ', ' + debugDesc + ')');\n\n      let ctid = recur.get(tid);\n      if (ctid) {\n        log('This tid is part of a recursive type. Using the fenced clone that was already generated for this tid:', tstr(ctid));\n      } else {\n        // Pre-generate the array tid to create so we can put it in the recur cache. Prevents `a=[]; a[0]=a` problems\n        ctid = createArrayTid(store);\n        recur.set(tid, ctid);\n\n        const kind = store.final(this.kind);\n        if (kind !== this.kind) log('The kind of', tstr(tid), 'is', tstr(this.kind),', which is aliased to', tstr(kind));\n        const clonedKind = fencedCloneTool(fence, kind, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, 'fetch kind');\n\n        playActionArr(locFrom, store, ctid, stack, clonedKind);\n\n        log('Clone1 the props into the cloned array');\n        const ctee = store.get(ctid);\n        ctee.props = new Map([...this.props.entries()].map(([key, value]) => [key, fencedCloneTool(fence, value, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc)]));\n      }\n\n      log('</arr.fencedClone>');\n      groupEnd();\n      return ctid;\n    },\n  });\n\n  return tid;\n}\n\nfunction playActionBinding(locFrom, store, stack, closure, name, kind, tid) {\n  log('- Set `' + name + '` to', tstr(tid), 'of type', kind);\n\n  const fileState = store.fileData.get(locFrom.filename);\n\n  const tokenIdent = getFirstToken(store, locFrom);\n  let tokenOp = fileState.tokens[tokenIdent.n + 1];\n\n  while (tokenOp && (Tenko.isWhiteToken(tokenOp.type))) tokenOp = fileState.tokens[tokenOp.n + 1];\n\n  const report = {wat: '#init', tid, name};\n  pushTlog(tokenIdent, report);\n  if (tokenOp.str === '=') pushTlog(tokenOp, report);\n\n  if (kind === 'var' && closure.has(name)) {\n    const mtid = merge(locFrom, store, tid, closure.get(name));\n    closure.set(name, mtid);\n  } else {\n    /*\n      // Happens at least for this case\n      function shadowedFunction(){\n        let shadowedFunction = 1;\n        shadowedFunction === 'str'; // fail\n      }\n      shadowedFunction();\n     */\n    ASSERT(!closure.has(name) || fileState.implicitGlobals.has(name), 'either the binding already didnt exist or its lex and it shouldnt exist yet or it was already reported as an implicit global', name, kind, closure, fileState.implicitGlobals, fileState.filename, closure.filename);\n    closure.set(name, tid);\n  }\n}\n\nexport function playActionClass(locFrom, store, tid = createClassTid(store), stack, nid, className, staticMethods, closure, userDesc, prototypeTid, superClassTid) {\n  // Top of stack should be prototype object, then super class, then in source code order (static and instance mixed) the methods\n\n  log('The class prototype tid:', tstr(prototypeTid));\n  const prototypeTee = store.get(prototypeTid);\n\n  log('This class extends:', tstr(superClassTid), typeof superClassTid === 'string' ? '' : '(-> ' + tstr('Function.prototype') + ')');\n  ASSERT_TID(superClassTid, NO_SUPER_VALUE);\n  const superClassTee = superClassTid === NO_SUPER_VALUE ? null : store.get(superClassTid);\n\n  ASSERT(!superClassTee || (!prototypeTee.builtin && !prototypeTee.prototypeOf), 'i think, or fixme', prototypeTee);\n  prototypeTee.prototypeOf = tid;\n\n  if (superClassTid !== NO_SUPER_VALUE) {\n    // At definition time the super class must be a constructor with a .prototype property that exists with an object\n    if (superClassTid === 'null') {\n      store.linter.check('EXTENDS_NULL', locFrom);\n    } else if (isPrimitive(superClassTee)) {\n      // This is a runtime error but my model doesn't care much\n      store.linter.check('EXTENDS_PRIMITIVE', locFrom);\n    } else {\n      const prototypeTid = superClassTee.props.get('prototype');\n      if (prototypeTid === undefined) {\n        store.linter.check('EXTENDS_NO_PROTO', locFrom);\n      } else if (prototypeTid !== null && prototypeTid !== 'null') { // null is okay here! Object has null, for example. You can extend Object. You do.\n        if (isPrimitive(prototypeTid)) {\n          store.linter.check('EXTENDS_BAD_PROTO', locFrom);\n        }\n      }\n    }\n  }\n\n  // If this class extends then set __proto__ to its .prototype. If it does not extend, set it to Object.prototype\n  const protoTid = superClassTid !== NO_SUPER_VALUE && superClassTee.props ? superClassTee.props.get('prototype') : 'Object.prototype';\n  if (protoTid === undefined) {\n    log('Not setting a `prototype.__proto__` property because there was no prototype at all');\n  } else {\n    log('Setting the .prototype.__proto__ (on ' + tstr(prototypeTid) + ') of the class to:', tstr(protoTid));\n    // ASSERT(prototypeTee.props.get('__proto__') === 'Object.prototype' || prototypeTee.props.get('__proto__') === protoTid, 'keeps default value, or in case of a clone, already set to target value', prototypeTee.props.get('__proto__'));\n    prototypeTee.setProp('__proto__', protoTid);\n  }\n\n  log('Static method entries:', staticMethods);\n\n  const props = new Map([\n    ['prototype', prototypeTid],\n    ['__proto__', superClassTid === NO_SUPER_VALUE ? 'Function.prototype' : superClassTid],\n    ...staticMethods,\n  ]);\n\n  store.set(tid, {\n    _class: 'funco',\n    _type: 'class',\n    _name: className,\n    _clone: '#',\n    tid,\n    type: 'C',\n    iid: ++store.instanceId,\n    paramNames: [], // not used\n    minParamRequired: -1,\n    body: [], // not used\n    funcType: 'class',\n    ownerClass: tid, // Used for bound class to be able to resolve the original class\n    superClass: superClassTid,\n    funcExprName: '', // not used\n    thisAccess: false, // not used\n    superPropOwner: SUPER_PROP_OWNER_NOT_FOR_CLASS,\n    parentClosure: closure, // not used\n    props,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map(props),\n    alias: null,\n    userDesc, // For reporting to the user what kind of value this is (\"the class named A starting at x,y\")\n    locFrom,\n    fencedClone(fence, recur = new Map, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs) {\n      const tid = store.final(this.tid);\n      // if (root) fenceStart(tid, store);\n      group('class.fencedClone(' + fence + ', ' + debugDesc + ')');\n\n      let ctid = recur.get(tid);\n      if (ctid) {\n        log('This tid is part of a recursive type. Using the fenced clone that was already generated for this tid:', tstr(ctid));\n      } else {\n        // Pre-generate the array tid to create so we can put it in the recur cache. Prevents `a=[]; a[0]=a` problems\n        ctid = createClassTid(store);\n        recur.set(tid, ctid);\n\n        const superClassTidClone = superClassTid === NO_SUPER_VALUE ? NO_SUPER_VALUE : fencedCloneTool(fence, superClassTid, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, 'superClass(' + debugDesc + ')');\n        const prototypeTidClone = fencedCloneTool(fence, prototypeTid, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, 'prototype(' + debugDesc + ')');\n\n        playActionClass(locFrom, store, ctid, stack, nid, className, [], closure, this.userDesc, prototypeTidClone, superClassTidClone);\n\n        // The concept of a class, initially, does not change (I hope...). So we only need to clone the props.\n        const ctee = store.get(ctid);\n        ASSERT(ctee, 'should have a class tee now?', ctid, ctee);\n        log('Clone2 the props into the cloned function');\n        ctee.props = new Map([...this.props.entries()].map(([key, value]) => [key, fencedCloneTool(fence, value, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc)]));\n      }\n\n      log('</class.fencedClone>');\n      groupEnd();\n      return ctid;\n    },\n  });\n\n  log('->', tstr(tid));\n  return tid;\n}\n\nexport function playActionFunc(locFrom, {\n  store,\n  tid = createFuncoTid(store),\n  stack,\n  closure,\n  callerContext,\n  nid,\n  funcName,\n  paramNames,\n  paramBindingNames,\n  hasRest,\n  minParamRequired,\n  body,\n  funcType,\n  thisAccess,\n  reachableNames,\n  ownerClass,\n  superClass = NO_SUPER_VALUE,\n  boundContext,\n  boundParams,\n  funcTokenIndex = -1,\n  fromFilename,\n  fromColumn,\n  fromLine,\n  userDesc,\n  useProps = false,\n  ...rest\n}) {\n  // Note: this function assumes an superOwner was pushed onto the superStack before this calle (!)\n  ASSERT(['decl', 'expr', 'method', 'decl-bound', 'expr-bound', 'method-bound', 'class-bound', 'arrow'].includes(funcType), 'funcType is an enum', funcType);\n  ASSERT(JSON.stringify(rest) === '{}', 'should not receive additional args', rest);\n\n  log(\n    'playActionFunc(locFrom, {store, tid:', tstr(tid),', stack, closure, callerContext:',tstr(callerContext),', nid:', [nid], ', funcName: ', [funcName],\n    ', paramNames: [', paramNames.join(', '), '], paramBindingNames: [', paramBindingNames.join(', '), '], hasRest: ', hasRest, ', minParamRequired:', minParamRequired,\n    ', body, funcType:', funcType, ', thisAccess:', thisAccess, ', ownerClass:', tstr(ownerClass),\n    ', funcTokenIndex:', funcTokenIndex, ', fromFilename:', fromFilename, ', userDesc)'\n  );\n\n  if (ownerClass === undefined) {\n    // new (f.bind())() should still create a new instance of this function, even though a bound function has no prototype\n    ownerClass = tid;\n  }\n\n  let superPropOwner = SUPER_PROP_OWNER_NOT_A_METHOD;\n  if (funcType.startsWith('method')) {\n    ASSERT(store.superStack.length > 0, 'the owner parent class of the method should be pushed onto the stack before this call');\n    superPropOwner = store.superStack[store.superStack.length - 1];\n  }\n\n  let props;\n  if (useProps) {\n    group('Using props that were passed on');\n    props = useProps;\n  } else {\n    group('Creating the fresh prototype object to use with this function instance');\n\n    // Note: column+1 to make the locFrom different than the funco for digest recursion checks... I may come to regret this\n    const protoTid = playActionObj({filename: fromFilename, column: fromColumn + 1, line: fromLine}, store, undefined, stack, [], [])\n\n    props = new Map([\n      ['prototype', protoTid],\n      ['__proto__', 'Function.prototype'],\n    ]);\n  }\n\n  groupEnd();\n\n  log('- prototype:', tstr(props.get('prototype')));\n  log('- __proto__:', tstr(props.get('__proto__')));\n  log('- superPropOwner:', tstr(superPropOwner));\n\n  ASSERT_SUPER_PROP_OWNER(superPropOwner);\n  const tee = {\n    _class: 'funco',\n    _type: '@',\n    _clone: '#',\n    tid,\n    type: 'F',\n    iid: ++store.instanceId,\n    nid, // uniquely describes this function body (for digest)\n    paramNames, // Only names of ident params, ignores patterns, are not \"unique\" in case that matters\n    paramBindingNames, // All names bound through params, includes both patterns and idents, should be \"unique\"\n    hasRest,\n    minParamRequired,\n    boundContext, // May be undefined\n    boundParams, // May be undefined\n    body,\n    funcType,\n    ownerClass,\n    superClass,\n    funcExprName: funcType === 'expr' || funcType.startsWith('method') ? funcName : '',\n    thisAccess,\n    reachableNames, // All binding names reachable from this function, excluding underlying shadows/this/arguments. Used for digest.\n    superPropOwner,\n    parentClosure: closure,\n    props,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map(props),\n    alias: null,\n    userDesc,\n    funcTokenIndex,\n    fromFilename,\n    fromColumn,\n    fromLine,\n    locFrom: {filename: fromFilename, column: fromColumn, line: fromLine},\n    fencedClone(fence, recur = new Map, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs) {\n      const tid = store.final(this.tid);\n      // if (root) fenceStart(tid, store);\n      group('func.fencedClone(' + fence + ', ' + debugDesc + ')');\n\n      ASSERT_SUPER_PROP_OWNER(superPropOwner);\n\n      // We don't need to clone the actual function stuff. That's immutable (I hope...). But we do need to clone the props on the func.\n\n      let ctid = recur.get();\n      if (recur.has(tid)) {\n        log('This tid is part of a recursive type. Using the fenced clone that was already generated for this tid:', tstr(ctid));\n      } else {\n        // Pre-generate the array tid to create so we can put it in the recur cache. Prevents `a=[]; a[0]=a` problems\n        ctid = createFuncoTid(store);\n        recur.set(tid, ctid);\n\n        if (funcType.startsWith('method')) {\n          store.superStack.push(superPropOwner);\n        }\n        playActionFunc(locFrom, {\n          store,\n          tid: ctid,\n          stack,\n          closure,\n          callerContext,\n          nid,\n          funcName,\n          paramNames,\n          paramBindingNames,\n          hasRest,\n          minParamRequired,\n          body,\n          funcType,\n          thisAccess,\n          reachableNames,\n          ownerClass,\n          superClass,\n          boundContext,\n          boundParams,\n          funcTokenIndex,\n          fromColumn,\n          fromLine,\n          fromFilename,\n          userDesc,\n        });\n        if (funcType.startsWith('method')) {\n          store.superStack.pop();\n        }\n\n        log('Clone3 the props into the cloned function');\n        const ctee = store.get(ctid);\n        ctee.props = new Map([...this.props.entries()].map(([key, value]) => [key, fencedCloneTool(fence, value, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc)]));\n      }\n\n      log('</func.fencedClone>');\n      groupEnd();\n      return ctid;\n    },\n  };\n\n  store.set(tid, tee);\n  log('->', tstr(tid));\n  return tid;\n}\n\nexport function playActionKind(locFrom, store, stack, arrTid) {\n  ASSERT(arrTid, 'should be something on the stack');\n  const tee = store.get(arrTid);\n  ASSERT(tee, 'should lead to a tee');\n\n  let kind = 'undefined';\n  if (tee.type === 'A') {\n    ASSERT_TID(tee.kind);\n    const kindTee = store.get(tee.kind);\n    if (kindTee.type === 'H') {\n      // What if the read is from a spread? In that case we don't care about this ...\n      store.linter.check('ARRAY_KIND_READ_BUT_UNDET', locFrom);\n      log('Setting the kind of this array to', tstr('undefined'), 'because it was undetermined while being queried');\n      store.linkTo(kindTee, store.get('undefined'));\n      tee.kind = 'undefined';\n    } else {\n      kind = tee.kind;\n    }\n  } else {\n    store.linter.check('ARRAY_KIND', locFrom);\n  }\n  log('Array:', tstr(arrTid), '--> kind:', tstr(kind));\n\n  return kind;\n}\n\nexport function playActionMap(locFrom, store, tid = createMapTid(store), stack, keyKind, valueKind) {\n  // There ought to be 2 values on the stack to be the kind of this map; top is value kind, second is key kind\n  // Store ought to be global (but I may want to reconsider my choice of putting the uid counter in there...)\n\n  log('Creating Map instance with key kind =', tstr(keyKind), ' and value kind =', tstr(valueKind), 'as', tstr(tid));\n  ASSERT_TID(keyKind);\n  ASSERT_TID(valueKind);\n  const props = new Map([\n    ['__proto__', 'Map.prototype'],\n  ]);\n  store.set(tid, {\n    _class: 'map',\n    _clone: '#',\n    tid,\n    type: 'M',\n    keyKind,\n    kind: valueKind, // When looking up the kind of an iterable, maps return their value kind, so make the `kind` key that of value\n    iid: ++store.instanceId,\n    props,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map(props),\n    alias: null,\n    locFrom,\n    fencedClone(fence, recur = new Map, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs) {\n      const tid = store.final(this.tid);\n      // if (root) fenceStart(tid, store);\n      group('map.fencedClone(' + fence + ', ' + debugDesc + ')');\n\n      let ctid = recur.get(tid);\n      if (ctid) {\n        log('This tid is part of a recursive type. Using the fenced clone that was already generated for this tid:', tstr(ctid));\n      } else {\n        // Pre-generate the array tid to create so we can put it in the recur cache. Prevents `a=[]; a[0]=a` problems\n        ctid = createMapTid(store);\n        recur.set(tid, ctid);\n\n        const keyArg = fencedCloneTool(fence, keyKind, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, 'kind');\n        const valueArg = fencedCloneTool(fence, valueKind, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, 'kind');\n\n        playActionMap(locFrom, store, ctid, stack, keyArg, valueArg);\n\n        log('Clone6 the props into the cloned array');\n        const ctee = store.get(ctid);\n        ctee.props = new Map([...this.props.entries()].map(([key, value]) => [key, fencedCloneTool(fence, value, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc)]));\n      }\n\n      log('</map.fencedClone>');\n      groupEnd();\n      return ctid;\n    },\n  });\n\n  return tid;\n}\n\nexport function playActionNew(locFrom, store, stack, spreadAt, wrapperClassTid, argTids) {\n  // Top of stack ought to be the function to be called, followed by the args in order\n\n  // A `new` is similar to a call except it has special rules for context and the return value\n  // In addition, certain things can only be `new`ed, only be `call`ed, and some can be both.\n\n  // Args are same as for regular function (arg+default pairs)\n\n  log('Stack at start of @new:', stack.map(tstr).join(', '));\n\n  // The context is created before the call so we need to log the instance fence here\n  const instanceFence = store.instanceId;\n\n  log('Stack has this wrapper tid to `new` on:', tstr(wrapperClassTid));\n  const wrapperClassTee = store.get(wrapperClassTid);\n  log('Type of callee:', BOLD + wrapperClassTee.funcType + RESET, ', owner class:', tstr(wrapperClassTee.ownerClass));\n\n  // Unwrap the class in case it was bound (pretty much a noop otherwise, but good to be consistent)\n  // This principle holds for es5 and es6 class behavior\n  const classTid = wrapperClassTee.ownerClass === undefined ? wrapperClassTee.tid : wrapperClassTee.ownerClass; // used for .bind on classes\n  log('owner class (to use in case of .bind):', tstr(classTid));\n  const classTee = store.get(classTid);\n\n  if (!classTee || !classTee.props) {\n    // Not a class, not even callable, consider this a noop, return undefined\n    store.linter.check('NEW_NOT_CONSTRUCTOR', locFrom);\n    return 'undefined';\n  }\n\n  if (classTee.funcType && classTee.funcType.startsWith('class-bind')) store.linter.check('TOFIX', locFrom, '??');\n  if (classTee.funcType && classTee.funcType.startsWith('arrow')) store.linter.check('TOFIX', locFrom, '??');\n  if (classTee.funcType && !classTee.funcType.startsWith('decl') && !classTee.funcType.startsWith('expr') && !classTee.funcType.startsWith('method') && !classTee.funcType.startsWith('class') && !classTee.funcType.startsWith('func-builtin')) store.linter.check('TOFIX', locFrom, '??');\n\n  if (classTee.boundContext && classTee.funcType !== 'class-bound') {\n    // Technically this could be a runtime error. But I don't care for our model as long as the rest holds...\n    store.linter.check('FUNCTION_BIND_NEW', locFrom);\n  }\n\n  // The context is a fresh object whose __proto__ points to the invoked class'es .prototype\n  // There are two paths here; es5 and es6 classes\n\n  group('Creating the fresh object instance to be the context of this `new` call');\n  const instanceTid = playActionObj(locFrom, store, undefined, stack, ['__proto__'], [classTee.props.get('prototype') || 'Object.prototype']);\n  groupEnd();\n\n  let constructTid = classTid;\n  if (classTee.funcType.startsWith('class')) { // can be class, can be a .bind() result on a class\n    log('This is a class, must resolve the constructor from owner class:', tstr(classTid));\n    const prototypeTid = classTee.props.get('prototype');\n    log('- .prototype:', tstr(prototypeTid));\n    ASSERT(prototypeTid, 'the prototype of a constructor can not be cleared', prototypeTid);\n    const prototypeTee = store.get(prototypeTid);\n    const constructorTid = prototypeTee.props.get('constructor');\n    ASSERT(constructorTid, 'the constructor on an es6 class must always exist, explicitly or implicitly', constructorTid);\n    log('- .prototype.constructor:', tstr(constructTid));\n\n    constructTid = constructorTid;\n  }\n\n  log('Did this call have a spread? spreadAt =', spreadAt);\n\n  group('invoking now');\n  let returnTid = metaCall(locFrom, constructTid, instanceTid, true, stack, argTids.length, argTids, spreadAt, store, classTid, instanceFence, false);\n  groupEnd();\n\n  if (['undefined', 'null', 'boolean', 'number', 'string'].includes(returnTid)) {\n    log('The `new` call returned a primitive (', tstr(returnTid), '). Force returning the object instance instead:', tstr(instanceTid));\n    returnTid = instanceTid;\n  }\n\n  log('Stack at end of @new:', stack.map(tstr).join(', '));\n  return returnTid;\n}\n\nexport function playActionObj(locFrom, store, tid = createObjectTid(store), _stack, propNames, propTids) {\n  // There ought to be as many values on the stack as there are properties with initializers\n  // Create a tee with these properties\n\n  ASSERT(propNames instanceof Array, 'prop names should be array', propNames);\n\n  const props = new Map\n  propNames.forEach((name, i) => {\n    props.set(name, propTids[i]);\n  });\n  if (!props.has('__proto__')) {\n    props.set('__proto__', 'Object.prototype');\n  }\n\n  //The `kind` state gives us an outside chance of supporting dynamic properties when used as a Map. Set it to `false`\n  // once there are at least two properties with different tids. Since we will always issue a model-breaking warning\n  // I think it's fine to ignore `undefined` here, as well as the value of `__proto__`.\n  let lastKind = '';\n  props.forEach((tid, name) => {\n    if (name === '__proto__') return; // ignore\n    if (tid === 'undefined') return; // ignore\n    if (lastKind === '') lastKind = tid;\n    if (lastKind !== tid) lastKind = false;\n  });\n  const kind = lastKind === '' ? createPlaceholder(store, 'HOK', 'object kind') : lastKind;\n\n  store.set(tid, {\n    _class: 'obj',\n    tid,\n    type: 'O',\n    iid: ++store.instanceId,\n    props,\n    setProp(name, tid) {\n      // Note: this.props may not be props so do not assume this\n\n      log('props.set(', name, ',', tstr(tid), ')');\n      this.props.set(name, tid);\n      ASSERT(this.kind === false || ASSERT_TID(this.kind), 'object kind is special cased', this.kind);\n      group('Updating object kind');\n      if (name !== '__proto__' && tid !== 'undefined' && this.kind !== false && testMerge(store, this.kind, tid)) {\n        this.kind = merge(locFrom, store, this.kind, tid);\n      } else {\n        log('The object can no longer be used as a hashmap. Dynamic property access will now return `undefined` and a lint error.');\n        this.kind = false;\n      }\n      groupEnd();\n      log('setProp returning', tstr(tid), 'and the prop is now recorded as', tstr(this.props.get(name)));\n      return tid;\n    },\n    seen: new Map(props),\n    kind, // tid or false\n    alias: null,\n    locFrom, // Used to detect recursive objects created through recursive functions\n    fencedClone(fence, recur = new Map, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs) {\n      const tid = store.final(this.tid);\n      group('obj.fencedClone(' + fence + ', ' + debugDesc + ') on', tstr(tid), recur.size < 5 ? ', recur=' : (', recur has ' + recur.size + ' items'), recur.size < 5 ? recur : '');\n\n      let ctid = recur.get(tid);\n      if (ctid) {\n        log('This tid is part of a recursive type. Using the fenced clone that was already generated for this tid:', tstr(ctid));\n      } else {\n        // Pre-generate the array tid to create so we can put it in the recur cache. Prevents `a=[]; a[0]=a` problems\n        ctid = createObjectTid(store);\n        recur.set(tid, ctid);\n\n        // Create fresh object without props through normal path, then replace the props with the clones\n        playActionObj(locFrom, store, ctid, _stack, [], []);\n\n        log('Clone4 the props into the cloned object');\n        const ctee = store.get(ctid);\n        ctee.kind = this.kind === false ? false : fencedCloneTool(fence, this.kind, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc);\n        ctee.props = new Map([...this.props.entries()].map(([key, value]) => [key, fencedCloneTool(fence, value, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc)]));\n      }\n\n      log('</obj.fencedClone>');\n      groupEnd();\n      return ctid;\n    },\n  });\n\n  log('->', tstr(tid), ', iid:', store.instanceId);\n  return tid;\n}\n\nexport function playActionSet(locFrom = {filename: '<builtin>', column: 0, line: 0}, store, tid = createSetTid(store), stack, kind) {\n  // There ought to be 1 value on the stack to be the kind of this set\n  // Store ought to be global (but I may want to reconsider my choice of putting the uid counter in there...)\n\n  log('Creating Set instance with kind =', tstr(kind), 'as', tstr(tid));\n  ASSERT_TID(kind);\n\n  const props = new Map([\n    ['__proto__', 'Set.prototype'],\n  ]);\n  store.set(tid, {\n    _class: 'set',\n    _clone: '#',\n    tid,\n    type: 'S',\n    kind,\n    iid: ++store.instanceId,\n    props,\n    setProp(name, tid) { this.props.set(name, tid); return tid; },\n    seen: new Map(props),\n    alias: null,\n    locFrom,\n    fencedClone(fence, recur = new Map, debugDesc, arrInputs, mapReversedInputs, deltaMutators, currentInputs) {\n      const tid = store.final(this.tid);\n      group('set.fencedClone(' + fence + ', ' + debugDesc + ')');\n\n      let ctid = recur.get(tid);\n      if (ctid) {\n        log('This tid is part of a recursive type. Using the fenced clone that was already generated for this tid:', tstr(ctid));\n      } else {\n        // Pre-generate the array tid to create so we can put it in the recur cache. Prevents `a=[]; a[0]=a` problems\n        ctid = createSetTid(store);\n        recur.set(tid, ctid);\n\n        const kindClone = fencedCloneTool(fence, kind, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, 'kind');\n\n        playActionSet(locFrom, store, ctid, stack, kindClone);\n\n        log('Clone5 the props into the cloned array');\n        const ctee = store.get(ctid);\n        ctee.props = new Map([...this.props.entries()].map(([key, value]) => [key, fencedCloneTool(fence, value, store, recur, arrInputs, mapReversedInputs, deltaMutators, currentInputs, debugDesc)]));\n      }\n\n      log('</set.fencedClone>');\n      groupEnd();\n      return ctid;\n    },\n  });\n\n  return tid;\n}\n\nfunction locToToken(store, {filename, column, line}) {\n  const token = store.fileData.get(filename).tokenTable.get(column + 'x' + line);\n  ASSERT(token, 'all known locs should have a token');\n  return token;\n}\n\nfunction getFirstToken(store, loc) {\n  return store.fileData.get(loc.filename).tokenTable.get(loc.column + 'x' + loc.line);\n}\n","~/proj/zetype/node_modules/tenko/build/tenko.prod.mjs":"\n\n\n\n// <perf>\nlet IGNORE = {};\n// </perf>\n\n// <charcodes>\n\n// </charcodes>\n\n// <utils>\nfunction inspect(...args) {\nconsole.dir(((args.length === 1)? args[0] : args), {depth:null});\n}\nfunction THROW(str, ...rest) {\nthrow new Error(`Parser error! ${str} ${(rest.length? rest : '')}`);\n}\n// </utils>\n\n// <tokentype>\nlet __$flag_leaf = 0;\nlet __$flag_group = 7;\nlet ALL_GEES;\nlet KEYWORD_TRIE_OBJLIT = {0:{17:{6:{20:{12:{4:{13:{19:{18:{hit:2072, canon:'arguments'}}}}}}}}, 18:{24:{13:{2:{hit:2074, canon:'async'}}}, hit:2073, canon:'as'}, 22:{0:{8:{19:{hit:2075, canon:'await'}}}}}, 1:{17:{4:{0:{10:{hit:2076, canon:'break'}}}}}, 2:{0:{18:{4:{hit:2077, canon:'case'}}, 19:{2:{7:{hit:2078, canon:'catch'}}}}, 11:{0:{18:{18:{hit:2079, canon:'class'}}}}, 14:{13:{18:{19:{hit:2080, canon:'const'}}, 19:{8:{13:{20:{4:{hit:2081, canon:'continue'}}}}}}}}, 3:{4:{1:{20:{6:{6:{4:{17:{hit:2082, canon:'debugger'}}}}}}, 5:{0:{20:{11:{19:{hit:2083, canon:'default'}}}}}, 11:{4:{19:{4:{hit:2084, canon:'delete'}}}}}, 14:{hit:2085, canon:'do'}}, 4:{11:{18:{4:{hit:2086, canon:'else'}}}, 13:{20:{12:{hit:2087, canon:'enum'}}}, 21:{0:{11:{hit:2088, canon:'eval'}}}, 23:{15:{14:{17:{19:{hit:2089, canon:'export'}}}}, 19:{4:{13:{3:{18:{hit:2090, canon:'extends'}}}}}}}, 5:{0:{11:{18:{4:{hit:2091, canon:'false'}}}}, 8:{13:{0:{11:{11:{24:{hit:2092, canon:'finally'}}}}}}, 14:{17:{hit:2093, canon:'for'}}, 17:{14:{12:{hit:2094, canon:'from'}}}, 20:{13:{2:{19:{8:{14:{13:{hit:2095, canon:'function'}}}}}}}}, 6:{4:{19:{hit:2096, canon:'get'}}}, 8:{5:{hit:2097, canon:'if'}, 12:{15:{11:{4:{12:{4:{13:{19:{18:{hit:2098, canon:'implements'}}}}}}}, 14:{17:{19:{hit:2099, canon:'import'}}}}}, 13:{18:{19:{0:{13:{2:{4:{14:{5:{hit:67637, canon:'instanceof'}}}}}}}}, 19:{4:{17:{5:{0:{2:{4:{hit:2102, canon:'interface'}}}}}}}, hit:67636, canon:'in'}}, 11:{4:{19:{hit:2103, canon:'let'}}}, 13:{4:{22:{hit:2104, canon:'new'}}, 20:{11:{11:{hit:2105, canon:'null'}}}}, 14:{5:{hit:2106, canon:'of'}}, 15:{0:{2:{10:{0:{6:{4:{hit:2107, canon:'package'}}}}}}, 17:{8:{21:{0:{19:{4:{hit:2108, canon:'private'}}}}}, 14:{19:{4:{2:{19:{4:{3:{hit:2109, canon:'protected'}}}}}}}}, 20:{1:{11:{8:{2:{hit:2110, canon:'public'}}}}}}, 17:{4:{19:{20:{17:{13:{hit:2111, canon:'return'}}}}}}, 18:{4:{19:{hit:2112, canon:'set'}}, 19:{0:{19:{8:{2:{hit:2113, canon:'static'}}}}}, 20:{15:{4:{17:{hit:2114, canon:'super'}}}}, 22:{8:{19:{2:{7:{hit:2115, canon:'switch'}}}}}}, 19:{0:{17:{6:{4:{19:{hit:2116, canon:'target'}}}}}, 7:{8:{18:{hit:2117, canon:'this'}}, 17:{14:{22:{hit:2118, canon:'throw'}}}}, 17:{20:{4:{hit:2119, canon:'true'}}, 24:{hit:2120, canon:'try'}}, 24:{15:{4:{14:{5:{hit:2121, canon:'typeof'}}}}}}, 21:{0:{17:{hit:2122, canon:'var'}}, 14:{8:{3:{hit:2123, canon:'void'}}}}, 22:{7:{8:{11:{4:{hit:2124, canon:'while'}}}}, 8:{19:{7:{hit:2125, canon:'with'}}}}, 24:{8:{4:{11:{3:{hit:2126, canon:'yield'}}}}}};\nfunction isWhiteToken(type) {\nreturn (type & 256) === 256;\n}\nfunction isNewlineToken(type) {\nreturn (type & 512) === 512;\n}\nfunction isCommentToken(type) {\nreturn (type & 1024) === 1024;\n}\nfunction isIdentToken(type) {\nreturn (type & 2048) === 2048;\n}\nfunction isNumberToken(type) {\nreturn (type & 4096) === 4096;\n}\nfunction isBigintToken(type) {\nreturn (type & 8192) === 8192;\n}\nfunction isStringToken(type) {\nreturn (type & 131072) === 131072;\n}\nfunction isPunctuatorToken(type) {\nreturn (type & 16384) === 16384;\n}\nfunction isRegexToken(type) {\nreturn (type & 262144) === 262144;\n}\nfunction isTickToken(type) {\nreturn (type & 524288) === 524288;\n}\nfunction isBadTickToken(type) {\nreturn (type & 1048576) === 1048576;\n}\nfunction isNumberStringToken(type) {\nreturn (type & 135168) !== 0;\n}\nfunction isNumberStringRegex(type) {\nreturn (type & 397312) !== 0;\n}\nfunction toktypeToString(type) {\nswitch ((((typeof type) === 'object')? type.type : type)) {\ncase 0:\nreturn 'UNTYPED';\ncase 257:\nreturn 'SPACE';\ncase 258:\nreturn 'TAB';\ncase 771:\nreturn 'NL_SOLO';\ncase 772:\nreturn 'NL_CRLF';\ncase 1285:\nreturn 'COMMENT_SINGLE';\ncase 1286:\nreturn 'COMMENT_MULTI';\ncase 1287:\nreturn 'COMMENT_HTML';\ncase 2048:\nreturn 'IDENT';\ncase 2072:\nreturn 'ID_arguments';\ncase 2073:\nreturn 'ID_as';\ncase 2074:\nreturn 'ID_async';\ncase 2075:\nreturn 'ID_await';\ncase 2076:\nreturn 'ID_break';\ncase 2077:\nreturn 'ID_case';\ncase 2078:\nreturn 'ID_catch';\ncase 2079:\nreturn 'ID_class';\ncase 2080:\nreturn 'ID_const';\ncase 2081:\nreturn 'ID_continue';\ncase 2082:\nreturn 'ID_debugger';\ncase 2083:\nreturn 'ID_default';\ncase 2084:\nreturn 'ID_delete';\ncase 2085:\nreturn 'ID_do';\ncase 2086:\nreturn 'ID_else';\ncase 2087:\nreturn 'ID_enum';\ncase 2088:\nreturn 'ID_eval';\ncase 2089:\nreturn 'ID_export';\ncase 2090:\nreturn 'ID_extends';\ncase 2091:\nreturn 'ID_false';\ncase 2092:\nreturn 'ID_finally';\ncase 2093:\nreturn 'ID_for';\ncase 2094:\nreturn 'ID_from';\ncase 2095:\nreturn 'ID_function';\ncase 2096:\nreturn 'ID_get';\ncase 2097:\nreturn 'ID_if';\ncase 2098:\nreturn 'ID_implements';\ncase 2099:\nreturn 'ID_import';\ncase 67636:\nreturn 'ID_in';\ncase 67637:\nreturn 'ID_instanceof';\ncase 2102:\nreturn 'ID_interface';\ncase 2103:\nreturn 'ID_let';\ncase 2104:\nreturn 'ID_new';\ncase 2105:\nreturn 'ID_null';\ncase 2106:\nreturn 'ID_of';\ncase 2107:\nreturn 'ID_package';\ncase 2108:\nreturn 'ID_private';\ncase 2109:\nreturn 'ID_protected';\ncase 2110:\nreturn 'ID_public';\ncase 2111:\nreturn 'ID_return';\ncase 2112:\nreturn 'ID_set';\ncase 2113:\nreturn 'ID_static';\ncase 2114:\nreturn 'ID_super';\ncase 2115:\nreturn 'ID_switch';\ncase 2116:\nreturn 'ID_target';\ncase 2117:\nreturn 'ID_this';\ncase 2118:\nreturn 'ID_throw';\ncase 2119:\nreturn 'ID_true';\ncase 2120:\nreturn 'ID_try';\ncase 2121:\nreturn 'ID_typeof';\ncase 2122:\nreturn 'ID_var';\ncase 2123:\nreturn 'ID_void';\ncase 2124:\nreturn 'ID_while';\ncase 2125:\nreturn 'ID_with';\ncase 2126:\nreturn 'ID_yield';\ncase 4104:\nreturn 'NUMBER_HEX';\ncase 4105:\nreturn 'NUMBER_DEC';\ncase 4106:\nreturn 'NUMBER_BIN';\ncase 4107:\nreturn 'NUMBER_OCT';\ncase 4108:\nreturn 'NUMBER_OLD';\ncase 12296:\nreturn 'NUMBER_BIG_HEX';\ncase 12297:\nreturn 'NUMBER_BIG_DEC';\ncase 12298:\nreturn 'NUMBER_BIG_BIN';\ncase 12299:\nreturn 'NUMBER_BIG_OCT';\ncase 16463:\nreturn 'PUNC_EXCL';\ncase 82000:\nreturn 'PUNC_EXCL_EQ';\ncase 82001:\nreturn 'PUNC_EXCL_EQ_EQ';\ncase 82002:\nreturn 'PUNC_PERCENT';\ncase 49235:\nreturn 'PUNC_PERCENT_EQ';\ncase 82004:\nreturn 'PUNC_AND';\ncase 82005:\nreturn 'PUNC_AND_AND';\ncase 49238:\nreturn 'PUNC_AND_EQ';\ncase 16471:\nreturn 'PUNC_PAREN_OPEN';\ncase 16472:\nreturn 'PUNC_PAREN_CLOSE';\ncase 82009:\nreturn 'PUNC_STAR';\ncase 82010:\nreturn 'PUNC_STAR_STAR';\ncase 49243:\nreturn 'PUNC_STAR_EQ';\ncase 49244:\nreturn 'PUNC_STAR_STAR_EQ';\ncase 82013:\nreturn 'PUNC_PLUS';\ncase 16478:\nreturn 'PUNC_PLUS_PLUS';\ncase 49247:\nreturn 'PUNC_PLUS_EQ';\ncase 16480:\nreturn 'PUNC_COMMA';\ncase 82017:\nreturn 'PUNC_MIN';\ncase 16482:\nreturn 'PUNC_MIN_MIN';\ncase 49251:\nreturn 'PUNC_MIN_EQ';\ncase 16484:\nreturn 'PUNC_MIN_MIN_GT';\ncase 16485:\nreturn 'PUNC_DOT';\ncase 16486:\nreturn 'PUNC_DOT_DOT_DOT';\ncase 82023:\nreturn 'PUNC_DIV';\ncase 49256:\nreturn 'PUNC_DIV_EQ';\ncase 16489:\nreturn 'PUNC_COLON';\ncase 16490:\nreturn 'PUNC_SEMI';\ncase 82027:\nreturn 'PUNC_LT';\ncase 82028:\nreturn 'PUNC_LT_LT';\ncase 82029:\nreturn 'PUNC_LT_EQ';\ncase 49262:\nreturn 'PUNC_LT_LT_EQ';\ncase 16495:\nreturn 'PUNC_LT_EXCL_MIN_MIN';\ncase 49264:\nreturn 'PUNC_EQ';\ncase 82033:\nreturn 'PUNC_EQ_EQ';\ncase 82034:\nreturn 'PUNC_EQ_EQ_EQ';\ncase 16499:\nreturn 'PUNC_EQ_GT';\ncase 82036:\nreturn 'PUNC_GT';\ncase 82037:\nreturn 'PUNC_GT_GT';\ncase 82038:\nreturn 'PUNC_GT_GT_GT';\ncase 82039:\nreturn 'PUNC_GT_EQ';\ncase 49272:\nreturn 'PUNC_GT_GT_EQ';\ncase 49273:\nreturn 'PUNC_GT_GT_GT_EQ';\ncase 16506:\nreturn 'PUNC_QMARK';\ncase 82043:\nreturn 'QMARK_DOT';\ncase 82044:\nreturn 'QMARK_QMARK';\ncase 16509:\nreturn 'PUNC_BRACKET_OPEN';\ncase 16510:\nreturn 'PUNC_BRACKET_CLOSE';\ncase 82047:\nreturn 'PUNC_CARET';\ncase 49280:\nreturn 'PUNC_CARET_EQ';\ncase 16513:\nreturn 'PUNC_CURLY_OPEN';\ncase 82050:\nreturn 'PUNC_OR';\ncase 82051:\nreturn 'PUNC_OR_OR';\ncase 49284:\nreturn 'PUNC_OR_EQ';\ncase 16517:\nreturn 'PUNC_CURLY_CLOSE';\ncase 16518:\nreturn 'PUNC_TILDE';\ncase 262157:\nreturn 'REGEXN';\ncase 262158:\nreturn 'REGEXU';\ncase 131087:\nreturn 'STRING_SINGLE';\ncase 131088:\nreturn 'STRING_DOUBLE';\ncase 524305:\nreturn 'TICK_HEAD';\ncase 524306:\nreturn 'TICK_BODY';\ncase 524307:\nreturn 'TICK_TAIL';\ncase 524308:\nreturn 'TICK_PURE';\ncase 1572881:\nreturn 'TICK_BAD_HEAD';\ncase 1572882:\nreturn 'TICK_BAD_BODY';\ncase 1572883:\nreturn 'TICK_BAD_TAIL';\ncase 1572884:\nreturn 'TICK_BAD_PURE';\ncase 2097173:\nreturn 'EOF';\ncase 2097174:\nreturn 'ASI';\ncase 2097175:\nreturn 'ERROR';\n}\nthrow new Error(('toktypeToString: UNKNOWN[' + JSON.stringify(type)) + ']');\n}\nlet MAX_START_VALUE = 26;\nlet __$flag_start = 0;\nlet tokenStartJumpTable = [26, 26, 26, 26, 26, 26, 26, 26, 26, 1, 4, 1, 1, 5, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 1, 16, 6, 26, 2, 17, 18, 6, 16471, 16472, 19, 12, 16480, 13, 8, 11, 14, 7, 7, 7, 7, 7, 7, 7, 7, 7, 16489, 16490, 21, 10, 22, 25, 26, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 16509, 24, 16510, 20, 2, 15, 3, 3, 3, 3, 3, 3, 3, 2, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 2, 16513, 23, 9, 16518];\nlet stringScanTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nlet identScanTable = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1];\nlet regexAtomEscapeStartJumpTable = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 0, 1, 11, 11, 11, 0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 6, 11, 11, 0, 11, 11, 11, 0, 11, 11, 11, 0, 0, 0, 0, 11, 1, 11, 11, 5, 0, 11, 0, 11, 11, 11, 11, 9, 11, 11, 0, 11, 6, 11, 0, 0, 0, 2, 0, 0, 3, 11, 11, 0, 0, 0, 1];\nlet regexClassEscapeStartJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 18, 18, 18, 18, 0, 19, 18, 18, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17, 0, 0, 0, 0, 0, 18, 0, 0, 7, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 13, 0, 0, 0, 13, 0, 0, 0, 18, 18, 18, 18, 0, 0, 0, 6, 4, 13, 0, 8, 0, 0, 0, 0, 5, 0, 0, 9, 0, 14, 0, 10, 13, 11, 2, 12, 13, 3, 0, 0, 18, 18, 18, 0];\nlet hexValueJumpTable = [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 16, 16, 16, 16, 16, 16, 10, 11, 12, 13, 14, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 10, 11, 12, 13, 14, 15];\nlet regexAtomJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 3, 4, 2, 2, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 14, 13, 0];\nlet stringEscapeStartJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 0, 7, 4, 15, 0, 5, 0, 0, 0, 0, 0, 0];\nfunction getTokenStart(c) {\nlet s = tokenStartJumpTable[c];\nreturn s;\n}\nfunction getStringPart(c) {\nif (c > 0x7e) return 3;\nlet s = stringScanTable[c];\nreturn s;\n}\nfunction getIdentPart(c) {\nif (c > 0x7e) return 3;\nlet s = identScanTable[c];\nreturn s;\n}\nfunction getHexValue(c) {\nif (c > 0x66) return 16;\nlet v = hexValueJumpTable[c];\nreturn v;\n}\nfunction T(type) {\nreturn ('T<' + toktypeToString(type)) + '>';\n}\n// </tokentype>\n\n// <lexerflags>\nlet __$flag_lf = 0;\nfunction L(flags) {\nlet bak = flags;\nlet s = [];\nif (!flags) {\ns.push('LF_NO_FLAGS');\n}\nif (flags & 8192) {\nflags ^= 8192;\ns.push('LF_STRICT_MODE');\n}\nif (flags & 4) {\nflags ^= 4;\ns.push('LF_FOR_REGEX');\n}\nif (flags & 2048) {\nflags ^= 2048;\ns.push('LF_IN_TEMPLATE');\n}\nif (flags & 8) {\nflags ^= 8;\ns.push('LF_IN_ASYNC');\n}\nif (flags & 128) {\nflags ^= 128;\ns.push('LF_IN_GENERATOR');\n}\nif (flags & 16) {\nflags ^= 16;\ns.push('LF_IN_CONSTRUCTOR');\n}\nif (flags & 64) {\nflags ^= 64;\ns.push('LF_IN_FUNC_ARGS');\n}\nif (flags & 256) {\nflags ^= 256;\ns.push('LF_IN_GLOBAL');\n}\nif (flags & 512) {\nflags ^= 512;\ns.push('LF_IN_ITERATION');\n}\nif (flags & 1024) {\nflags ^= 1024;\ns.push('LF_IN_SWITCH');\n}\nif (flags & 2) {\nflags ^= 2;\ns.push('LF_CAN_NEW_DOT_TARGET');\n}\nif (flags & 32) {\nflags ^= 32;\ns.push('LF_IN_FOR_LHS');\n}\nif (flags & 4096) {\nflags ^= 4096;\ns.push('LF_NO_ASI');\n}\nif (flags & 16384) {\nflags ^= 16384;\ns.push('LF_SUPER_CALL');\n}\nif (flags & 32768) {\nflags ^= 32768;\ns.push('LF_SUPER_PROP');\n}\nif (flags & 65536) {\nflags ^= 65536;\ns.push('LF_NOT_KEYWORD');\n}\nif (flags) {\nthrow new Error(((((('UNKNOWN_FLAGS: ' + flags.toString(2)) + ' (was: ') + bak.toString(2)) + '), so far: [') + s.join('|')) + ']');\n}\nreturn 'L:' + s.join('|');\n}\n// </lexerflags>\n\n// <enum_lexer>\nconst GOAL_MODULE = true;\nconst GOAL_SCRIPT = false;\nconst COLLECT_TOKENS_NONE = 0;\nconst COLLECT_TOKENS_SOLID = 1;\nconst COLLECT_TOKENS_ALL = 2;\nconst COLLECT_TOKENS_TYPES = 3;\nconst WEB_COMPAT_OFF = false;\nconst WEB_COMPAT_ON = true;\n// </enum_lexer>\n\n// <enum_parser>\nconst VERSION_EXPONENTIATION = 7;\nconst VERSION_WHATEVER = Infinity;\nlet BINDING_TYPE_NONE = 0;\nlet BINDING_TYPE_ARG = 1;\nlet BINDING_TYPE_VAR = 2;\nlet BINDING_TYPE_FUNC_VAR = 3;\nlet BINDING_TYPE_FUNC_STMT = 4;\nlet BINDING_TYPE_FUNC_LEX = 5;\nlet BINDING_TYPE_LET = 6;\nlet BINDING_TYPE_CONST = 7;\nlet BINDING_TYPE_CLASS = 8;\nlet BINDING_TYPE_CATCH_IDENT = 9;\nlet BINDING_TYPE_CATCH_OTHER = 10;\nlet HAS_NO_BINDINGS = null;\nlet SCOPE_LAYER_GLOBAL = 0;\nlet SCOPE_LAYER_FOR_HEADER = 1;\nlet SCOPE_LAYER_BLOCK = 2;\nlet SCOPE_LAYER_FUNC_PARAMS = 3;\nlet SCOPE_LAYER_CATCH_HEAD = 5;\nlet SCOPE_LAYER_CATCH_BODY = 6;\nlet SCOPE_LAYER_FINALLY = 7;\nlet SCOPE_LAYER_SWITCH = 8;\nlet SCOPE_LAYER_FUNC_ROOT = 9;\nlet SCOPE_LAYER_FUNC_BODY = 10;\nlet SCOPE_LAYER_ARROW_PARAMS = 11;\nlet SCOPE_LAYER_FAKE_BLOCK = 12;\nfunction DEVONLY() {\nlet dev = false;\nreturn dev;\n}\nfunction copyPiggies(output, input) {\nreturn output | (input & 1984);\n}\nfunction P(f, arr) {\nif (f & 256) {\narr.push('PIGGY_BACK_WAS_CONSTRUCTOR');\nf ^= 256;\n}\nif (f & 512) {\narr.push('PIGGY_BACK_WAS_PROTO');\nf ^= 512;\n}\nif (f & 64) {\narr.push('PIGGY_BACK_SAW_AWAIT');\nf ^= 64;\n}\nif (f & 128) {\narr.push('PIGGY_BACK_SAW_YIELD');\nf ^= 128;\n}\nif (f & 1024) {\narr.push('PIGGY_BACK_WAS_ARROW');\nf ^= 1024;\n}\nreturn f;\n}\n// </enum_parser>\n\n// <lexer>\nconst TABLE_NONBIN_UNI_PROPS = ',General_Category,gc,Script,sc,Script_Extensions,scx,';\nconst TABLE_BIN_UNI_PROPS = ',ASCII,ASCII_Hex_Digit,AHex,Alphabetic,Alpha,Any,Assigned,Bidi_Control,Bidi_C,Bidi_Mirrored,Bidi_M,Case_Ignorable,CI,Cased,Changes_When_Casefolded,CWCF,Changes_When_Casemapped,CWCM,Changes_When_Lowercased,CWL,Changes_When_NFKC_Casefolded,CWKCF,Changes_When_Titlecased,CWT,Changes_When_Uppercased,CWU,Dash,Default_Ignorable_Code_Point,DI,Deprecated,Dep,Diacritic,Dia,Emoji,Emoji_Component,Emoji_Modifier,Emoji_Modifier_Base,Emoji_Presentation,Extended_Pictographic,Extender,Ext,Grapheme_Base,Gr_Base,Grapheme_Extend,Gr_Ext,Hex_Digit,Hex,IDS_Binary_Operator,IDSB,IDS_Trinary_Operator,IDST,ID_Continue,IDC,ID_Start,IDS,Ideographic,Ideo,Join_Control,Join_C,Logical_Order_Exception,LOE,Lowercase,Lower,Math,Noncharacter_Code_Point,NChar,Pattern_Syntax,Pat_Syn,Pattern_White_Space,Pat_WS,Quotation_Mark,QMark,Radical,Regional_Indicator,RI,Sentence_Terminal,STerm,Soft_Dotted,SD,Terminal_Punctuation,Term,Unified_Ideograph,UIdeo,Uppercase,Upper,Variation_Selector,VS,White_Space,space,XID_Continue,XIDC,XID_Start,XIDS,';\nconst TABLE_GEN_CAT_VALUES = ',Cased_Letter,LC,Close_Punctuation,Pe,Connector_Punctuation,Pc,Control,Cc,cntrl,Currency_Symbol,Sc,Dash_Punctuation,Pd,Decimal_Number,Nd,digit,Enclosing_Mark,Me,Final_Punctuation,Pf,Format,Cf,Initial_Punctuation,Pi,Letter,L,Letter_Number,Nl,Line_Separator,Zl,Lowercase_Letter,Ll,Mark,M,Combining_Mark,Math_Symbol,Sm,Modifier_Letter,Lm,Modifier_Symbol,Sk,Nonspacing_Mark,Mn,Number,N,Open_Punctuation,Ps,Other,C,Other_Letter,Lo,Other_Number,No,Other_Punctuation,Po,Other_Symbol,So,Paragraph_Separator,Zp,Private_Use,Co,Punctuation,P,punct,Separator,Z,Space_Separator,Zs,Spacing_Mark,Mc,Surrogate,Cs,Symbol,S,Titlecase_Letter,Lt,Unassigned,Cn,Uppercase_Letter,Lu,';\nconst TABLE_SCRIPT_VALUES = ',Adlam,Adlm,Ahom,Anatolian_Hieroglyphs,Hluw,Arabic,Arab,Armenian,Armn,Avestan,Avst,Balinese,Bali,Bamum,Bamu,Bassa_Vah,Bass,Batak,Batk,Bengali,Beng,Bhaiksuki,Bhks,Bopomofo,Bopo,Brahmi,Brah,Braille,Brai,Buginese,Bugi,Buhid,Buhd,Canadian_Aboriginal,Cans,Carian,Cari,Caucasian_Albanian,Aghb,Chakma,Cakm,Cham,Cherokee,Cher,Common,Zyyy,Coptic,Copt,Qaac,Cuneiform,Xsux,Cypriot,Cprt,Cyrillic,Cyrl,Deseret,Dsrt,Devanagari,Deva,Dogra,Dogr,Duployan,Dupl,Egyptian_Hieroglyphs,Egyp,Elbasan,Elba,Elymaic,Elym,Ethiopic,Ethi,Georgian,Geor,Glagolitic,Glag,Gothic,Goth,Grantha,Gran,Greek,Grek,Gujarati,Gujr,Gunjala_Gondi,Gong,Gurmukhi,Guru,Han,Hani,Hangul,Hang,Hanifi_Rohingya,Rohg,Hanunoo,Hano,Hatran,Hatr,Hebrew,Hebr,Hiragana,Hira,Imperial_Aramaic,Armi,Inherited,Zinh,Qaai,Inscriptional_Pahlavi,Phli,Inscriptional_Parthian,Prti,Javanese,Java,Kaithi,Kthi,Kannada,Knda,Katakana,Kana,Kayah_Li,Kali,Kharoshthi,Khar,Khmer,Khmr,Khojki,Khoj,Khudawadi,Sind,Lao,Laoo,Latin,Latn,Lepcha,Lepc,Limbu,Limb,Linear_A,Lina,Linear_B,Linb,Lisu,Lycian,Lyci,Lydian,Lydi,Mahajani,Mahj,Makasar,Maka,Malayalam,Mlym,Mandaic,Mand,Manichaean,Mani,Marchen,Marc,Medefaidrin,Medf,Masaram_Gondi,Gonm,Meetei_Mayek,Mtei,Mende_Kikakui,Mend,Meroitic_Cursive,Merc,Meroitic_Hieroglyphs,Mero,Miao,Plrd,Modi,Mongolian,Mong,Mro,Mroo,Multani,Mult,Myanmar,Mymr,Nabataean,Nbat,Nandinagari,Nand,New_Tai_Lue,Talu,Newa,Nko,Nkoo,Nushu,Nshu,Nyiakeng_Puachue_Hmong,Hmnp,Ogham,Ogam,Ol_Chiki,Olck,Old_Hungarian,Hung,Old_Italic,Ital,Old_North_Arabian,Narb,Old_Permic,Perm,Old_Persian,Xpeo,Old_Sogdian,Sogo,Old_South_Arabian,Sarb,Old_Turkic,Orkh,Oriya,Orya,Osage,Osge,Osmanya,Osma,Pahawh_Hmong,Hmng,Palmyrene,Palm,Pau_Cin_Hau,Pauc,Phags_Pa,Phag,Phoenician,Phnx,Psalter_Pahlavi,Phlp,Rejang,Rjng,Runic,Runr,Samaritan,Samr,Saurashtra,Saur,Sharada,Shrd,Shavian,Shaw,Siddham,Sidd,SignWriting,Sgnw,Sinhala,Sinh,Sogdian,Sogd,Sora_Sompeng,Sora,Soyombo,Soyo,Sundanese,Sund,Syloti_Nagri,Sylo,Syriac,Syrc,Tagalog,Tglg,Tagbanwa,Tagb,Tai_Le,Tale,Tai_Tham,Lana,Tai_Viet,Tavt,Takri,Takr,Tamil,Taml,Tangut,Tang,Telugu,Telu,Thaana,Thaa,Thai,Tibetan,Tibt,Tifinagh,Tfng,Tirhuta,Tirh,Ugaritic,Ugar,Vai,Vaii,Wancho,Wcho,Warang_Citi,Wara,Yi,Yiii,Zanabazar_Square,Zanb,';\nlet ID_START_REGEX = undefined;\nfunction getIdStartRegexSuperSlow() {\nif (ID_START_REGEX) return ID_START_REGEX;\nreturn ID_START_REGEX = createUnicodeRegex('^\\\\p{ID_Start}$');\n}\nlet ID_CONTINUE_REGEX = undefined;\nfunction getIdRestRegexSuperSlow() {\nif (ID_CONTINUE_REGEX) return ID_CONTINUE_REGEX;\nreturn ID_CONTINUE_REGEX = createUnicodeRegex('^\\\\p{ID_Continue}$');\n}\nfunction createUnicodeRegex(pattern) {\ntry {\nreturn new RegExp(pattern, 'u');\n} catch (e) {\nconsole.warn(('Tenko: Current nodejs version does not suppport unicode regexes or regex property escapes; Input contains unicode that requires it so Tenko is unable to properly parse input (' + e.message) + ')');\nreturn /|/;\n}\n}\nfunction Lexer(input, options) {\nconst {targetEsVersion = Infinity, parsingGoal = true, collectTokens = 0, returnTokens = 3, webCompat = true, gracefulErrors = false, tokenStorageExternal, babelTokenCompat = false, errorCodeFrame = true, truncCodeFrame = false, $log = console.log, $warn = console.warn, $error = console.error} = options;\nconst tokenStorage = (tokenStorageExternal || (((collectTokens !== 0)? [] : undefined)));\nconst supportRegexPropertyEscapes = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexLookbehinds = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexDotallFlag = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexNamedGroups = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportBigInt = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nconst supportNullishCoalescing = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nconst supportOptionalChaining = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nlet pointer = 0;\nlet len = input.length;\nlet consumedNewlinesBeforeSolid = false;\nlet nlwas = false;\nlet finished = false;\nlet lastOffset = pointer;\nlet startForError = 0;\nlet lastType = 0;\nlet lastStart = 0;\nlet lastStop = 0;\nlet lastLine = 0;\nlet lastColumn = 0;\nlet lastCanonizedInput = '';\nlet lastCanonizedInputLen = 0;\nlet lastPotentialRegexError = '';\nlet lastReportableLexerError = '';\nlet currentLine = 1;\nlet currentColOffset = 0;\nlet prevTokenEndColumn = 0;\nlet prevTokenEndLine = 0;\nlet prevTokenEndPointer = 0;\nlet prevTokenSolid = true;\nlet stale = false;\nlet cache = input.charCodeAt(0);\nlet anyTokenCount = 0;\nlet solidTokenCount = 0;\nfunction peek() {\nreturn cache;\n}\nfunction _readCache() {\nreturn cache;\n}\nfunction peekd(delta) {\nreturn input.charCodeAt(pointer + delta);\n}\nfunction peeky(ord) {\nreturn cache === ord;\n}\nfunction slice(from, to) {\nreturn input.slice(from, to);\n}\nfunction skipPeek() {\nreturn cache = input.charCodeAt(++pointer);\n}\nfunction skip() {\nlet p = ++pointer;\nif (pointer >= len) {\ncache = 0;\nreturn;\n}\ncache = input.charCodeAt(p);\n}\nfunction skipFastWithoutUpdatingCache() {\n++pointer;\n}\nfunction eof() {\nreturn pointer >= len;\n}\nfunction eofd(d) {\nreturn pointer >= (len - d);\n}\nfunction neof() {\nreturn pointer < len;\n}\nfunction neofd(d) {\nreturn pointer <= (len - d);\n}\nfunction nextToken(lexerFlags) {\nif (prevTokenSolid) {\nprevTokenEndColumn = pointer - currentColOffset;\nprevTokenEndLine = currentLine;\nprevTokenEndPointer = pointer;\nprevTokenSolid = false;\n}\nlastPotentialRegexError = '';\nlastReportableLexerError = '';\ndo {\n++anyTokenCount;\nlet startCol = pointer - currentColOffset;\nlet startRow = currentLine;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nnlwas = consumedNewlinesBeforeSolid;\nif (pointer >= len) {\ncreateToken(2097173, pointer, pointer, startCol, startRow);\nfinished = true;\nreturn returnSolidToken(2097173, pointer, pointer, startCol, startRow);\n}\nlet start = startForError = pointer;\nlet consumedTokenType = jumpTableLexer(lexerFlags);\nif (!isWhiteToken(consumedTokenType)) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\nreturn returnSolidToken(consumedTokenType, start, pointer, startCol, startRow);\n}\nif (isCommentToken(consumedTokenType)) {\nif (returnTokens === 2) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\nreturn returnCommentToken(consumedTokenType, start, pointer, startCol, startRow);\n}\n}\nif (((collectTokens === 2) || (collectTokens === 3))) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, false)));\n}\nif (returnTokens === 1) {\nreturn createToken(consumedTokenType, start, pointer, startCol, startRow);\n}\nif (consumedTokenType === 1285) {\nif (((collectTokens !== 2) && (collectTokens !== 3))) skipNewlinesWithoutTokens();\n}\nif (nlwas === true) {\nif (((collectTokens !== 2) && (collectTokens !== 3))) skipSpacesWithoutTokens();\n}\n} while (true);\n}\nfunction returnCommentToken(consumedTokenType, start, pointer, startCol, startRow) {\nif (((collectTokens === 2) || (collectTokens === 3))) {\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, false)));\n}\n}\nfunction returnSolidToken(consumedTokenType, start, pointer, startCol, startRow) {\n++solidTokenCount;\nif (collectTokens !== 0) {\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, consumedNewlinesBeforeSolid)));\n}\nconsumedNewlinesBeforeSolid = false;\nprevTokenSolid = true;\n}\nfunction skipSpacesWithoutTokens() {\nwhile (pointer < len) {\nlet c = cache;\nif (((c !== 0x20) && (c !== 0x09))) return;\nskip();\n}\n}\nfunction skipNewlinesWithoutTokens() {\nwhile (pointer < len) {\nlet c = cache;\nif (c === 0x0A) {\nskip();\nincrementLine();\n} else if (c === 0x0D) {\nskip();\nparseCR();\n} else {\nreturn;\n}\n}\n}\nfunction jumpTableLexer(lexerFlags) {\nlet c = cache;\nskip();\nif (c > 0x7e) {\nreturn parseOtherUnicode(c);\n}\nlet s = getTokenStart(c);\nif (s > MAX_START_VALUE) {\nreturn s;\n}\nswitch (s) {\ncase 1:\nreturn parseSpace();\ncase 2:\nreturn parseIdentifierRest(String.fromCharCode(c), 1);\ncase 3:\nif ((lexerFlags & 65536) === 65536) return parseIdentifierRest(String.fromCharCode(c), 1);\nreturn parsePotentialKeywordTrieMap(c);\ncase 4:\nreturn parseNewlineSolo();\ncase 5:\nreturn parseCR();\ncase 6:\nreturn parseAnyString(c, lexerFlags);\ncase 7:\nreturn parseDecimal();\ncase 8:\nreturn parseLeadingDot();\ncase 9:\nif ((lexerFlags & 2048) === 2048) return parseTemplateString(lexerFlags, false);\nreturn 16517;\ncase 10:\nreturn parseEqual();\ncase 11:\nreturn parseFwdSlash(lexerFlags);\ncase 12:\nreturn parseSameOrCompound(0x2b);\ncase 13:\nreturn parseDash();\ncase 14:\nreturn parseLeadingZero(lexerFlags);\ncase 15:\nreturn parseTemplateString(lexerFlags, true);\ncase 16:\nreturn parseExcl();\ncase 17:\nreturn parseCompoundAssignment(0x25);\ncase 18:\nreturn parseSameOrCompound(0x26);\ncase 19:\nreturn parseStar();\ncase 20:\nreturn parseCompoundAssignment(0x5e);\ncase 21:\nreturn parseLt();\ncase 22:\nreturn parseGtPunctuator();\ncase 23:\nreturn parseSameOrCompound(0x7c);\ncase 24:\nreturn parseBackslash();\ncase 25:\nreturn parseQmark();\n}\nTHROW('Unknown input', pointer - 1, pointer);\n}\nfunction incrementLine() {\nconsumedNewlinesBeforeSolid = true;\n++currentLine;\ncurrentColOffset = pointer;\n}\nfunction addAsi() {\nif (collectTokens !== 0) {\ntokenStorage.push(((collectTokens === 3)? 2097174 : createBaseToken(2097174, pointer, pointer, pointer - currentColOffset, currentLine, false)), tokenStorage.pop());\n}\n++anyTokenCount;\n++solidTokenCount;\nprevTokenSolid = true;\n}\nfunction createToken(type, start, stop, column, line) {\nlastType = type;\nlastStart = start;\nlastStop = stop;\nlastLine = line;\nlastColumn = column;\n}\nfunction createBaseToken(type, start, stop, column, line, nl) {\nif (babelTokenCompat) {\nreturn {type, start, stop, loc:{start:{line:line, column:column}, end:{line:currentLine, column:currentColOffset}}, column, line};\n}\nreturn {type, start, stop, column, line, nl};\n}\nfunction parseLeadingDot() {\nif (pointer >= len) return 16485;\nlet c = cache;\nif (c === 0x2e) {\nreturn parseTripleDot();\n}\nif (isAsciiNumber(c)) {\nreturn parseNumberFromDot(c);\n}\nreturn 16485;\n}\nfunction parseTripleDot() {\nif (peekd(1) === 0x2e) {\nskip();\nskip();\nreturn 16486;\n}\nreturn 16486;\n}\nfunction parseNumberFromDot(c) {\nskip();\nif (pointer < len) {\nlet d = skipDigits();\nparseExponentMaybe(d);\n}\nverifyCharAfterNumber();\nreturn 4105;\n}\nfunction parseSpace() {\nreturn 257;\n}\nfunction parseCR() {\nif ((pointer < len && (cache === 0x0A))) {\nskip();\nincrementLine();\nreturn 772;\n}\nincrementLine();\nreturn 771;\n}\nfunction parseAnyString(marker, lexerFlags) {\nlet pointerOffset = pointer;\nlet badEscape = false;\nlet hadNewline = false;\nwhile (pointer < len) {\nlet c = cache;\nlet s = getStringPart(c);\nif (s <= MAX_START_VALUE) {\nswitch (s) {\ncase 0:\nskip();\nbreak;\ncase 1:\nskip();\nif (c === marker) {\nif (badEscape) {\nif (!lastReportableLexerError) lastReportableLexerError = 'String had an illegal escape';\nreturn 2097175;\n}\nif (hadNewline) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Encountered newline in string which is not allowed';\nreturn 2097175;\n}\nlastCanonizedInput += slice(pointerOffset, pointer - 1);\nlastCanonizedInputLen += (pointer - 1) - pointerOffset;\nreturn ((marker === 0x22)? 131088 : 131087);\n}\nbreak;\ncase 2:\nlastCanonizedInput += slice(pointerOffset, pointer);\nlastCanonizedInputLen += pointer - pointerOffset;\nbadEscape = ((parseStringOrTemplateEscape(lexerFlags, false) === true) || badEscape);\npointerOffset = pointer;\nbreak;\ncase 3:\nskip();\nif (((c <= 0x2029) && (c >= 0x2028))) {\nincrementLine();\n}\nbreak;\ncase 4:\nskip();\nhadNewline = true;\nbreak;\n;\n}\n}\n}\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed string at EOF';\nreturn 2097175;\n}\nfunction parseStringOrTemplateEscape(lexerFlags, forTemplate) {\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Backslash at end of input';\nreturn true;\n}\nlet c = cache;\nskip();\nlet s = ((c > 0x7e)? 6 : stringEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nlastCanonizedInput += String.fromCharCode(c);\n++lastCanonizedInputLen;\nreturn false;\ncase 1:\nlastCanonizedInput += '\\n';\n++lastCanonizedInputLen;\nreturn false;\ncase 2:\nlastCanonizedInput += '\\'';\n++lastCanonizedInputLen;\nreturn false;\ncase 3:\nlastCanonizedInput += '\"';\n++lastCanonizedInputLen;\nreturn false;\ncase 4:\n{\nif (pointer >= len) return true;\nlet r = parseUnicodeEscapeForNonRegex();\nif (r === 0x110000) return true;\nlastCanonizedInput += ((r > 0xffff)? String.fromCodePoint(r) : String.fromCharCode(r));\nlastCanonizedInputLen += ((r > 0xffff)? 2 : 1);\nreturn false;\n}\ncase 5:\nreturn parseStringEscapeHex();\ncase 6:\nif (((c === 0x2028) || (c === 0x2029))) {\nincrementLine();\nreturn false;\n}\nlastCanonizedInput += String.fromCharCode(c);\n++lastCanonizedInputLen;\nreturn false;\ncase 7:\nlastCanonizedInput += '\\t';\n++lastCanonizedInputLen;\nreturn false;\ncase 8:\nlastCanonizedInput += '\\r';\n++lastCanonizedInputLen;\nreturn false;\ncase 9:\nif ((pointer < len && (cache === 0x0A))) skip();\nincrementLine();\nreturn false;\ncase 10:\nincrementLine();\nreturn false;\ncase 11:\n\ncase 12:\nreturn parseStringEscapeOctalOrDigit(c, forTemplate, lexerFlags);\ncase 13:\nlastCanonizedInput += '\\b';\n++lastCanonizedInputLen;\nreturn false;\ncase 14:\nlastCanonizedInput += '\\f';\n++lastCanonizedInputLen;\nreturn false;\ncase 15:\nlastCanonizedInput += '\\v';\n++lastCanonizedInputLen;\nreturn false;\n;\n}\n}\nfunction skipZeroes() {\nlet c = cache;\nwhile (c === 0x30) {\nskip();\nif (pointer >= len) return 0;\nc = cache;\n}\nreturn c;\n}\nfunction parseStringEscapeHex() {\nif (eofd(1)) {\nif (pointer >= len) return false;\nif (!lastReportableLexerError) lastReportableLexerError = 'Not enough of input left to create valid hex escape';\nreturn true;\n}\nlet a = cache;\nlet b = peekd(1);\nlet va = getHexValue(a);\nlet vb = getHexValue(b);\nif ((va | vb) >= 16) {\nlastCanonizedInput += 'x';\n++lastCanonizedInputLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'At least one of the two hex characters were not hex character (0-9a-f)';\nreturn true;\n}\nskip();\nskip();\nlastCanonizedInput += String.fromCharCode((va << 4) | vb);\n++lastCanonizedInputLen;\nreturn false;\n}\nfunction parseStringEscapeOctalOrDigit(a, forTemplate, lexerFlags) {\nif (((a === 0x38) || (a === 0x39))) {\nif (!lastReportableLexerError) lastReportableLexerError = 'The grammar does not allow to escape the 8 or the 9 character';\nreturn true;\n}\nif (pointer >= len) return false;\nlet b = cache;\nif (((((webCompat === false) || forTemplate)) || ((lexerFlags & 8192) === 8192))) {\nif (((a === 0x30) && (((b < 0x30) || (b > 0x39))))) {\nlastCanonizedInput += '\\0';\n++lastCanonizedInputLen;\nreturn false;\n}\nif (forTemplate) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Illegal legacy octal escape in template, where octal escapes are never allowed';\n} else if ((lexerFlags & 8192) === 8192) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Illegal legacy octal escape in strict mode';\n} else {\nif (!lastReportableLexerError) lastReportableLexerError = 'Octal escapes are only allowed in sloppy mode with web compat enabled';\n}\nreturn true;\n}\nif (((a === 0x30) && (((b < 0x30) || (b > 0x37))))) {\nlastCanonizedInput += '\\0';\n++lastCanonizedInputLen;\nreturn false;\n}\nif (((b < 0x30) || (b > 0x37))) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nskip();\nif (pointer >= len) return false;\nif (a > 0x33) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nlet c = cache;\nif (((c < 0x30) || (c > 0x37))) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nskip();\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b, c), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nfunction parseDash() {\nif (((((((((parsingGoal === false) && (webCompat === true))) && (!eofd(1)))) && (cache === 0x2d))) && (peekd(1) === 0x3e))) {\nif (consumedNewlinesBeforeSolid === true) {\nreturn parseCommentHtmlClose();\n} else {\n\n}\n}\nreturn parseSameOrCompound(0x2d);\n}\nfunction parseSameOrCompound(c) {\nif (pointer < len) {\nlet d = cache;\nif (d === c) {\nskip();\nswitch (c) {\ncase 0x2b:\nreturn 16478;\ncase 0x2d:\nreturn 16482;\ncase 0x26:\nreturn 82005;\ncase 0x7c:\nreturn 82051;\n;\n}\n}\nif (d === 0x3d) {\nskip();\nswitch (c) {\ncase 0x2b:\nreturn 49247;\ncase 0x2d:\nreturn 49251;\ncase 0x26:\nreturn 49238;\ncase 0x7c:\nreturn 49284;\n;\n}\n}\n}\nswitch (c) {\ncase 0x2b:\nreturn 82013;\ncase 0x2d:\nreturn 82017;\ncase 0x26:\nreturn 82004;\ncase 0x7c:\nreturn 82050;\n;\n}\n}\nfunction parseTemplateString(lexerFlags, fromTick) {\nlastOffset = pointer;\nlet badEscapes = false;\nwhile (pointer < len) {\nlet c = cache;\nwhile (c === 0x24) {\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed template string';\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nreturn 2097175;\n}\nc = cache;\nif (c === 0x7b) {\nlastCanonizedInput += slice(lastOffset, pointer - 1);\nlastCanonizedInputLen += (pointer - 1) - lastOffset;\nskip();\nreturn (badEscapes? ((fromTick? 1572881 : 1572882)) : ((fromTick? 524305 : 524306)));\n}\n}\nif (c === 0x60) {\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nskip();\nreturn (badEscapes? ((fromTick? 1572884 : 1572883)) : ((fromTick? 524308 : 524307)));\n}\nif (c === 0x0D) {\nskip();\nif ((pointer < len && (cache === 0x0A))) {\nskip();\n}\nincrementLine();\n} else if (isLfPsLs(c)) {\nskip();\nincrementLine();\n} else if (c === 0x5c) {\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nbadEscapes = ((parseStringOrTemplateEscape(lexerFlags, true) === true) || badEscapes);\nlastOffset = pointer;\n} else {\nskip();\n}\n}\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed template literal';\nreturn 2097175;\n}\nfunction verifyCharAfterNumber() {\nif (pointer >= len) return;\nlet c = cache;\nif (((isIdentStart(c, 0) !== (-1)) || (((c >= 0x30) && (c <= 0x39))))) {\nreturn THROW(('Found `' + String.fromCharCode(c)) + '`. It is not legal for an ident or number token to start after a number token without some form of separation', pointer, pointer);\n}\n}\nfunction parseLeadingZero(lexerFlags) {\nlet r = _parseLeadingZero(lexerFlags);\nif (r !== 2097175) verifyCharAfterNumber();\nreturn r;\n}\nfunction _parseLeadingZero(lexerFlags) {\nif (pointer >= len) return 4105;\nlet c = cache;\nif (isAsciiNumber(c)) {\nskip();\nif (pointer < len) skipDigits();\nif ((lexerFlags & 8192) === 8192) {\nif (!lastReportableLexerError) lastReportableLexerError = '\"Illegal\" octal escape in strict mode';\nreturn 2097175;\n}\nif (pointer < len) {\nlet e = cache;\nif (((e === 0x45) || (e === 0x65))) {\nif (!lastReportableLexerError) lastReportableLexerError = 'An exponent is not allowed after a legacy octal number and an ident after number must be separated by some whitespace so this is an error';\nreturn 2097175;\n}\nif (e === 0x6E) {\nif (!supportBigInt) {\nreturn THROW('BigInt suffix is not supported on legacy octals; use the `0o` prefix notation for that', startForError, pointer + 1);\n}\n}\n}\nreturn 4108;\n}\nif (c === 0x2e) {\nparseFromFractionDot();\nreturn 4105;\n}\nif (((c === 0x78) || (c === 0x58))) {\nskip();\nreturn parseHex();\n}\nif (((c === 0x6F) || (c === 0x4F))) {\nskip();\nreturn parseOctal();\n}\nif (((c === 0x62) || (c === 0x42))) {\nskip();\nreturn parseBinary();\n}\nif (((c === 0x65) || (c === 0x45))) {\nparseExponentMaybe(c);\nreturn 4105;\n}\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12297;\n}\nreturn 4105;\n}\nfunction parseDecimal() {\nif (pointer >= len) {\nreturn 4105;\n}\nlet c = skipDigits();\nif (pointer >= len) {\nreturn 4105;\n}\nif (c === 0x2e) {\nparseFromFractionDot();\nverifyCharAfterNumber();\nreturn 4105;\n}\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer);\n}\nskip();\nverifyCharAfterNumber();\nreturn 12297;\n}\nparseExponentMaybe(c);\nverifyCharAfterNumber();\nreturn 4105;\n}\nfunction skipDigits() {\nlet c = cache;\nwhile (isAsciiNumber(c)) {\nskip();\nif (pointer >= len) return 0;\nc = cache;\n}\nreturn c;\n}\nfunction parseExponentMaybe(c) {\nif (((c !== 0x65) && (c !== 0x45))) return;\nif (eofd(1)) return;\nlet d = peekd(1);\nif (((d === 0x2d) || (d === 0x2b))) {\nif (eofd(2)) return;\nlet e = peekd(2);\nif (!isAsciiNumber(e)) return;\nskipFastWithoutUpdatingCache();\nskipFastWithoutUpdatingCache();\nskip();\nif (pointer >= len) return;\nskipDigits();\nreturn;\n}\nif (!isAsciiNumber(d)) return;\nskipFastWithoutUpdatingCache();\nskip();\nif (pointer >= len) return;\nskipDigits();\n}\nfunction parseFromFractionDot() {\nskip();\nif (pointer >= len) return;\nlet c = skipDigits();\nparseExponentMaybe(c);\n}\nfunction parseHex() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0x` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nlet cv = getHexValue(c);\nif (cv === 16) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0x` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4104;\nc = cache;\ncv = getHexValue(c);\nif (cv === 16) {\nbreak;\n}\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12296;\n}\nreturn 4104;\n}\nfunction parseOctal() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0o` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nif (!isOctal(c)) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0o` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4107;\nc = cache;\nif (!isOctal(c)) break;\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12299;\n}\nreturn 4107;\n}\nfunction parseBinary() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0b` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nif (!isBinary(c)) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0b` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4106;\nc = cache;\nif (!isBinary(c)) break;\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12297;\n}\nreturn 4106;\n}\nfunction isBinary(ord) {\nreturn ((ord === 0x30) || (ord === 0x31));\n}\nfunction parseExcl() {\nif (pointer >= len) return 16463;\nif ((cache === 0x3d)) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 82001;\n}\nreturn 82000;\n}\nreturn 16463;\n}\nfunction parseStar() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x2a) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49244;\n}\nreturn 82010;\n} else if (c === 0x3d) {\nskip();\nreturn 49243;\n}\n}\nreturn 82009;\n}\nfunction parseIdentRestNotKeywordObjTrie(d, n, start) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nfunction parsePotentialKeywordTrieMap(c) {\nlet trieObjlit = KEYWORD_TRIE_OBJLIT[c - 0x61];\nlet start = pointer - 1;\nlet n = start + 1;\ndo {\nif (n >= len) return eofAfterPotentialKeywordTrieMap(trieObjlit, n, start);\nlet d = input.charCodeAt(n++);\nif (((d < 0x61) || (d > 0x7a))) {\nreturn endOfPotentialKeywordTrieMap(trieObjlit, d, n, start);\n}\ntrieObjlit = trieObjlit[d - 0x61];\nif (trieObjlit === undefined) return parseIdentRestNotKeywordObjTrie(d, n, start);\n} while (true);\n}\nfunction endOfPotentialKeywordTrieMap(trieObjlit, d, n, start) {\nlet hit = trieObjlit.hit;\nif (d > 0x7e) {\npointer = n - 1;\ncache = d;\nlet wide = isIdentRestChr(d, n - 1);\nif (wide === (-1)) {\nlastCanonizedInputLen = (n - 1) - start;\nif (hit === undefined) {\nlastCanonizedInput = slice(start, n - 1);\nreturn 2048;\n}\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nlet s = getTokenStart(d);\nif (((((s === 2) || (s === 7))) || (s === 14))) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nif (s === 24) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nif (hit !== undefined) {\npointer = n - 1;\ncache = d;\nlastCanonizedInputLen = (n - 1) - start;\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nlastCanonizedInput = slice(start, n - 1);\nlastCanonizedInputLen = (n - 1) - start;\npointer = n - 1;\ncache = d;\nreturn 2048;\n}\nfunction eofAfterPotentialKeywordTrieMap(trieObjlit, n, start) {\npointer = n - 1;\nskip();\nlastCanonizedInputLen = n - start;\nlet hit = trieObjlit.hit;\nif (hit !== undefined) {\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nlastCanonizedInput = slice(start, n);\nreturn 2048;\n}\nfunction parseIdentifierRest(prevStr, prevLen) {\nlet start = pointer;\nwhile (pointer < len) {\nlet c = cache;\nlet s = getIdentPart(c);\nswitch (s) {\ncase 0:\nskip();\nbreak;\ncase 1:\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\ncase 2:\nlet x = prevStr + slice(start, pointer);\nlet xlen = prevLen + (pointer - start);\nskip();\nreturn parseIdentFromUnicodeEscape(false, x, xlen);\ncase 3:\nlet wide = isIdentRestChrUnicode(c, pointer);\nif (wide === (-1)) {\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\n}\nif (wide === (-3)) {\nskipFastWithoutUpdatingCache();\n}\nskip();\nbreak;\n;\n}\n}\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\n}\nfunction parseIdentFromUnicodeEscape(fromStart, prevStr, prevLen) {\nif (pointer >= len) {\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Encountered a backslash at end of input';\nreturn 2097175;\n}\nif (!(cache === 0x75)) {\nreturn THROW('Only unicode escapes are supported in identifier escapes', startForError, pointer + 1);\n}\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Reached end of input before closing the current ident escape';\nreturn 2097175;\n}\nlet r = parseUnicodeEscapeForNonRegex();\nif (r === 0x110000) {\nparseIdentifierRest(prevStr, prevLen);\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Only _unicode_ escapes are supported in identifiers';\nreturn 2097175;\n}\nif (r > 0xffff) {\nprevStr += String.fromCodePoint(r);\nprevLen += 2;\n} else {\nprevStr += String.fromCharCode(r);\n++prevLen;\n}\nif (((fromStart === true) && (isIdentStart(r, -1) !== (-1)))) {\nreturn parseIdentifierRest(prevStr, prevLen);\n}\nif (((fromStart === false) && (isIdentRestChr(r, -1) !== (-1)))) {\nreturn parseIdentifierRest(prevStr, prevLen);\n}\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Identifier escape did not yield a valid identifier character';\nreturn 2097175;\n}\nfunction toStringExpensive(c) {\nreturn String.fromCodePoint(c);\n}\nfunction isIdentStart(c, offsetOfC) {\nif (c > 0x7e) {\nreturn veryExpensiveUnicodeCheck(c, offsetOfC, getIdStartRegexSuperSlow());\n}\nlet s = getTokenStart(c);\nif (((s === 2) || (s === 3))) return -2;\nreturn -1;\n}\nfunction isIdentRestChr(c, offsetOfC) {\nif (c > 0x7e) {\nreturn isIdentRestChrUnicode(c, offsetOfC);\n}\nlet s = getTokenStart(c);\nif (((s === 2) || (s === 3))) return -2;\nif (s === 7) return -2;\nif (s === 14) return -2;\nreturn -1;\n}\nfunction isIdentRestChrUnicode(c, offsetOfC) {\nif (((c === 0x200C) || (c === 0x200D))) return -2;\nreturn veryExpensiveUnicodeCheck(c, offsetOfC, getIdRestRegexSuperSlow());\n}\nfunction veryExpensiveUnicodeCheck(c, offset, regexScanner) {\nif (offset !== (-1)) {\nc = input.codePointAt(offset);\n}\nlet s = String.fromCodePoint(c);\nif (regexScanner.test(s)) {\nreturn ((s.length === 1)? (-2) : (-3));\n}\nreturn -1;\n}\nfunction isAsciiLetter(c) {\nlet d = c | 32;\nreturn ((d >= 0x61) && (d <= 0x7a));\n}\nfunction isAsciiNumber(c) {\nreturn ((c >= 0x30) && (c <= 0x39));\n}\nfunction parseCompoundAssignment(c) {\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nif (c === 0x5e) return 49280;\nreturn 49235;\n}\nif (c === 0x5e) return 82047;\nreturn 82002;\n}\nfunction parseFwdSlash(lexerFlags) {\nif (pointer >= len) return 82023;\nlet c = cache;\nif (c === 0x2f) {\nskip();\nreturn parseCommentSingle();\n}\nif (c === 0x2a) {\nreturn parseCommentMulti();\n}\nif ((lexerFlags & 4) === 4) {\nreturn parseRegex(c);\n}\nif (c === 0x3d) {\nskip();\nreturn 49256;\n}\nreturn 82023;\n}\nfunction parseCommentSingle() {\nwhile (pointer < len) {\nlet c = cache;\nif (((c === 0x0D) || isLfPsLs(c))) {\nreturn 1285;\n}\nskip();\n}\nreturn 1285;\n}\nfunction parseCommentMulti() {\nskip();\nlet c = 0;\nwhile (pointer < len) {\nc = cache;\nskip();\nwhile (c === 0x2a) {\nif (pointer >= len) break;\nc = cache;\nskip();\nif (c === 0x2f) {\nreturn 1286;\n}\n}\nif (c === 0x0D) {\nif ((pointer < len && (cache === 0x0A))) skip();\nincrementLine();\n} else if (isLfPsLs(c)) {\nincrementLine();\n}\n}\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed multi line comment, early eof';\nreturn 2097175;\n}\nfunction parseCommentHtmlOpen() {\nparseCommentSingle();\nreturn 1287;\n}\nfunction parseCommentHtmlClose() {\nparseCommentSingle();\nreturn 1287;\n}\nfunction parseEqual() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 82034;\n}\nreturn 82033;\n} else if (c === 0x3e) {\nskip();\nreturn 16499;\n}\n}\nreturn 49264;\n}\nfunction parseLt() {\nif (((((((((((parsingGoal === false) && (webCompat === true))) && (!eofd(3)))) && (cache === 0x21))) && (peekd(1) === 0x2d))) && (peekd(2) === 0x2d))) {\nreturn parseCommentHtmlOpen();\n}\nreturn parseLtPunctuator();\n}\nfunction parseLtPunctuator() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nreturn 82029;\n}\nif (c === 0x3c) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49262;\n}\nreturn 82028;\n}\n}\nreturn 82027;\n}\nfunction parseGtPunctuator() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nreturn 82039;\n}\nif (c === 0x3e) {\nskip();\nif (pointer < len) {\nc = cache;\nif (c === 0x3d) {\nskip();\nreturn 49272;\n}\nif (c === 0x3e) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49273;\n}\nreturn 82038;\n}\n}\nreturn 82037;\n}\n}\nreturn 82036;\n}\nfunction parseNewlineSolo() {\nincrementLine();\nreturn 771;\n}\nfunction parseBackslash() {\nreturn parseIdentFromUnicodeEscape(true, '', 0);\n}\nfunction parseQmark() {\nif (pointer >= len) return 16506;\nif ((cache === 0x3f)) {\nskip();\nif (supportNullishCoalescing) {\nreturn 82044;\n}\nreturn THROW('The nullish coalescing operator (`??`) is only supported since ES2020, currently targeting a lower version', pointer - 2, pointer);\n}\nif ((cache === 0x2e)) {\nif (neofd(1)) {\nlet c = peekd(1);\nif (((c >= 0x30) && (c <= 0x39))) {\nreturn 16506;\n}\n}\nskip();\nif (supportOptionalChaining) {\nreturn 82043;\n}\nreturn THROW('The optional chaining operator (`?.`) is only supported since ES2020, currently targeting a lower version', pointer, pointer + 2);\n}\nreturn 16506;\n}\nfunction regexSyntaxError(desc, ...rest) {\nif (lastReportableLexerError) {\nreturn 4;\n}\nupdateRegexPotentialError(desc + ((rest.length? (': [' + rest.join(', ')) + ']' : '')));\nlastReportableLexerError = 'Regex: ' + lastPotentialRegexError;\nreturn 4;\n}\nfunction updateRegexPotentialError(msg) {\nif (!lastPotentialRegexError.includes(msg)) {\nif (lastPotentialRegexError) lastPotentialRegexError += '; ';\nlastPotentialRegexError += msg;\n}\n}\nfunction updateRegexUflagIsIllegal(state, reason) {\nreturn updateRegexUflagState(state, 2, reason);\n}\nfunction updateRegexUflagIsMandatory(state, reason) {\nreturn updateRegexUflagState(state, 1, reason);\n}\nfunction updateRegexUflagState(currentState, newState, error) {\nif (lastReportableLexerError) return 4;\nif (currentState === (((newState === 1)? 2 : 1))) {\nreturn regexSyntaxError(error);\n}\nif (currentState === 0) {\nupdateRegexPotentialError(error);\ncurrentState = newState;\n} else {\n\n}\nreturn currentState;\n}\nlet nCapturingParens = 0;\nlet largestBackReference = 0;\nlet declaredGroupNames = ',';\nlet reffedGroupNames = ',';\nlet kCharClassEscaped = false;\nlet foundInvalidGroupName = false;\nfunction parseRegex(c) {\nnCapturingParens = 0;\nlargestBackReference = 0;\nlastPotentialRegexError = '';\ndeclaredGroupNames = ',';\nreffedGroupNames = ',';\nkCharClassEscaped = false;\nfoundInvalidGroupName = false;\nlet ustatusBody = parseRegexBody(c);\nif (ustatusBody === 4) {\nreturn 2097175;\n}\nlet ustatusFlags = parseRegexFlags();\nif (nCapturingParens < largestBackReference) {\nlet errmsg = 'Largest back reference index exceeded the number of capturing groups (only valid without u-flag in webcompat mode)';\nif (webCompat === false) {\nregexSyntaxError(errmsg);\nreturn 2097175;\n}\nustatusBody = updateRegexUflagIsIllegal(ustatusBody, errmsg);\n}\nif (ustatusFlags === 4) {\nreturn 2097175;\n}\nif (kCharClassEscaped) {\nif (declaredGroupNames !== ',') {\nregexSyntaxError('Found `\\\\k` in a char class but the regex also had a group name so this is illegal');\nreturn 2097175;\n}\nif (((webCompat === false) || (ustatusFlags === 1))) {\nregexSyntaxError('Found `\\\\k` in a char class but this is only allowed in webcompat mode and without u-flag');\nreturn 2097175;\n}\n}\nif (((reffedGroupNames !== ',') && (((webCompat === false) || (declaredGroupNames !== ','))))) {\nlet bad = false;\nreffedGroupNames.split(',').filter(Boolean).forEach(name => {\nif (!declaredGroupNames.includes((',' + name) + ',')) {\nregexSyntaxError(('Found a `\\\\k` that referenced `' + name) + '` but no capturing group had this name');\nbad = true;\n}\n});\nif (bad) {\nreturn 2097175;\n}\n}\nif (ustatusBody === 1) {\nif (ustatusFlags === 1) return 262158;\nregexSyntaxError('Regex contained syntax that is only valid with the u-flag but the u-flag was not present');\nreturn 2097175;\n}\nif (ustatusBody === 2) {\nif (ustatusFlags !== 1) return 262157;\nregexSyntaxError('Regex contained syntax that is invalid with the u-flag but the u-flag was present');\nreturn 2097175;\n}\nif (ustatusFlags === 1) return 262158;\nreturn 262157;\n}\nfunction parseRegexBody(c) {\nreturn _parseRegexBody(c, 0, 0);\n}\nfunction cannotBeQuantifier(c, uflagStatus, webcompatException, msg) {\nlet badStart = ((((((c === 0x2a) || (c === 0x2b))) || (c === 0x3f))) || (c === 0x7b));\nif (badStart) {\nmsg += (' (by a `' + String.fromCharCode(c)) + '`)';\nif ((webcompatException && (webCompat === true))) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, msg);\n} else {\nuflagStatus = regexSyntaxError(msg);\n}\n}\nreturn uflagStatus;\n}\nfunction _parseRegexBody(c, groupLevel, uflagStatus) {\nlet afterAtom = false;\nuflagStatus = cannotBeQuantifier(c, uflagStatus, c === 0x7b, 'Started with a quantifier but that is not allowed');\nlet groupNames = {};\ndo {\nlet s = ((c > 0x7e)? 11 : regexAtomJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\nafterAtom = true;\nbreak;\ncase 1:\nskip();\nafterAtom = true;\nbreak;\ncase 2:\nskip();\nif (afterAtom) {\nafterAtom = false;\nif (pointer < len) {\nif ((cache === 0x3f)) {\nskip();\n}\n}\n} else {\nuflagStatus = regexSyntaxError(('Encountered unescaped quantifier (ord=' + c) + ') without a value to quantify');\n}\nbreak;\ncase 3:\nlet wasFixableAssertion = false;\nlet wasUnfixableAssertion = false;\nskip();\nafterAtom = false;\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (c === 0x3f) {\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (((((((c === 0x3a) || (c === 0x3d))) || (c === 0x21))) || (c === 0x3c))) {\nif (c === 0x3c) {\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (((c === 0x3d) || (c === 0x21))) {\nif (!supportRegexLookbehinds) {\nreturn THROW('Lookbehinds in regular expressions are not supported in the currently targeted language version', startForError, pointer + 1);\n}\nskip();\nwasUnfixableAssertion = true;\n} else if (!supportRegexNamedGroups) {\nskip();\nreturn regexSyntaxError(('The lookbehind group `(?<` must be `(?<=` or `(?<!` because named groups are not supported in the currently targeted ES version, next char after `<` is `' + String.fromCharCode(c)) + '`');\n} else {\nuflagStatus = parseRegexGroupName(c, uflagStatus, true);\n++nCapturingParens;\n}\n} else if (((c === 0x3d) || (c === 0x21))) {\nskip();\nwasFixableAssertion = true;\n}\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\n} else {\nreturn regexSyntaxError(('Illegal character after pseudo group marker `(?` [ord=' + c) + ']');\n}\n} else {\n++nCapturingParens;\n}\nlet subbad = _parseRegexBody(c, groupLevel + 1, 0);\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif ((wasFixableAssertion || wasUnfixableAssertion)) {\nuflagStatus = cannotBeQuantifier(c, uflagStatus, !wasUnfixableAssertion, 'Regex A-ssertion \"atoms\" can not be quantified (so things like `^`, `$`, and `(?=` can not have `*`, `+`, `?`, or `{` following it)');\n}\nafterAtom = true;\nif (subbad === 4) {\nuflagStatus = 4;\n} else if (subbad === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (subbad === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n}\nbreak;\ncase 4:\nskip();\nif (groupLevel > 0) return uflagStatus;\nreturn regexSyntaxError('Found unescaped closing paren `)` without a group being open');\ncase 5:\nlet charClassEscapeStatus = parseRegexCharClass();\nif (charClassEscapeStatus === 4) {\nuflagStatus = 4;\n} else if (charClassEscapeStatus === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (charClassEscapeStatus === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n}\nafterAtom = true;\nbreak;\ncase 6:\n{\nskip();\nlet reason = 'Encountered unescaped closing square bracket `]` while not parsing a character class, which is only valid without u-flag';\nif (webCompat === false) {\nreturn regexSyntaxError(reason);\n}\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, reason);\nafterAtom = true;\nbreak;\n}\ncase 7:\n{\nskip();\nafterAtom = true;\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF');\n}\nlet d = cache;\nif (((d === 0x62) || (d === 0x42))) {\nskip();\nafterAtom = false;\n} else {\nlet escapeStatus = parseEscapeForRegexAtom(d);\nif (escapeStatus === 4) {\nuflagStatus = 4;\n} else if (escapeStatus === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (escapeStatus === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n} else if (escapeStatus === 8) {\nafterAtom = false;\n}\n}\n}\nbreak;\ncase 8:\nif (groupLevel !== 0) {\nreturn regexSyntaxError('Unclosed group');\n}\nskip();\nreturn uflagStatus;\ncase 9:\nskip();\nafterAtom = false;\nbreak;\ncase 10:\nskip();\nif (pointer < len) {\nc = cache;\nuflagStatus = cannotBeQuantifier(c, uflagStatus, c === 0x7b, 'Regex `A-ssertion` \"atoms\" can not be quantified but this `$` was quantified anyways');\n}\nafterAtom = false;\nbreak;\ncase 11:\nif (((c === 0x2028) || (c === 0x2029))) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nskip();\nafterAtom = true;\nbreak;\ncase 12:\n{\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF at the start of a regex quantifier');\n}\nlet c = cache;\nlet validBrace = (isAsciiNumber(c)? parseRegexCurlyQuantifier(c) : 3);\nif (validBrace === 1) {\nif (afterAtom) {\nafterAtom = false;\nif ((pointer < len && (cache === 0x3f))) {\nskip();\n}\nbreak;\n}\nreturn regexSyntaxError('A valid bracket quantifier requires an unqualified atom, but that was not the case');\n}\nif (validBrace === 2) {\nreturn regexSyntaxError('Parsed a braced quantifier that contained an illegal range (left>right)');\n}\nif (pointer >= len) return regexSyntaxError('Encountered EOF while parsing curly quantifier');\nif (webCompat === false) {\nif ((cache === 0x2c)) {\nreturn regexSyntaxError('The first digit of a regex curly quantifier is mandatory');\n}\nif ((cache === 0x7d)) {\nreturn regexSyntaxError('A regex curly quantifier had no content');\n}\nreturn regexSyntaxError('Found an unescaped `{` that was not the start of a valid quantifier');\n}\nafterAtom = true;\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, 'Found an unescaped `{` that was not the start of a valid quantifier');\nbreak;\n}\ncase 13:\n{\nskip();\nlet reason = 'Encountered unescaped closing curly `}` while not parsing a quantifier';\nif (webCompat === false) {\nreturn regexSyntaxError(reason);\n}\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, reason);\nafterAtom = true;\nbreak;\n}\ncase 14:\nskip();\nafterAtom = false;\nbreak;\ncase 15:\nreturn regexSyntaxError('Encountered early EOF');\n;\n}\nif (pointer >= len) break;\nc = cache;\n} while (true);\nreturn regexSyntaxError('Found EOF before regex was closed');\n}\nfunction parseRegexGroupName(c, uflagStatus, forCapturing) {\nlet r = _parseRegexGroupName(c, uflagStatus, forCapturing);\nif (!foundInvalidGroupName) return r;\nif (forCapturing === true) {\nreturn regexSyntaxError('An invalid name for a capturing group can never lead to a valid regex');\n}\nkCharClassEscaped = true;\nreturn r;\n}\nfunction _parseRegexGroupName(c, uflagStatus, forCapturing) {\nif (c === 0x3e) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nif (webCompat === true) {\nreffedGroupNames += '<>,';\nreturn updateRegexUflagIsIllegal(uflagStatus, 'Group name is not optional without webcompat, found empty `<>`');\n}\nreturn regexSyntaxError('Group name is not optional, found empty `<>`');\n}\nlet pointerStart = pointer;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nlet first = true;\nlet lastPointer = 0;\nwhile (((((c !== 0x3e) && (uflagStatus !== 4))) && (lastPointer !== pointer))) {\nlastPointer = pointer;\nif (c === 0x5c) {\nuflagStatus = _parseRegexGroupNameEscape(first, uflagStatus, forCapturing);\n} else {\nuflagStatus = _parseRegexGroupNameChar(first, c, uflagStatus, forCapturing);\n}\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn regexSyntaxError('Missing closing angle bracket of name of capturing group');\n}\nc = cache;\nfirst = false;\n}\nif (uflagStatus === 4) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn 4;\n}\nif (lastPointer === pointer) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn 2;\n}\nlastCanonizedInputLen = lastCanonizedInput.length;\nskip();\nif (lastCanonizedInputLen > 0) {\nlet next = lastCanonizedInput + ',';\nif (forCapturing === true) {\nif (declaredGroupNames.includes(',' + next)) {\nTHROW(('This group name (`' + lastCanonizedInput) + '`) was already used before', pointerStart, pointer - 1);\n}\ndeclaredGroupNames += next;\n} else {\nreffedGroupNames += next;\n}\n}\nreturn uflagStatus;\n}\nfunction _parseRegexGroupNameChar(start, c, uflagStatus, forCapturing) {\nlet wide = (start? isIdentStart(c, pointer) : isIdentRestChr(c, pointer));\nif (wide === (-2)) {\nskip();\nlastCanonizedInput += String.fromCharCode(c);\nreturn uflagStatus;\n}\nif (wide === (-1)) {\nfoundInvalidGroupName = true;\nif (((webCompat === false) || (forCapturing === true))) {\nreturn regexSyntaxError(('Tried to parse the name for a capturing group but it contained at least one invalid ident char (`' + String.fromCharCode(c)) + '`)');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, ('Tried to parse the name for a capturing group but it contained at least one invalid ident char (`' + String.fromCharCode(c)) + '`)');\n}\nskipFastWithoutUpdatingCache();\nskip();\nlastCanonizedInput += String.fromCodePoint(c);\nif (forCapturing === true) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'The start of the name of a capturing group had a surrogate pair and is therefor only valid with u-flag');\n}\nif (webCompat === false) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'The start of a `\\\\k` group name had a surrogate pair and is therefor only valid with u-flag');\n}\nreturn uflagStatus;\n}\nfunction _parseRegexGroupNameEscape(start, uflagStatus, forCapturing) {\nskip();\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Found EOF at start of a group name identifier');\n}\nif (!(cache === 0x75)) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Found invalid escape character at the start of a group name identifier');\n}\nskip();\nif (pointer >= len) {\nreturn updateRegexUflagIsIllegal(0, 'Unexpected EOF while parsing unicode escape');\n}\nlet c = cache;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nuflagStatus = updateRegexUflagIsMandatory(0, 'Found a unicode ruby escape which is only valid with u-flag');\n} else {\nc = parseUnicodeQuadEscape(c, false);\nif (((c > 0xffff) && (forCapturing === true))) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, 'The name of a capturing group contained a double unicode quad escape which is valid as a surrogate pair which requires u-flag and which cannot be made valid without u-flag');\n}\n}\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Early EOF while parsing a group name');\n}\nif (c === 0x110000) {\nfoundInvalidGroupName = true;\nif (((webCompat === false) || (forCapturing === true))) {\nreturn regexSyntaxError('Regex contained a group name with invalid unicode escape');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, 'The name of a `\\\\k` escape contained a broken unicode ruby escape and this can not lead to a valid regex with u-flag');\n}\nlet firstCharStr = toStringExpensive(c);\nlastCanonizedInput += firstCharStr;\nlet wide = (start? isIdentStart(c, -1) : isIdentRestChr(c, -1));\nif (wide === (-2)) {\nreturn uflagStatus;\n}\nif (wide === (-3)) {\nif (forCapturing === true) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'Found a codepoint in a capturing group name that requires the u-flag to be considered valid');\n}\nif (webCompat === false) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'Found a codepoint in a `\\\\k` escape group name that requires the u-flag to be considered valid');\n}\nreturn uflagStatus;\n}\nif (forCapturing === true) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Encountered invalid unicode escape inside the group name of a capturing group, this cannot be valid');\n}\nif (webCompat === false) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Encountered invalid unicode escape inside the group name of a `\\\\k` escape, this can not become valid without web compat mode');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, 'Encountered invalid unicode escape inside the group name of a `\\\\k` escape, this is invalid with u-flag');\n}\nfunction parseEscapeForRegexAtom(c) {\nlet s = ((c > 0x7e)? 4 : regexAtomEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\nreturn 0;\ncase 2:\nskip();\nreturn parseUnicodeEscapeForRegexAtom();\ncase 3:\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing hex escape');\n}\nlet a = cache;\nlet va = getHexValue(a);\nif (va === 16) {\nlet reason = 'First char of hex escape not a valid digit';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\n}\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing hex escape');\n}\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) {\nlet reason = 'Second char of hex escape not a valid digit';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\n}\nskip();\nreturn 0;\ncase 1:\nskip();\nreturn updateRegexUflagIsIllegal(0, 'Atoms can only escape certain non-special chars without u-flag');\ncase 4:\nlet wide = isIdentRestChr(c, pointer);\nif (wide === (-3)) {\nc = input.codePointAt(pointer);\nskipFastWithoutUpdatingCache();\nskip();\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot use a surrogate pair as atom escape (' + c) + ', `') + String.fromCodePoint(c)) + '`)');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\n}\nif (wide === (-2)) {\nskip();\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot escape this regular identifier character [ord=' + c) + '][') + String.fromCharCode(c)) + ']');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\n}\n;\nskip();\nif (((c === 0x2028) || (c === 0x2029))) {\nreturn regexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\n}\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot escape this non-identifier character [ord=' + c) + '][') + String.fromCharCode(c)) + ']');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\ncase 5:\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing char escape');\n}\nlet d = cache;\nif (isAsciiLetter(d)) {\nskip();\nreturn 0;\n}\nlet reason = ('Illegal char escape char (ord=' + d) + ')';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\ncase 6:\nconst FROM_ATOM = false;\nreturn parseRegexPropertyEscape(c, FROM_ATOM);\ncase 7:\nskip();\nif (pointer >= len) return 0;\nif (isAsciiNumber(cache)) {\nlet reason = 'Back references can not have more two or more consecutive numbers';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n} else {\nreturn regexSyntaxError(reason);\n}\n}\nreturn 0;\ncase 8:\nreturn parseRegexDecimalEscape(c);\ncase 9:\n{\nlet uflagStatus = 0;\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing `\\\\k` escape in regex character class');\nc = cache;\nif (c !== 0x3c) {\nkCharClassEscaped = true;\nlet reason = 'Named back reference \\\\k; missing group name';\nif (webCompat === false) {\nreturn regexSyntaxError(reason, c);\n}\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing `\\\\k` escape in regex character class');\nc = cache;\nuflagStatus = parseRegexGroupName(c, uflagStatus, false);\nreturn uflagStatus;\n}\ncase 10:\nskip();\nreturn regexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\ncase 11:\nskip();\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain letters without u-flag');\n}\nreturn regexSyntaxError(('Cannot escape this letter [' + String.fromCharCode(c)) + ']');\n;\n}\n}\nfunction parseRegexDecimalEscape(c) {\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing decimal escape in regex');\nlet d = cache;\nif (((d >= 0x30) && (d <= 0x39))) {\nskip();\nlet e = cache;\nif (((e >= 0x30) && (e <= 0x39))) {\nlet reason = 'Parsed too many digits';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n} else {\nreturn regexSyntaxError(reason);\n}\n} else {\nlargestBackReference = Math.max(largestBackReference, ((c - 0x30) * 10) + (d - 0x30));\n}\n} else {\nlargestBackReference = Math.max(largestBackReference, c - 0x30);\n}\nreturn 0;\n}\nfunction parseRegexCharClass() {\nskip();\nlet prev = 0;\nlet surrogate = 0;\nlet isSurrogate = false;\nlet isSurrogateHead = false;\nlet wasSurrogate = true;\nlet wasSurrogateHead = false;\nlet urangeOpen = false;\nlet urangeLeft = -1;\nlet nrangeOpen = false;\nlet nrangeLeft = -1;\nlet flagState = 0;\nif (pointer >= len) return regexSyntaxError('Encountered early EOF while parsing char class (1)');\nlet c = cache;\nif (c === 0x5e) {\nskip();\nif (pointer >= len) return regexSyntaxError('Encountered early EOF while parsing char class (2)');\nc = cache;\n}\nwhile (c !== 0x5d) {\nlet wasEscape = false;\nlet wasDoubleQuad = false;\nlet wasBadUniEscape = false;\nlet wasPropEscape = false;\nlet wasPropOnly = false;\nlet wasBadPropEscape = false;\nlet wasRubyWebEscape = false;\nlet escapeCharUP = 0;\nif (c === 0x5c) {\nskip();\nwasEscape = true;\nif (pointer >= len) {\nregexSyntaxError('Early EOF after backslash in char class');\nreturn 0x110000;\n}\nc = cache;\nescapeCharUP = c;\nlet escapePointer = pointer;\nc = parseRegexCharClassEscape(c);\nif (escapeCharUP === 0x75) {\nif (c === 0x110000) {\nif (pointer >= len) return 0x110000;\nif (webCompat === false) return 0x110000;\nwasBadUniEscape = true;\nflagState = updateRegexUflagIsIllegal(flagState, 'A broken `\\\\u` escape can never be valid with u-flag');\nwasPropOnly = (pointer - escapePointer) === 1;\n} else if ((c & 67108864) > 0) {\nc ^= 67108864;\nwasRubyWebEscape = webCompat === true;\n} else if (c > 0xffff) {\nwasDoubleQuad = true;\n}\n} else if (((escapeCharUP === 0x70) || (escapeCharUP === 0x50))) {\nif (webCompat === true) {\nif (((((c === 0x110000) || (c === 34668544))) || ((c & 16777216) === 16777216))) {\nwasBadPropEscape = true;\n} else {\nwasPropEscape = true;\nwasPropOnly = (pointer - escapePointer) === 1;\n}\n}\n}\nif (c === 0x110000) {\nif (!wasBadUniEscape) {\nflagState = regexSyntaxError(lastPotentialRegexError);\n}\n} else if (c === 34668544) {\nflagState = regexSyntaxError(lastPotentialRegexError);\nc = 33554432;\n} else if (c === 33554432) {\n\n} else if (c === 0x110001) {\nif (webCompat === true) {\nflagState = updateRegexUflagIsIllegal(0, 'Char class can not contain `\\\\B`');\n} else {\nflagState = regexSyntaxError('Char class can not contain `\\\\B`');\n}\nc = 0x42;\n} else if (c === 0x110002) {\nflagState = updateRegexUflagIsIllegal(flagState, lastPotentialRegexError);\nc = 0x5c;\n} else {\nif (c & 16777216) {\nc = c ^ 16777216;\nflagState = updateRegexUflagIsIllegal(flagState, lastPotentialRegexError);\n}\nif (c & 8388608) {\nc = c ^ 8388608;\nflagState = updateRegexUflagIsMandatory(flagState, lastPotentialRegexError);\n}\n}\n} else if (((((((c === 0x0D) || (c === 0x0A))) || (c === 0x2028))) || (c === 0x2029))) {\nreturn regexSyntaxError('Encountered newline');\n} else {\nskip();\n}\nif (wasBadUniEscape) {\n\n} else if (wasEscape) {\nisSurrogate = c > 0xffff;\nif (isSurrogate) surrogate = c;\nisSurrogateHead = false;\n} else if ((wasSurrogateHead && isSurrogateTail(c))) {\nisSurrogate = true;\nisSurrogateHead = false;\nsurrogate = getSurrogate(prev, c);\n} else {\nisSurrogate = false;\nisSurrogateHead = isSurrogateLead(c);\n}\nif (urangeOpen) {\nlet urangeRight = (isSurrogate? surrogate : ((wasSurrogateHead? prev : c)));\nif (((urangeLeft === 33554432) || (urangeRight === 33554432))) {\nflagState = updateRegexUflagIsIllegal(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` not allowed in ranges with u');\n} else if (((!isSurrogateHead) || wasSurrogateHead)) {\nurangeOpen = false;\nif (urangeLeft > urangeRight) {\nflagState = updateRegexUflagIsIllegal(flagState, ((((((('Encountered incorrect range (left>right, ' + urangeLeft) + ' > ') + urangeRight) + ', 0x') + urangeLeft.toString(16)) + ' > 0x') + urangeRight.toString(16)) + ') which is illegal with u-flag');\n}\nurangeLeft = -1;\n} else {\n\n}\n} else if (((((c === 0x2d) && (!wasEscape))) && (urangeLeft !== (-1)))) {\nurangeOpen = true;\n} else {\nurangeLeft = (isSurrogate? surrogate : c);\n}\nlet cTmp = (((wasRubyWebEscape || wasPropEscape))? escapeCharUP : c);\nlet cTail = c;\nlet stillDataLeft = true;\nlet rubyHackLhs = (((wasRubyWebEscape || wasBadUniEscape)) || wasPropEscape);\nlet rubyHackRhsPeek = (wasBadUniEscape || ((wasBadPropEscape && (!wasPropOnly))));\nlet rubyHackRhsCurly = (wasRubyWebEscape || ((wasPropEscape && (!wasPropOnly))));\nwhile (stillDataLeft) {\nif (wasDoubleQuad) {\nwasDoubleQuad = false;\ncTail = codePointToSurrogateTail(cTmp);\ncTmp = codePointToSurrogateHead(cTmp);\n} else if (rubyHackLhs) {\nrubyHackLhs = false;\ncTmp = escapeCharUP;\nif (wasPropOnly) stillDataLeft = false;\n} else if (rubyHackRhsCurly) {\nrubyHackRhsCurly = false;\ncTmp = 0x7d;\nstillDataLeft = false;\n} else if (rubyHackRhsPeek) {\ncTmp = peekd(-1);\nrubyHackRhsPeek = false;\nstillDataLeft = false;\n} else {\nstillDataLeft = false;\ncTmp = cTail;\n}\nif (nrangeOpen) {\nconst nrangeRight = cTmp;\nif (((nrangeLeft === 33554432) || (nrangeRight === 33554432))) {\nif (webCompat === false) {\nflagState = updateRegexUflagIsMandatory(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` not allowed in ranges');\n}\n} else {\nif (nrangeLeft > nrangeRight) {\nflagState = updateRegexUflagIsMandatory(flagState, ((((((('Encountered incorrect range (left>right, ' + nrangeLeft) + ' > ') + nrangeRight) + ', 0x') + nrangeLeft.toString(16)) + ' > 0x') + nrangeRight.toString(16)) + ') when parsing as if without u-flag');\n}\n}\nnrangeLeft = -1;\nnrangeOpen = false;\n} else if (((((cTmp === 0x2d) && (!wasEscape))) && (nrangeLeft !== (-1)))) {\nnrangeOpen = true;\n} else {\nnrangeLeft = cTmp;\n}\n}\nwasSurrogate = isSurrogate;\nwasSurrogateHead = isSurrogateHead;\nprev = c;\nif (pointer >= len) {\nreturn regexSyntaxError('Unexpected early EOF while parsing character class');\n}\nc = cache;\n}\nskip();\nif ((urangeOpen && wasSurrogateHead)) {\nif (((urangeLeft === 33554432) || (prev === 33554432))) {\nreturn updateRegexUflagIsIllegal(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` are only ok as a range with webcompat, without uflag');\n}\nif (urangeLeft > prev) {\nreturn updateRegexUflagIsIllegal(flagState, ((((((('Encountered incorrect range end (left>right, ' + urangeLeft) + ' > ') + prev) + ', 0x') + urangeLeft.toString(16)) + ' > 0x') + prev.toString(16)) + ') which is illegal with u-flag');\n}\nreturn flagState;\n}\nreturn flagState;\n}\nfunction surrogateToCodepoint(head, tail) {\nreturn (((head & 0x3ff) << 10) | (tail & 0x3ff)) + 0x10000;\n}\nfunction codePointToSurrogateTail(codepoint) {\nreturn ((codepoint - 0x10000) & 0b1111111111) + 0xDC00;\n}\nfunction codePointToSurrogateHead(codepoint) {\nreturn ((codepoint - 0x10000) >> 10) + 0xD800;\n}\nfunction parseRegexCharClassEscape(c) {\nlet s = ((c >= 0x7f)? 1 : regexClassEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\n;\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class with the u-flag');\nreturn c | 16777216;\n}\nif (isIdentRestChr(c, pointer) === (-1)) {\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class with the u-flag');\nreturn c | 16777216;\n}\n;\nregexSyntaxError(('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class');\nreturn 0x110000;\ncase 1:\n{\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a char class with the u-flag');\nif (webCompat === true) {\nskip();\nreturn c | 16777216;\n}\nlet wide = isIdentRestChr(c, -1);\nif (wide === (-2)) {\nregexSyntaxError(('Cannot escape `' + String.fromCodePoint(c)) + '` in a char class');\nreturn 0x110000;\n}\nif (((c === 0x2028) || (c === 0x2029))) {\nskip();\nregexSyntaxError('Regular expressions do not support line continuations (escaped x2028 x2029)');\nreturn 0x110000;\n}\nskip();\nreturn c | 16777216;\n}\ncase 2:\nskip();\nreturn parseUnicodeEscapeForRegexCharClass();\ncase 3:\nskip();\nif (eofd(1)) {\nregexSyntaxError('Found EOF before completely parsing a hex escape (in a char class of a regex)');\nreturn 0x110000;\n}\nlet a = cache;\nlet va = getHexValue(a);\nif (va === 16) {\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, 'First character of hex escape was invalid');\nreturn 16777336;\n}\nregexSyntaxError('First character of hex escape was invalid');\nreturn 0x110000;\n}\nskip();\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) {\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, 'Second character of hex escape was invalid');\nreturn 16777336;\n}\nregexSyntaxError('Second character of hex escape was invalid');\nreturn 0x110000;\n}\nskip();\nreturn (va << 4) | vb;\ncase 4:\n{\nskip();\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing `\\\\c` in a character class');\nreturn 0x110000;\n}\nlet d = cache;\nif (isAsciiLetter(d)) {\nskip();\nreturn d % 32;\n}\nlet reason = 'The `\\\\c` escape is only legal in a char class without u-flag and in webcompat mode';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn 0x110002;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\ncase 5:\nskip();\nif (webCompat === true) {\nkCharClassEscaped = true;\nupdateRegexUflagIsIllegal(0, 'Can only have `\\\\k` in a char class without u-flag and in webcompat mode');\nreturn 16777323;\n}\nregexSyntaxError('A character class is not allowed to have `\\\\k` back-reference');\nreturn 0x110000;\ncase 6:\nskip();\nreturn 8;\ncase 7:\n{\nskip();\nreturn 0x110001;\n}\ncase 8:\nskip();\nreturn 0x000C;\ncase 9:\nskip();\nreturn 0x000A;\ncase 10:\nskip();\nreturn 0x000D;\ncase 11:\nskip();\nreturn 0x0009;\ncase 12:\nskip();\nreturn 0x000B;\ncase 13:\nskip();\nreturn 33554432;\ncase 14:\nconst FROM_CHARCLASS = true;\nlet regexPropState = parseRegexPropertyEscape(c, FROM_CHARCLASS);\nif (regexPropState === 4) {\nreturn 34668544;\n}\nif (regexPropState === 2) {\nreturn 50331648;\n}\nif (regexPropState === 1) {\nreturn 41943040;\n}\n;\n;\nreturn 33554432;\ncase 15:\n{\nskip();\nif ((pointer < len && isAsciiNumber(cache))) {\nlet reason = 'An escaped zero cannot be followed by another number because that would be an octal escape';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn parseOctalFromSecondDigit(c) | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\nreturn 0;\n}\ncase 16:\n{\nskip();\nlet reason = 'A character class is not allowed to have numeric back-reference';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn parseOctalFromSecondDigit(c) | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\ncase 17:\nskip();\nreturn parseDecimalEscape(c);\ncase 18:\nskip();\nreturn c;\ncase 19:\n{\nskip();\nif (webCompat === true) {\nreturn 0x2d;\n}\nupdateRegexUflagIsMandatory(0, 'Escaping a dash in a char class is not allowed');\nreturn 8388653;\n}\ncase 20:\nskip();\nregexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\nreturn 0x110000;\n;\n}\n}\nfunction parseRegexPropertyEscape(c, fromCharClass) {\nif (!supportRegexPropertyEscapes) {\nlet uflagState = updateRegexUflagIsIllegal(0, 'Property escapes are not supported by the currently targeted language version');\nif (webCompat === true) return uflagState;\nreturn updateRegexUflagIsMandatory(uflagState, 'Cannot escape `\\\\p` without u-flag');\n}\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF after a regex `\\\\p`');\nif (cache !== 0x7b) {\nif (webCompat === true) return updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` must start with a curly bracket');\nreturn regexSyntaxError('Property escape `\\\\p` must start with a curly bracket');\n}\nc = skipPeek();\nlet pointerOffset = pointer;\nlet name = '';\nlet sawCommas = 0;\nlet hasEq = false;\nlet value = '';\ndo {\nif (((((((c >= 0x61) && (c <= 0x7a))) || (((c >= 0x41) && (c <= 0x5a))))) || (c === 0x5f))) {\n\n} else if (c === 0x7d) {\nbreak;\n} else if (c === 0x3d) {\nif (pointerOffset === pointer) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn regexSyntaxError('Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nif (hasEq) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` contained double equal sign, which is not valid');\n}\nreturn regexSyntaxError('Property escape `\\\\p` contained double equal sign, which is not valid');\n}\nhasEq = true;\nname = slice(pointerOffset, pointer);\npointerOffset = pointer + 1;\n} else {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nreturn regexSyntaxError(('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nc = skipPeek();\nif (pointer >= len) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Encountered early EOF while parsing `\\\\p` property escape');\n}\nreturn regexSyntaxError('Encountered early EOF while parsing `\\\\p` property escape');\n}\n} while (true);\nif (pointerOffset === pointer) {\nif (webCompat === true) {\nif (hasEq) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn updateRegexUflagIsIllegal(0, ('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nif (hasEq) {\nreturn regexSyntaxError('Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn regexSyntaxError(('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nif (hasEq) value = slice(pointerOffset, pointer); else name = slice(pointerOffset, pointer);\nlet nc = (',' + name) + ',';\nif (hasEq) {\nif (!TABLE_NONBIN_UNI_PROPS.includes(nc)) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The `\\\\p` escaped binary property name `' + name) + '` is not valid (does not appear in \"table-nonbinary-unicode-properties\")');\n}\nreturn regexSyntaxError(('The `\\\\p` escaped binary property name `' + name) + '` is not valid (does not appear in \"table-nonbinary-unicode-properties\")');\n}\nlet vc = (',' + value) + ',';\nif (((!TABLE_GEN_CAT_VALUES.includes(vc)) && (!TABLE_SCRIPT_VALUES.includes(vc)))) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The escaped property value `' + value) + '` is not valid (does not appear in \"table-unicode-general-category-values\" nor \"table-unicode-script-values\")');\n}\nreturn regexSyntaxError(('The escaped property value `' + value) + '` is not valid (does not appear in \"table-unicode-general-category-values\" nor \"table-unicode-script-values\")');\n}\nskip();\nif (webCompat === true) {\nreturn 0;\n}\nreturn updateRegexUflagIsMandatory(0, 'The `\\\\p` property escape is only legal with a u-flag, or as a webcompat edge case');\n}\nif (((!TABLE_BIN_UNI_PROPS.includes(nc)) && (!TABLE_GEN_CAT_VALUES.includes(nc)))) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The escaped lone property name `' + name) + '` is not valid (does not appear in \"table-binary-unicode-properties\" nor \"table-unicode-general-category-values\")');\n}\nreturn regexSyntaxError(('The escaped lone property name `' + name) + '` is not valid (does not appear in \"table-binary-unicode-properties\" nor \"table-unicode-general-category-values\") with u-flag, and `\\\\p` is not valid without u-flag and without webcompat');\n}\nskip();\nif (webCompat === true) {\nreturn 0;\n}\nreturn updateRegexUflagIsMandatory(0, 'The `\\\\p` property escape is only legal with a u-flag, or as a webcompat edge case');\n}\nfunction parseRegexFlags() {\nlet g = 0;\nlet i = 0;\nlet m = 0;\nlet u = 0;\nlet y = 0;\nlet s = 0;\nwhile (pointer < len) {\nlet c = cache;\nswitch (c) {\ncase 0x67:\n++g;\nbreak;\ncase 0x69:\n++i;\nbreak;\ncase 0x6D:\n++m;\nbreak;\ncase 0x75:\n++u;\nbreak;\ncase 0x79:\n++y;\nbreak;\ncase 0x73:\nif (!supportRegexDotallFlag) {\nreturn THROW('The dotall flag `s` is not supported in the currently targeted language version', pointer, pointer);\n}\n++s;\nbreak;\ndefault:\nif ((isAsciiLetter(c) || (c === 0x5c))) {\nreturn regexSyntaxError(((('Unknown regex flag [ord=' + c) + ', `') + String.fromCharCode(c)) + '`)]');\n}\nif ((((((g | i) | m) | u) | y) | s) > 1) {\nreturn regexSyntaxError('Encountered at least one regex flag twice');\n}\nreturn ((u > 0)? 1 : 2);\n}\nskip();\n}\nif ((((((g | i) | m) | u) | y) | s) > 1) {\nreturn regexSyntaxError('Encountered at least one regex flag twice');\n}\nreturn ((u > 0)? 1 : 2);\n}\nfunction parseRegexCurlyQuantifier(c) {\nlet min = 0;\nwhile (isAsciiNumber(c)) {\nmin = (min * 10) + (c - 0x30);\nskip();\nif (pointer >= len) return 3;\nc = cache;\n}\nif (c !== 0x2c) {\nif (c !== 0x7d) return 3;\nskip();\nreturn 1;\n}\nskip();\nif (pointer >= len) return 3;\nc = cache;\nif (!isAsciiNumber(c)) {\nif (c !== 0x7d) return 3;\nskip();\nreturn 1;\n}\nlet max = 0;\ndo {\nmax = (max * 10) + (c - 0x30);\nskip();\nif (pointer >= len) return 3;\nc = cache;\n} while (isAsciiNumber(c));\nif (c !== 0x7d) return 3;\nskip();\nif (min <= max) return 1;\nreturn 2;\n}\nfunction isSurrogateLead(c) {\nreturn ((c >= 0xD800) && (c <= 0xDBFF));\n}\nfunction isSurrogateTail(c) {\nreturn ((c >= 0xDC00) && (c <= 0xDFFF));\n}\nfunction getSurrogate(c1, c2) {\nreturn (((c1 - 0xD800) * 0x400) + (c2 - 0xDC00)) + 0x10000;\n}\nfunction parseDecimalEscape(c) {\nlet reason = 'Cannot escape \\\\8 or \\\\9 in a regex char class with u-flag';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn c | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\nfunction parseOctalFromSecondDigit(firstChar) {\nif (pointer >= len) return firstChar - 0x30;\nlet secondChar = cache;\nif (isLowerOctal(firstChar)) {\nif (isOctal(secondChar)) {\nskip();\nif (pointer >= len) return ((firstChar - 0x30) * 8) + (secondChar - 0x30);\nlet thirdChar = cache;\nif (isOctal(thirdChar)) {\nskip();\nreturn ((((firstChar - 0x30) * 8) * 8) + ((secondChar - 0x30) * 8)) + (thirdChar - 0x30);\n}\nreturn ((firstChar - 0x30) * 8) + (secondChar - 0x30);\n}\nreturn firstChar - 0x30;\n}\nif (isOctal(secondChar)) {\nskip();\nif (pointer >= len) return ((firstChar - 0x30) * 8) + (secondChar - 0x30);\nlet thirdChar = cache;\nif (isLowerOctal(thirdChar)) {\nskip();\nreturn ((((firstChar - 0x30) * 8) * 8) + ((secondChar - 0x30) * 8)) + (thirdChar - 0x30);\n}\nreturn ((firstChar - 0x30) * 8) + (secondChar - 0x30);\n}\nreturn firstChar - 0x30;\n}\nfunction isOctal(c) {\nreturn ((c >= 0x30) && (c <= 0x37));\n}\nfunction isLowerOctal(c) {\nreturn ((c >= 0x30) && (c <= 0x33));\n}\nfunction isUpperOctal(c) {\nreturn ((c >= 0x34) && (c <= 0x37));\n}\nfunction parseUnicodeEscapeForNonRegex() {\nlet c = cache;\nif (c !== 0x7b) {\nreturn parseUnicodeQuadEscape(c, true);\n}\nreturn parseUnicodeRubyEscape();\n}\nfunction parseUnicodeEscapeForRegexAtom() {\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF while trying to parse unicode escape');\n}\nlet c = cache;\nlet wasRuby = false;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nwasRuby = true;\n} else {\nc = parseUnicodeQuadEscape(c, false);\n}\nif (pointer >= len) {\nreturn regexSyntaxError('EOF while trying to parse regex atom unicode escape');\n}\nif (c === 0x110000) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Error while trying to parse regex atom unicode escape');\n}\nreturn regexSyntaxError('Error while trying to parse regex atom unicode escape');\n}\nif ((wasRuby && (webCompat === false))) {\nreturn updateRegexUflagIsMandatory(0, 'A regex atom that is an unicode ruby escape is only legal with u-flag');\n}\nif ((((wasRuby && (webCompat === true))) && (!c.toString(16).match(/[a-z]/i)))) {\nif ((pointer < len && (cache === 0x3f))) {\nskip();\n}\nreturn 8;\n}\nreturn 0;\n}\nfunction parseUnicodeEscapeForRegexCharClass() {\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing a unicode escape in a regex char class');\nreturn 0x110000;\n}\nlet c = cache;\nlet wasQuad = true;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nwasQuad = false;\n} else {\nc = parseUnicodeQuadEscape(c, false);\n}\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing a unicode escape in a regex char class');\nreturn 0x110000;\n}\nif (c === 0x110000) {\nreturn 0x110000;\n}\nlet rubyWebException = false;\nif (!wasQuad) {\nif (webCompat === false) {\nupdateRegexUflagIsMandatory(0, 'Found a unicode ruby escape which is only valid with u-flag');\nrubyWebException = true;\n}\nc |= 67108864;\n}\nif (rubyWebException) return c | 8388608;\nreturn c;\n}\nfunction parseUnicodeQuadEscape(a, noDouble) {\nif (eofd(3)) {\nupdateRegexUflagIsIllegal(0, 'Unexpected EOF while parsing unicode quad escape');\nreturn 0x110000;\n}\nlet b = peekd(1);\nlet c = peekd(2);\nlet d = peekd(3);\nlet va = getHexValue(a);\nlet vb = getHexValue(b);\nlet vc = getHexValue(c);\nlet vd = getHexValue(d);\nif ((((va | vb) | vc) | vd) > 15) {\nupdateRegexPotentialError('Attempted to parse a unicode quad escape but at least one digit was not a hex');\nreturn 0x110000;\n}\nskip();\nskip();\nskip();\nskip();\nlet firstPart = (((va << 12) | (vb << 8)) | (vc << 4)) | vd;\nif ((((((((((noDouble || (firstPart < 0xD800))) || (firstPart > 0xDBFF))) || eofd(5))) || (cache !== 0x5c))) || (peekd(1) !== 0x75))) {\nreturn firstPart;\n}\nlet e = peekd(2);\nlet f = peekd(3);\nlet g = peekd(4);\nlet h = peekd(5);\nlet ve = getHexValue(e);\nlet vf = getHexValue(f);\nlet vg = getHexValue(g);\nlet vh = getHexValue(h);\nif ((((ve | vf) | vg) | vh) > 15) {\nreturn firstPart;\n}\nlet secondPart = (((ve << 12) | (vf << 8)) | (vg << 4)) | vh;\nif (((secondPart < 0xDC00) || (secondPart > 0xDFFF))) {\nreturn firstPart;\n}\nskip();\nskip();\nskip();\nskip();\nskip();\nskip();\nlet codepoint = surrogateToCodepoint(firstPart, secondPart);\nupdateRegexPotentialError('A double unicode quad escape that represents a surrogate pair in char class or group name is only valid with u-flag');\nreturn codepoint;\n}\nfunction parseUnicodeRubyEscape() {\nskip();\nlet c = parseUnicodeRubyEscapeBody();\nif (((((c === 0x110000) || pointer >= len)) || (!(cache === 0x7d)))) {\nreturn 0x110000;\n}\nskip();\nreturn c;\n}\nfunction parseUnicodeRubyEscapeBody() {\nif (pointer >= len) return 0x110000;\nlet a = cache;\nlet v = getHexValue(a);\nif (v === 16) return 0x110000;\nskip();\nreturn parseUnicodeRubyEscapeBody2(v);\n}\nfunction parseUnicodeRubyEscapeBody2(v) {\nif (v === 0) {\nif (pointer >= len) return 0x110000;\nlet c = skipZeroes();\nv = getHexValue(c);\nif (v === 16) {\nreturn 0;\n}\nskip();\n}\nreturn parseUnicodeRubyEscapeBody3(v);\n}\nfunction parseUnicodeRubyEscapeBody3(v) {\nif (pointer >= len) return 0x110000;\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody4((v << 4) + vb);\n}\nfunction parseUnicodeRubyEscapeBody4(v) {\nif (pointer >= len) return 0x110000;\nlet c = cache;\nlet vc = getHexValue(c);\nif (vc === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody5((v << 4) + vc);\n}\nfunction parseUnicodeRubyEscapeBody5(v) {\nif (pointer >= len) return 0x110000;\nlet d = cache;\nlet vd = getHexValue(d);\nif (vd === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody6((v << 4) + vd);\n}\nfunction parseUnicodeRubyEscapeBody6(v) {\nif (pointer >= len) return 0x110000;\nlet e = cache;\nlet ve = getHexValue(e);\nif (ve === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody7((v << 4) + ve);\n}\nfunction parseUnicodeRubyEscapeBody7(v) {\nif (pointer >= len) return 0x110000;\nlet f = cache;\nlet vf = getHexValue(f);\nif (vf === 16) return v;\nskip();\nlet r = (v << 4) + vf;\nif (r >= 0x110000) return 0x110000;\nreturn r;\n}\nfunction parseOtherUnicode(c) {\nswitch (c) {\ncase 0xA0:\nreturn parseSpace();\ncase 0xFEFF:\nreturn parseSpace();\ncase 0x2028:\nreturn parseNewlineSolo();\ncase 0x2029:\nreturn parseNewlineSolo();\ndefault:\nlet t = parseIdentUnicodeOrError(c);\nif (t !== 2097175) return t;\nreturn parseWhitespaceUnicodeOrError(c);\n}\n}\nfunction parseIdentUnicodeOrError(c) {\nlet cu = input.codePointAt(pointer - 1);\nlet wide = isIdentStart(cu, pointer - 1);\nif (wide !== (-1)) {\nif (wide === (-3)) skip();\nreturn parseIdentifierRest(String.fromCodePoint(cu), ((wide === (-3))? 2 : 1));\n}\nif (!lastReportableLexerError) lastReportableLexerError = ((('Unexpected unicode character: ' + c) + ' (') + String.fromCharCode(c)) + ')';\nreturn 2097175;\n}\nfunction parseWhitespaceUnicodeOrError(c) {\nreturn ([0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202F, 0x205F, 0x3000].includes(c)? 257 : 2097175);\n}\nfunction THROW(str, tokenStart, tokenStop) {\n$error('Throwing this error:', str);\n_THROW('Lexer error! ' + str, tokenStart, tokenStop);\n}\nfunction _THROW(str, tokenStart, tokenStop, msg = '', withCodeFrame = errorCodeFrame, fullCodeFrameLocal = truncCodeFrame) {\nlet ectxt = (withCodeFrame? getErrorContext(tokenStart, tokenStop, msg, fullCodeFrameLocal) : '');\nlet context = (('\\n`````\\n' + (((ectxt[ectxt.length - 1] !== '\\n')? '\\n' : ''))) + ectxt) + '`````\\n';\n$log('Error at:' + context);\nif (gracefulErrors === false) throw new Error(((str + '\\n') + ((withCodeFrame? '\\n' : ''))) + ectxt); else $error(str);\n}\nfunction getErrorContext(tokenStart, tokenStop, msg, truncCodeFrame = false) {\nlet inputOffset = 0;\nif ((truncCodeFrame && (tokenStart > 100))) inputOffset = tokenStart - 100;\nlet inputLen = input.length - inputOffset;\nif ((truncCodeFrame && ((tokenStop + 100) < input.length))) inputLen = (tokenStop + 100) - inputOffset;\nlet isPointerIncluded = true;\nif ((inputOffset + inputLen) < pointer) {\nlet len = pointer - inputOffset;\nif (len < 1024) {\ninputLen = len;\n} else {\nisPointerIncluded = false;\n}\n}\nlet usedInput = input.slice(inputOffset, inputOffset + inputLen);\nlet tokenOffset = tokenStart - inputOffset;\nlet nl1 = usedInput.lastIndexOf('\\n', tokenOffset);\nlet nl2 = usedInput.indexOf('\\n', nl1 + 1);\nif (nl2 < 0) nl2 = usedInput.length;\nlet arrowCount = ((tokenStop - tokenStart) || 1);\nlet indentCount = tokenOffset - (nl1 + 1);\nlet pointerLine = currentLine;\nlet errorLine = currentLine;\nlet errorColumn = ((((inputOffset > 0) && (nl1 < 0)))? (-1) : ((tokenStart - inputOffset) - (((nl1 >= 0)? nl1 + 1 : 0))));\nif (isPointerIncluded) {\nlet relativePointer = pointer - inputOffset;\nlet searchPointer = relativePointer;\nwhile (searchPointer > 0) {\nsearchPointer = usedInput.lastIndexOf('\\n', searchPointer - 1);\n--pointerLine;\nif (searchPointer > nl1) --errorLine;\n}\nif (searchPointer !== 0) pointerLine += 1;\n}\nlet maxPointerlineLen = ('' + currentLine).length;\nlet gutterWidth = maxPointerlineLen + 4;\nlet pre = usedInput.slice(0, nl2).split('\\n');\nlet post = usedInput.slice(nl2 + 1, inputLen).split('\\n');\nwhile (((pre.length > 1) && (pre[0].length === 0))) {\npre.shift();\n++pointerLine;\n}\nwhile (((post.length > 0) && (post[post.length - 1].length === 0))) {\npost.pop();\n}\nlet lc = pointerLine;\nlet pre2 = pre.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + '  ') + s.trimRight())).join('\\n');\nlet post2 = post.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + '  ') + s.trimRight())).join('\\n');\nif (('' + lc).length > maxPointerlineLen) {\nmaxPointerlineLen = ('' + lc).length;\ngutterWidth = maxPointerlineLen + 4;\nlc = pointerLine;\npre2 = pre.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + '  ') + s.trimRight())).join('\\n');\npost2 = post.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + '  ') + s.trimRight())).join('\\n');\n}\nlet col = ((pointerLine === 1)? inputOffset : ((inputOffset - input.lastIndexOf('\\n', inputOffset)) - 1));\nlet top = ((((((('start@' + pointerLine) + ':') + (((col < 0)? '?' : col))) + ', error@') + errorLine) + ':') + (((errorColumn < 0)? '?' : errorColumn))) + '\\n';\nlet bar = ''.repeat(top.length - gutterWidth) + '\\n';\nlet header = ('' + ''.repeat(maxPointerlineLen)) + '';\nlet footer = ('' + ''.repeat(maxPointerlineLen)) + '';\nlet returnValue = ((((((((((((((((top + header) + bar) + pre2) + '\\n') + ' '.repeat(Math.max(0, maxPointerlineLen + 1))) + '  ') + ' '.repeat(Math.max(0, indentCount))) + '^'.repeat(Math.max(0, arrowCount))) + '------- error') + ((msg? ': ' + msg : ''))) + (((tokenOffset >= usedInput.length)? ' at EOF' : ''))) + ((post2? '\\n' : ''))) + post2) + '\\n') + footer) + bar) + '';\nreturn returnValue.split('\\n').map(s => (s.trimRight())).join('\\n');\n}\nreturn {tokens:tokenStorage, nextToken:nextToken, asi:addAsi, throw:_THROW, lexError:function() {\nTHROW(lastReportableLexerError, startForError, pointer);\n}, getTokenCountAny:function() {\nreturn anyTokenCount;\n}, getTokenCountSolid:function() {\nreturn solidTokenCount;\n}, prevEndColumn:function() {\nreturn prevTokenEndColumn;\n}, prevEndLine:function() {\nreturn prevTokenEndLine;\n}, prevEndPointer:function() {\nreturn prevTokenEndPointer;\n}, currColumn:function() {\nreturn pointer - currentColOffset;\n}, currLine:function() {\nreturn currentLine;\n}, currPointer:function() {\nreturn pointer;\n}, getNlwas:function() {\nreturn nlwas;\n}, getCanoN:function() {\nreturn lastCanonizedInput;\n}, getType:function() {\nreturn lastType;\n}, getStart:function() {\nreturn lastStart;\n}, getStop:function() {\nreturn lastStop;\n}, getLine:function() {\nreturn lastLine;\n}, getColumn:function() {\nreturn lastColumn;\n}, sliceInput:slice};\n}\nfunction isLfPsLs(c) {\nreturn ((c === 0x0A) || isPsLs(c));\n}\nfunction isPsLs(c) {\nreturn ((c === 0x2028) || (c === 0x2029));\n}\nfunction START(type) {\nswitch (type) {\ncase 1:\nreturn 'START_SPACE';\ncase 2:\nreturn 'START_ID';\ncase 3:\nreturn 'START_KEY';\ncase 4:\nreturn 'START_NL_SOLO';\ncase 5:\nreturn 'START_CR';\ncase 6:\nreturn 'START_STRING';\ncase 7:\nreturn 'START_DECIMAL';\ncase 8:\nreturn 'START_DOT';\ncase 9:\nreturn 'START_CURLY_CLOSE';\ncase 10:\nreturn 'START_EQ';\ncase 11:\nreturn 'START_DIV';\ncase 12:\nreturn 'START_PLUS';\ncase 13:\nreturn 'START_MIN';\ncase 14:\nreturn 'START_ZERO';\ncase 15:\nreturn 'START_TEMPLATE';\ncase 16:\nreturn 'START_EXCL';\ncase 17:\nreturn 'START_PERCENT';\ncase 18:\nreturn 'START_AND';\ncase 19:\nreturn 'START_STAR';\ncase 20:\nreturn 'START_CARET';\ncase 21:\nreturn 'START_LT';\ncase 22:\nreturn 'START_GT';\ncase 23:\nreturn 'START_OR';\ncase 24:\nreturn 'START_BSLASH';\ncase 26:\nreturn 'START_ERROR';\n}\nreturn ('S<' + T(type)) + '>';\n}\n// </lexer>\n\n// <parser>\nlet ASSERT_ASI_REGEX_NEXT = false;\nfunction sansFlag(flags, flag) {\nreturn (flags | flag) ^ flag;\n}\nfunction hasAllFlags(flags1, flags2) {\nreturn (flags1 & flags2) === flags2;\n}\nfunction hasAnyFlag(flags1, flags2) {\nreturn (flags1 & flags2) !== 0;\n}\nfunction hasNoFlag(flags, flag) {\nreturn (flags & flag) === 0;\n}\nfunction Parser(code, options = {}) {\nlet {goalMode:options_goalMode = false, collectTokens:options_collectTokens = 0, webCompat:options_webCompat = true, strictMode:options_strictMode = false, astRoot:options_astRoot = null, tokenStorage:options_tokenStorage, getLexer = null, allowGlobalReturn = false, targetEsVersion = Infinity, exposeScopes:options_exposeScopes = false, astUids = false, ranges:options_ranges = false, templateNewlineNormalization = true, errorCodeFrame = true, truncCodeFrame = true, $log = console.log, $warn = console.warn, $error = console.error, sourceField = '', babelCompat = false, babelTokenCompat = false, acornCompat = false, AST_directiveNodes = false} = options;\nlet goalMode = false;\nif ((typeof options_goalMode) === 'string') {\nif (options_goalMode === 'module') goalMode = true; else if (options_goalMode === 'script') goalMode = false; else throw new Error(('Unknown goal symbol value: `' + options_goalMode) + '`');\n} else {\ngoalMode = options_goalMode;\n}\nlet collectTokens = 0;\nif ((typeof options_collectTokens) === 'string') {\nif (options_collectTokens === 'all') collectTokens = 2; else if (options_collectTokens === 'solid') collectTokens = 1; else if (options_collectTokens === 'none') collectTokens = 0; else if (options_collectTokens === 'types') collectTokens = 3; else throw new Error(('Unknown collectTokens value: `' + options_collectTokens) + '`');\n} else {\ncollectTokens = options_collectTokens;\n}\nlet NODE_NAME_PROPERTY = (babelCompat? 'ObjectProperty' : 'Property');\nlet NODE_NAME_METHOD_OBJECT = (babelCompat? 'ObjectMethod' : 'Property');\nlet NODE_NAME_METHOD_CLASS = (babelCompat? 'ClassMethod' : 'MethodDefinition');\nlet tok = Lexer(code, {targetEsVersion, parsingGoal:goalMode, collectTokens, returnTokens:(babelCompat? 2 : 3), webCompat:options_webCompat, gracefulErrors:false, tokenStorageExternal:options_tokenStorage, babelTokenCompat, errorCodeFrame, truncCodeFrame, $log, $warn, $error});\nlet tok_throw = tok.throw;\nlet tok_lexError = tok.lexError;\nlet tok_asi = tok.asi;\nlet tok_prevEndColumn = tok.prevEndColumn;\nlet tok_prevEndLine = tok.prevEndLine;\nlet tok_prevEndPointer = tok.prevEndPointer;\nlet tok_currColumn = tok.currColumn;\nlet tok_currLine = tok.currLine;\nlet tok_currPointer = tok.currPointer;\nlet tok_nextToken = tok.nextToken;\nlet tok_getNlwas = tok.getNlwas;\nlet tok_getCanoN = tok.getCanoN;\nlet tok_getType = tok.getType;\nlet tok_getStart = tok.getStart;\nlet tok_getStop = tok.getStop;\nlet tok_getLine = tok.getLine;\nlet tok_getColumn = tok.getColumn;\nlet tok_sliceInput = tok.sliceInput;\nlet assertExpectedFail = '';\nlet $tp_assertExpected_start = tok_getStart();\nlet $tp_assertExpected_stop = tok_getStop();\nlet allowExponentiation = ((targetEsVersion >= 7) || (targetEsVersion === Infinity));\nlet allowTrailingFunctionComma = ((targetEsVersion >= 8) || (targetEsVersion === Infinity));\nlet allowAsyncFunctions = ((targetEsVersion >= 8) || (targetEsVersion === Infinity));\nlet allowAsyncGenerators = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nlet allowBadEscapesInTaggedTemplates = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nlet allowOptionalCatchBinding = ((targetEsVersion >= 10) || (targetEsVersion === Infinity));\nlet allowDynamicImport = ((targetEsVersion >= 11) || (targetEsVersion === Infinity));\nlet allowExportStarAs = ((targetEsVersion >= 11) || (targetEsVersion === Infinity));\nif (getLexer) getLexer(tok);\nfunction THROW_RANGE(desc, tokenStart, tokenStop, ...args) {\nif (arguments.length < 3) throw new Error('Expecting 3 args for THROW_RANGE, received ' + arguments.length);\nif (tokenStart > tokenStop) throw new Error(((('range should be >=0, was [' + tokenStart) + ', ') + tokenStop) + ']');\n$log('\\n');\n$log('Error in parser:', desc, 'remaining throw args;', args);\nlet fullErrmsg = ('Parser error! ' + desc) + (((tok_getType() === 2097173)? ' (at EOF)' : ''));\ntok_throw(fullErrmsg, tokenStart, tokenStop, '');\n}\nlet uid_counter = 0;\nlet _tree = {type:'Program', loc:undefined, body:[]};\nif (babelCompat) {\n_tree = {type:'Program', loc:undefined, body:[], sourceType:((goalMode === false)? 'script' : 'module'), interpreter:null};\n}\nif (acornCompat) {\n_tree = {type:'Program', loc:undefined, body:[], sourceType:((goalMode === false)? 'script' : 'module')};\n}\nlet _path = [_tree];\nlet _pnames;\nif (options_astRoot) {\noptions_astRoot.root = _tree;\noptions_astRoot.path = _path;\n}\nfunction AST_getClosedLoc($tp_first_start, $tp_first_line, $tp_first_column) {\nreturn AST_getCloseLoc($tp_first_start, $tp_first_line, $tp_first_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn());\n}\nfunction AST_getCloseLoc(startIndex, startLine, startColumn, endIndex, endLine, endColumn) {\nif (options_ranges) {\nreturn {start:{line:startLine | 0, column:startColumn | 0}, end:{line:endLine | 0, column:endColumn | 0}, range:{start:startIndex | 0, end:endIndex | 0}, source:sourceField};\n}\nreturn {start:{line:startLine, column:startColumn}, end:{line:endLine, column:endColumn}, source:sourceField};\n}\nfunction AST_open(prop, newNode) {\nAST_setNode(prop, newNode);\n_path[_path.length] = newNode;\n}\nfunction AST_close($tp_open_start, $tp_open_line, $tp_open_column) {\nAST_set('loc', AST_getCloseLoc($tp_open_start, $tp_open_line, $tp_open_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()));\n_path.pop();\n}\nfunction AST_closeTemplateElement(isTemplateDouble, $tp_tick_start, $tp_tick_line, $tp_tick_column) {\nlet colEnd = tok_prevEndColumn() - 1;\nlet pointerEnd = tok_prevEndPointer();\nif (isTemplateDouble) {\n--colEnd;\n--pointerEnd;\n}\nAST_set('loc', AST_getCloseLoc($tp_tick_start, $tp_tick_line, $tp_tick_column, pointerEnd, tok_prevEndLine(), colEnd));\n_path.pop();\n}\nfunction AST_set(prop, value) {\n_path[_path.length - 1][prop] = value;\n}\nfunction AST_setNode(astProp, node) {\nif (astUids) node.$uid = uid_counter++;\nlet parentNode = _path[_path.length - 1];\nlet p = parentNode[astProp];\nif (Array.isArray(p)) {\np[p.length] = node;\n} else {\nparentNode[astProp] = node;\n}\n}\nfunction AST_setNodeDangerously(astProp, node) {\nif ((astUids && node)) node.$uid = uid_counter++;\nlet parentNode = _path[_path.length - 1];\nlet p = parentNode[astProp];\nif (Array.isArray(p)) {\np[p.length] = node;\n} else {\nparentNode[astProp] = node;\n}\n}\nfunction AST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon) {\nlet identNode = AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nAST_setNode(astProp, identNode);\n}\nfunction AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon) {\nlet col = $tp_ident_column;\nlet line = $tp_ident_line;\nlet len = $tp_ident_stop - $tp_ident_start;\nlet colEnd = col + len;\nlet identNode = {type:'Identifier', loc:AST_getCloseLoc($tp_ident_start, line, col, $tp_ident_stop, line, colEnd), name:$tp_ident_canon};\nif (babelCompat) identNode.loc.identifierName = $tp_ident_canon;\nreturn identNode;\n}\nfunction AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon) {\n_AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, false);\n}\nfunction _AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, fromDirective) {\nif (isStringToken($tp_lit_type)) {\nAST_setStringLiteral(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, fromDirective);\n} else if (isNumberToken($tp_lit_type)) {\nif (isBigintToken($tp_lit_type)) {\nAST_setBigInt(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n} else {\nAST_setNumberLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n}\n} else {\nAST_setRegexLiteral(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n}\n}\nfunction AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nif (babelCompat) return AST_babelGetStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective);\nlet node = {type:'Literal', loc:AST_getCloseLoc($tp_string_start, $tp_string_line, $tp_string_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()), value:$tp_string_canon, raw:tok_sliceInput($tp_string_start, $tp_string_stop)};\nreturn node;\n}\nfunction AST_setStringLiteral(astProp, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nlet stringNode = AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective);\nAST_setNode(astProp, stringNode);\n}\nfunction AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nif (isBigintToken($tp_number_type)) return AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nif (babelCompat) return AST_babelGetNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet value = (($tp_number_type === 4105)? parseFloat(str) : ((($tp_number_type === 4104)? parseInt(str.slice(2), 16) : ((($tp_number_type === 4106)? parseInt(str.slice(2), 2) : ((($tp_number_type === 4107)? parseInt(str.slice(2), 8) : ((((str.includes('8') || str.includes('9')))? parseFloat(str.slice(1)) : parseInt(str.slice(1), 8))))))))));\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:value, raw:str};\n}\nfunction AST_setNumberLiteral(astProp, $tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet numberNode = AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nAST_setNode(astProp, numberNode);\n}\nfunction AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nif (acornCompat) return AST_acornGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nif (babelCompat) return AST_babelGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nreturn {type:'BigIntLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:null, bigint:tok_sliceInput($tp_number_start, $tp_number_stop - 1)};\n}\nfunction AST_setBigInt(astProp, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet bigintNode = AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nAST_setNode(astProp, bigintNode);\n}\nfunction AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nif (acornCompat) return AST_acornGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nif (babelCompat) return AST_babelGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), value:null, regex:{pattern:body, flags:tail}, raw:str};\n}\nfunction AST_setRegexLiteral(astProp, $tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet regexNode = AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nAST_setNode(astProp, regexNode);\n}\nfunction AST_add(prop, value) {\nlet arr = _path[_path.length - 1][prop];\narr[arr.length] = value;\n}\nfunction AST_popNode(prop) {\nlet parent = _path[_path.length - 1];\nlet p = parent[prop];\nif (Array.isArray(p)) {\nreturn p.pop();\n} else {\nreturn p;\n}\n}\nfunction AST_wrapClosedCustom(prop, newNode, newProp) {\nlet child = AST_popNode(prop);\nAST_open(prop, newNode);\nAST_set(newProp, child);\n}\nfunction AST_wrapClosedIntoArrayCustom(prop, newNode, newProp) {\nlet child = AST_popNode(prop);\nAST_open(prop, newNode);\nAST_set(newProp, [child]);\n}\nfunction AST_destruct(prop) {\nlet parent = _path[_path.length - 1];\nlet node = parent[prop];\nif (Array.isArray(node)) {\nlet last = node.length - 1;\nAST__destruct(node[last], node, last);\nreturn;\n}\nAST__destruct(node, parent, prop);\n}\nfunction AST__destruct(node, parent, astProp) {\nswitch (node.type) {\ncase 'ArrayExpression':\nnode.type = 'ArrayPattern';\nlet elements = node.elements;\nlet e = elements.length;\nfor (let i = 0;i < e;++i) {\nlet element = elements[i];\nif (element) AST__destruct(element, elements, i);\n}\nreturn;\ncase 'ObjectExpression':\nnode.type = 'ObjectPattern';\nlet properties = node.properties;\nlet n = properties.length;\nfor (let i = 0;i < n;++i) {\nif (properties[i].type === NODE_NAME_PROPERTY) {\n\n} else {\n\n}\nAST__destruct(properties[i], properties, i);\n}\nreturn;\ncase 'AssignmentExpression':\nAST__destruct(node.left, node, 'left');\nAST_destructReplaceAssignment(parent, astProp);\nreturn;\ncase NODE_NAME_PROPERTY:\nAST__destruct(node.value, node, 'value');\nreturn;\ncase 'SpreadElement':\nnode.type = 'RestElement';\nAST__destruct(node.argument, node, 'argument');\nreturn;\n}\n}\nfunction AST_destructReplaceAssignment(parentNode, prop) {\nlet oldNode = parentNode[prop];\nif (oldNode.operator !== '=') {\nreturn THROW_RANGE('The destructuring assignment should be a regular assignment', tok_getStart(), tok_getStop());\n}\nlet newNode = {type:'AssignmentPattern', loc:oldNode.loc, left:oldNode.left, right:oldNode.right};\nparentNode[prop] = newNode;\n}\nfunction AST_convertArrayToPattern($tp_eq_type, astProp) {\nif ($tp_eq_type === 49264) {\nlet node = _path[_path.length - 1][astProp];\nif (Array.isArray(node)) {\nnode = node[node.length - 1];\n}\nif (((node.type === 'ArrayExpression') || (node.type === 'ObjectExpression'))) {\nAST_destruct(astProp);\n}\n}\n}\nfunction AST_throwIfIllegalUpdateArg(astProp) {\nlet head = _path[_path.length - 1];\nlet prev = (head && head[astProp]);\nif (((!prev) || (((prev instanceof Array)? (((!prev.length) || (((prev[prev.length - 1].type !== 'Identifier') && (prev[prev.length - 1].type !== 'MemberExpression'))))) : (((prev.type !== 'Identifier') && (prev.type !== 'MemberExpression'))))))) {\nreturn THROW_RANGE('Can only increment or decrement an identifier or member expression', tok_getStart(), tok_getStop());\n}\n}\nfunction AST_patchAsyncCall($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, astProp) {\nlet node = _path[_path.length - 1];\nlet args = node[astProp];\nif (args instanceof Array) args = args[0];\nif (args.type === 'SequenceExpression') args = args.expressions; else args = [args];\nif (node[astProp] instanceof Array) node[astProp] = []; else node[astProp] = undefined;\nAST_setNode(astProp, {type:'CallExpression', loc:AST_getClosedLoc($tp_async_start, $tp_async_line, $tp_async_column), callee:AST_getIdentNode($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon), arguments:args});\n}\nfunction AST_babelDirectives() {\nlet node = _path[_path.length - 1];\nlet dirs = [];\nAST_set('directives', dirs);\nwhile ((node.body.length && (node.body[0].directive !== undefined))) {\nlet dir = node.body.shift();\ndirs[dirs.length] = {type:'Directive', loc:dir.loc, value:dir.expression};\ndir.expression.type = 'DirectiveLiteral';\n}\n}\nfunction AST_babelParenthesizesClosed($tp_parenOpen_start, astProp) {\nlet parent = _path[_path.length - 1];\nlet child = parent[astProp];\nif (Array.isArray(child)) {\nchild = child[child.length - 1];\n}\nif (child.extra) {\nchild.extra.parenthesized = true;\nchild.extra.parenStart = $tp_parenOpen_start;\n} else {\nchild.extra = {parenthesized:true, parenStart:$tp_parenOpen_start};\n}\n}\nfunction AST_babelAddComment($tp_comment_start, $tp_comment_stop, $tp_comment_line, $tp_comment_column, $tp_comment_type) {\nif (!_path[_path.length - 1].innerComments) _path[_path.length - 1].innerComments = [];\nlet str = tok_sliceInput($tp_comment_start, $tp_comment_stop);\nlet typeName = 'CommentLine';\nlet value = '';\nif ($tp_comment_type === 1285) {\nvalue = tok_sliceInput($tp_comment_start + 2, $tp_comment_stop);\n} else if ($tp_comment_type === 1286) {\ntypeName = 'CommentBlock';\nvalue = tok_sliceInput($tp_comment_start + 2, $tp_comment_stop - 2);\n} else {\nvalue = ((str.slice(0, 3) === '-->')? tok_sliceInput($tp_comment_start + 3, $tp_comment_stop) : tok_sliceInput($tp_comment_start + 4, $tp_comment_stop));\n}\nlet commentNode = {type:typeName, loc:AST_getCloseLoc($tp_comment_start, $tp_comment_line, $tp_comment_column, tok_currPointer(), tok_currLine(), tok_currColumn()), value:value};\nAST_setNode('innerComments', commentNode);\nreturn commentNode;\n}\nfunction AST_babelGetStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nlet str = tok_sliceInput($tp_string_start, $tp_string_stop);\nlet value = (fromDirective? str.slice(1, -1) : $tp_string_canon);\nreturn {type:'StringLiteral', loc:AST_getCloseLoc($tp_string_start, $tp_string_line, $tp_string_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()), value:value, extra:{rawValue:value, raw:str}};\n}\nfunction AST_babelGetNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet value = (($tp_number_type === 4105)? parseFloat(str) : ((($tp_number_type === 4104)? parseInt(str.slice(2), 16) : ((($tp_number_type === 4106)? parseInt(str.slice(2), 2) : ((($tp_number_type === 4107)? parseInt(str.slice(2), 8) : ((((str.includes('8') || str.includes('9')))? parseFloat(str.slice(1)) : parseInt(str.slice(1), 8))))))))));\nreturn {type:'NumericLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:value, extra:{rawValue:value, raw:str}};\n}\nfunction AST_babelGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop - 1);\nreturn {type:'BigIntLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:str, extra:{rawValue:str, raw:str + 'n'}};\n}\nfunction AST_babelGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'RegExpLiteral', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), pattern:body, flags:tail, extra:{rawValue:undefined, raw:str}, value:undefined};\n}\nfunction AST_acornGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet strn = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet str = strn.slice(0, -1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), raw:strn, bigint:str, value:BigInt(str)};\n}\nfunction AST_acornGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), value:new RegExp(body, tail), regex:{pattern:body, flags:tail}, raw:str};\n}\nfunction initLexer(lexerFlags) {\nskipToStatementStart(lexerFlags);\n}\nfunction skipRex(lexerFlags) {\n_skip(lexerFlags | 4);\n}\nfunction skipDiv(lexerFlags) {\n_skip(lexerFlags);\n}\nfunction skipAny(lexerFlags) {\n_skip(lexerFlags);\n}\nfunction _skip(lexerFlags) {\ntok_nextToken(lexerFlags);\nif (tok_getType() === 2097175) {\nreturn tok_lexError();\n}\nif (!babelCompat) return;\nlet $tp_maybeComment_type = tok_getType();\nlet $tp_maybeComment_line = tok_getLine();\nlet $tp_maybeComment_column = tok_getColumn();\nlet $tp_maybeComment_start = tok_getStart();\nlet $tp_maybeComment_stop = tok_getStop();\nwhile (isCommentToken($tp_maybeComment_type)) {\ntok_nextToken(lexerFlags);\nif (tok_getType() === 2097175) {\nreturn tok_lexError();\n}\nAST_babelAddComment($tp_maybeComment_start, $tp_maybeComment_stop, $tp_maybeComment_line, $tp_maybeComment_column, $tp_maybeComment_type);\n$tp_maybeComment_type = tok_getType();\n$tp_maybeComment_line = tok_getLine();\n$tp_maybeComment_column = tok_getColumn();\n$tp_maybeComment_start = tok_getStart();\n$tp_maybeComment_stop = tok_getStop();\n}\n}\nfunction skipToParenOpenOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToCurlyOpenOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Expected to parse an opening curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToFromOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Next token should be the ident `from` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToStringOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (!isStringToken(tok_getType())) {\nreturn THROW_RANGE(('Next token should be a string but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToIdentOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (!isIdentToken(tok_getType())) {\nreturn THROW_RANGE(('Next token should be an ident but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToArrowOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16499) {\nreturn THROW_RANGE(('Next token should be `=>` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToAsCommaCurlyClose(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToAsCommaFrom(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToColonOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16489) {\nreturn THROW_RANGE(('Next token should be `:` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToTargetOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 2116) {\nreturn THROW_RANGE(('Next token should be `target` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToStatementStart(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStart(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartGrouped(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartSemi(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartSquareCloseComma(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToAfterNew(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToSwitchBody(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToBindingStart(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToBindingStartGrouped(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToColonParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarCurlyOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentCurlyOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentCurlyClose(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarCurlyOpenParenOpenString(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToAwaitParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStringNumberSquareOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipIdentSafeSlowAndExpensive(lexerFlags, leftHandSideExpression) {\nswitch (tok_getType()) {\ncase 2084:\n\ncase 2121:\n\ncase 2123:\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('A unary expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nreturn;\ncase 2104:\nskipToAfterNew(lexerFlags);\nreturn;\ncase 2075:\nif (((goalMode === true) || ((lexerFlags & 8) !== 0))) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An `await` expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\nreturn 0;\ncase 2126:\nif ((lexerFlags & 8320) !== 0) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('A `yield` expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipRex(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\n}\nfunction parseTopLevels(lexerFlags) {\nlet scoop = SCOPE_createGlobal('_parseTopLevels');\nif (options_exposeScopes) AST_set('$scope', scoop);\nlet exportedNames = new Set();\nlet exportedBindings = new Set();\nlet len;\nlet bak;\nparseBodyPartsWithDirectives(lexerFlags, scoop, exportedNames, exportedBindings, 1, 0, 0, 0, 0, 0, '', true, 'body');\nif (goalMode === true) {\nlet globalNames = scoop.names;\nexportedBindings.forEach(name => {\nif (((name !== 'default') && (((globalNames === HAS_NO_BINDINGS) || (!globalNames.has(name)))))) {\nreturn THROW_RANGE(('Exporting a name that was not bound in global: `' + name) + '`', tok_getStart(), tok_getStop());\n}\n});\n}\n}\nfunction SCOPE_createGlobal(desc) {\nlet scoop = {type:SCOPE_LAYER_GLOBAL, names:HAS_NO_BINDINGS, dupeParamErrorStart:0, dupeParamErrorStop:0, parent:null};\nif (astUids) scoop.$uid = uid_counter++;\nreturn scoop;\n}\nfunction SCOPE_addLayer(scoop, scopeType, desc) {\nlet scoopNew = {type:scopeType, names:HAS_NO_BINDINGS, dupeParamErrorStart:0, dupeParamErrorStop:0, parent:scoop};\nif (astUids) scoop.$uid = uid_counter++;\nreturn scoopNew;\n}\nfunction SCOPE_addFuncDeclName(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState) {\nif (bindingType === BINDING_TYPE_FUNC_VAR) {\nSCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType);\n} else {\nSCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState);\n}\n}\nfunction SCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType) {\nif (((bindingType === BINDING_TYPE_VAR) || (bindingType === BINDING_TYPE_FUNC_VAR))) {\nSCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType);\n} else {\nSCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, 1);\n}\n}\nfunction SCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType) {\nlet currScoop = scoop;\ndo {\nif (currScoop.names === HAS_NO_BINDINGS) {\ncurrScoop.names = new Map();\n} else if (currScoop.names.has($tp_bindingIdent_canon)) {\nlet bindingType = currScoop.names.get($tp_bindingIdent_canon);\nverifyDuplicateVarBinding(lexerFlags, bindingType, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon);\n}\ncurrScoop.names.set($tp_bindingIdent_canon, bindingType);\ncurrScoop = currScoop.parent;\n} while ((currScoop && (currScoop.type !== SCOPE_LAYER_FUNC_ROOT)));\n}\nfunction verifyDuplicateVarBinding(lexerFlags, value, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon) {\nswitch (value) {\ncase BINDING_TYPE_NONE:\n\ncase BINDING_TYPE_ARG:\n\ncase BINDING_TYPE_VAR:\n\ncase BINDING_TYPE_FUNC_VAR:\n\ncase BINDING_TYPE_FUNC_STMT:\nreturn;\ncase BINDING_TYPE_FUNC_LEX:\n\ncase BINDING_TYPE_LET:\n\ncase BINDING_TYPE_CONST:\n\ncase BINDING_TYPE_CLASS:\nreturn THROW_RANGE('Found a var binding that is duplicate of a lexical binding on the same or lower statement level', $tp_bindingIdent_start, $tp_bindingIdent_stop);\ncase BINDING_TYPE_CATCH_OTHER:\nreturn THROW_RANGE(('Can not create a binding for `' + $tp_bindingIdent_canon) + '` because was already bound as a catch clause pattern binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\ncase BINDING_TYPE_CATCH_IDENT:\nif (options_webCompat === false) {\nreturn THROW_RANGE(('Can not create a binding for `' + $tp_bindingIdent_canon) + '` because was already bound as a catch clause binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\nreturn;\n}\n}\nfunction SCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState) {\nif (scoop === null) {\nreturn;\n}\nlet value = ((((scoop.names === HAS_NO_BINDINGS) || (!scoop.names.has($tp_bindingIdent_canon))))? BINDING_TYPE_NONE : scoop.names.get($tp_bindingIdent_canon));\nif (value !== BINDING_TYPE_NONE) {\nif (bindingType === BINDING_TYPE_ARG) {\nscoop.dupeParamErrorStart = $tp_bindingIdent_start + 1;\nscoop.dupeParamErrorStop = $tp_bindingIdent_stop;\n} else if (((((options_webCompat !== true) || (value !== BINDING_TYPE_FUNC_LEX))) || (fdState !== 3))) {\nreturn THROW_RANGE(('Attempted to create a lexical binding for `' + $tp_bindingIdent_canon) + '` but another binding already existed on the same level', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n} else {\n\n}\n}\nif (((((scoop.type === SCOPE_LAYER_FUNC_BODY) && (scoop.parent.names !== HAS_NO_BINDINGS))) && scoop.parent.names.has($tp_bindingIdent_canon))) {\nreturn THROW_RANGE(('Cannot create lexical binding for `' + $tp_bindingIdent_canon) + '` because it shadows a function parameter', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\nif (((((scoop.type === SCOPE_LAYER_ARROW_PARAMS) && (value !== BINDING_TYPE_NONE))) && (bindingType === BINDING_TYPE_ARG))) {\nscoop.dupeParamErrorStart = $tp_bindingIdent_start + 1;\nscoop.dupeParamErrorStop = $tp_bindingIdent_stop;\n}\nif (scoop.type === SCOPE_LAYER_CATCH_BODY) {\nlet parentValue = ((((scoop.parent.names === HAS_NO_BINDINGS) || (!scoop.parent.names.has($tp_bindingIdent_canon))))? BINDING_TYPE_NONE : scoop.parent.names.get($tp_bindingIdent_canon));\nif (((parentValue === BINDING_TYPE_CATCH_IDENT) || (parentValue === BINDING_TYPE_CATCH_OTHER))) {\nreturn THROW_RANGE(('Can not create a lexical binding for `' + $tp_bindingIdent_canon) + '` because it shadows a catch clause binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\n}\nif (scoop.names === HAS_NO_BINDINGS) scoop.names = new Map();\nscoop.names.set($tp_bindingIdent_canon, bindingType);\n}\nfunction parseDirectivePrologues(lexerFlags, astProp) {\nlet hadUseStrict = false;\nlet isStrict = (lexerFlags & 8192) === 8192;\nlet hadOctal = false;\nwhile (isStringToken(tok_getType())) {\nlet $tp_string_type = tok_getType();\nlet $tp_string_line = tok_getLine();\nlet $tp_string_column = tok_getColumn();\nlet $tp_string_start = tok_getStart();\nlet $tp_string_stop = tok_getStop();\nlet $tp_string_canon = tok_getCanoN();\nskipDiv(lexerFlags);\n_AST_setLiteral(astProp, $tp_string_type, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, true);\nlet $tp_next_start = tok_getStart();\nif (tok_getType() !== 16490) {\nparseExpressionAfterLiteral(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, astProp);\nif (tok_getType() !== 16490) {\nparseExpressionFromOp(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, 16, astProp);\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_string_start, $tp_string_line, $tp_string_column, 16, astProp);\n}\n}\n}\nif (tok_getStart() === $tp_next_start) {\nlet dir = tok_sliceInput($tp_string_start + 1, $tp_string_stop - 1);\nif (((!isStrict) && /(^|[^\\\\])(\\\\\\\\)*\\\\(?:0\\d|[1-9])/.test(dir))) {\nhadOctal = true;\n}\nif (dir === 'use strict') {\nhadUseStrict = true;\nlexerFlags = lexerFlags | 8192;\nif (!isStrict) {\nif (tok_getType() === 4108) {\nreturn THROW_RANGE('Illegal legacy octal literal in strict mode', tok_getStart(), tok_getStop());\n}\nif (((!hadOctal) && /(^|[^\\\\])(\\\\\\\\)*\\\\(?:0\\d|[1-9])/.test(tok_sliceInput(tok_getStart(), tok_getStop())))) {\nreturn THROW_RANGE('Octal in directive with strict mode directive or in strict mode is always illegal', tok_getStart(), tok_getStop());\n}\n}\nisStrict = true;\n}\nif ((AST_directiveNodes && (!babelCompat))) {\nAST_setNodeDangerously(astProp, {type:'Directive', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), directive:dir});\nparseSemiOrAsi(lexerFlags);\n} else {\nparseSemiOrAsi(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'ExpressionStatement', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), expression:AST_popNode(astProp), directive:dir});\n}\n} else {\nparseSemiOrAsi(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'ExpressionStatement', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), expression:AST_popNode(astProp)});\nbreak;\n}\n}\nif ((hadOctal && isStrict)) {\nreturn THROW_RANGE('Octal in directive with strict mode directive or in strict mode is always illegal', tok_getStart(), tok_getStop());\n}\nreturn hadUseStrict;\n}\nfunction parseBodyPartsWithDirectives(lexerFlags, scoop, exportedNames, exportedBindings, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isGlobalToplevel, astProp) {\nlet wasStrict = (lexerFlags & 8192) === 8192;\nlet isStrict = wasStrict;\nlet hasUseStrict = parseDirectivePrologues(lexerFlags, 'body');\nif (hasUseStrict) {\nisStrict = true;\nif (((paramsSimple === 2) || (paramsSimple === 3))) {\nreturn THROW_RANGE('Can only declare use strict if func params are \"simple\"', tok_getStart(), tok_getStop());\n}\nif (((((!wasStrict) && ($tp_functionNameToVerify_start !== 0))) && isStrictOnlyKeyword($tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon))) {\nreturn THROW_RANGE(('Can not use reserved keyword `' + $tp_functionNameToVerify_canon) + '` in strict mode as id for function that has a use strict directive', $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop);\n}\nlexerFlags |= 8192;\n}\nif (((dupeParamErrorStart !== 0) && (((paramsSimple === 3) || isStrict)))) {\nreturn THROW_RANGE('Function had duplicate params', dupeParamErrorStart - 1, dupeParamErrorStop);\n}\nwhile (((tok_getType() !== 2097173) && (tok_getType() !== 16517))) {\nparseBodyPart(lexerFlags, scoop, null, exportedNames, exportedBindings, isGlobalToplevel, false, 4, null, astProp);\n}\nif (babelCompat) AST_babelDirectives();\n}\nfunction wrapLabelSet(labelSet, desc) {\nlet set = {parentLabels:labelSet, statementLabels:new Set(), iterationLabels:null};\nreturn set;\n}\nfunction parseStatementHeader(lexerFlags, headProp) {\nlet $tp_openParan_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nparseExpressions(((lexerFlags | 4096) | 1792) ^ 1792, headProp);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren of statement header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', $tp_openParan_start, tok_getStop());\n}\nskipToStatementStart(lexerFlags);\n}\nfunction parseSemiOrAsi(lexerFlags) {\nif (tok_getType() === 16490) {\nskipToStatementStart(lexerFlags);\nreturn;\n}\nif (((((tok_getType() === 16517) || (tok_getNlwas() === true))) || (tok_getType() === 2097173))) {\ntok_asi();\n} else {\n$log('parse error at curent token');\nreturn THROW_RANGE('Unable to ASI', tok_getStart(), tok_getStop());\n}\n}\nfunction parseNestedBodyPart(lexerFlags, scoop, labelSet, isLabelled, fdState, nestedLabels, astProp) {\nparseBodyPart(lexerFlags, scoop, labelSet, undefined, undefined, false, isLabelled, fdState, nestedLabels, astProp);\n}\nfunction parseBodyPart(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp) {\nif (isIdentToken(tok_getType())) {\nparseIdentStatement(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp);\nreturn;\n}\nif (isPunctuatorToken(tok_getType())) {\nparsePunctuatorStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\n}\nif (isNumberToken(tok_getType())) {\nparseFromNumberStatement(lexerFlags, astProp);\nreturn;\n}\nif (isStringToken(tok_getType())) {\nparseFromStringStatement(lexerFlags, astProp);\nreturn;\n}\nif (isTickToken(tok_getType())) {\nparseTickStatement(lexerFlags, astProp);\nreturn;\n}\nif (isRegexToken(tok_getType())) {\nparseFromRegexStatement(lexerFlags, astProp);\nreturn;\n}\nTHROW_RANGE('Unexpected EOF', tok_getStart(), tok_getStop());\n}\nfunction parseFunctionDeclaration(lexerFlags, scoop, isFuncDecl, isRealFuncExpr, $tp_async_type, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, $tp_funcHead_start, $tp_funcHead_stop, optionalIdent, isLabelled, fdState, astProp) {\nskipToIdentStarParenOpen(lexerFlags);\nlet $tp_star_type = 0;\nif (tok_getType() === 82009) {\n$tp_star_type = 82009;\n$tp_funcHead_stop = tok_getStop();\nskipToIdentParenOpen(lexerFlags);\nif ((($tp_async_type === 2074) && (!allowAsyncGenerators))) {\nreturn THROW_RANGE('Async generators are not supported by the currently targeted language version, they were introduced in ES9/ES2018', $tp_funcHead_start, $tp_funcHead_stop);\n}\n}\nif (isLabelled === true) {\nif (fdState === 1) {\nreturn THROW_RANGE('A \"labelled function declaration\" is not allowed in this situation', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('A \"labelled function declaration\" can not be async', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('A \"labelled function declaration\" can not be a generator', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif (((options_webCompat === false) || ((lexerFlags & 8192) === 8192))) {\nreturn THROW_RANGE('A \"labelled function declaration\" is only allowed in sloppy web compat mode', $tp_funcHead_start, $tp_funcHead_stop);\n}\n} else if (fdState === 2) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('An async function declaration in web compat mode is still not allowed as `if-else` child, only plain func decls are allowed there', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('A generator function declaration in web compat mode is still not allowed as `if-else` child, only plain func decls are allowed there', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif (((options_webCompat === false) || ((lexerFlags & 8192) === 8192))) {\nreturn THROW_RANGE('A function declaration can only be the child of an `if`/`else` in sloppy web compat mode', $tp_funcHead_start, $tp_funcHead_stop);\n}\nscoop = SCOPE_addLayer(scoop, SCOPE_LAYER_FAKE_BLOCK, 'special \"fake-block\" function statement for label');\n} else if (((isFuncDecl === true) && (fdState === 1))) {\nreturn THROW_RANGE('Cannot parse a function declaration here, only expecting statements here', $tp_funcHead_start, $tp_funcHead_stop);\n}\nreturn parseFunctionAfterKeyword(lexerFlags, scoop, isFuncDecl, isRealFuncExpr, optionalIdent, false, false, $tp_async_type, $tp_star_type, 0, 0, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, fdState, astProp);\n}\nfunction parseFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp) {\nif (tok_getType() === 82009) {\nreturn parseGeneratorFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp);\n}\nparseFunctionAfterKeyword(lexerFlags, null, false, true, false, false, false, 0, 0, 0, 0, $tp_function_start, $tp_function_line, $tp_function_column, 1, astProp);\n}\nfunction parseGeneratorFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp) {\nskipToIdentParenOpen(lexerFlags);\nparseFunctionAfterKeyword(lexerFlags, null, false, true, false, false, false, 0, 82009, 0, 0, $tp_function_start, $tp_function_line, $tp_function_column, 1, astProp);\n}\nfunction parseAsyncFunctionDecl(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, fromStmtOrExpr, scoop, isExport, exportedBindings, isLabelled, fdState, astProp) {\nlet $tp_function_stop = tok_getStop();\nlet canonName = parseFunctionDeclaration(lexerFlags, scoop, ((fromStmtOrExpr === 1)? false : true), ((fromStmtOrExpr === 1)? true : false), 2074, $tp_async_start, $tp_async_line, $tp_async_column, $tp_async_start, $tp_function_stop, ((((isExport === true) || (fromStmtOrExpr === 1)))? true : false), isLabelled, fdState, astProp);\nif (isExport === true) {\naddBindingToExports(exportedBindings, canonName);\n}\nreturn 16;\n}\nfunction parseFunctionAfterKeyword(lexerFlags, outerScoop, isFuncDecl, isRealFuncExpr, optionalIdent, isClassConstructor, isMethod, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, fdState, astProp) {\nif ((babelCompat && (isMethod !== false))) {\nAST_set('generator', $tp_star_type === 82009);\nAST_set('async', $tp_async_type === 2074);\n} else if (acornCompat) {\nif (allowAsyncFunctions) {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, async:$tp_async_type === 2074, expression:false, id:undefined, params:[], body:undefined});\n} else {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, expression:false, id:undefined, params:[], body:undefined});\n}\n} else {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, async:$tp_async_type === 2074, id:undefined, params:[], body:undefined});\n}\nlet innerScoop = SCOPE_createGlobal('parseFunctionAfterKeyword_main_func_scope');\nlet $tp_functionNameToVerify_type = 0;\nlet $tp_functionNameToVerify_line = 0;\nlet $tp_functionNameToVerify_column = 0;\nlet $tp_functionNameToVerify_start = 0;\nlet $tp_functionNameToVerify_stop = 0;\nlet $tp_functionNameToVerify_canon = '';\nlet canonName = '';\nif (isIdentToken(tok_getType())) {\n$tp_functionNameToVerify_type = tok_getType();\n$tp_functionNameToVerify_line = tok_getLine();\n$tp_functionNameToVerify_column = tok_getColumn();\n$tp_functionNameToVerify_start = tok_getStart();\n$tp_functionNameToVerify_stop = tok_getStop();\n$tp_functionNameToVerify_canon = tok_getCanoN();\nlet bindingFlags = ((lexerFlags | 136) ^ 136) | getFuncIdentAsyncGenState(isRealFuncExpr, lexerFlags, $tp_star_type, $tp_async_type);\nlet nameBindingType = ((((((isFuncDecl === true) && (fdState === 4))) && ((((lexerFlags & 256) === 0) || (goalMode === false)))))? BINDING_TYPE_FUNC_VAR : BINDING_TYPE_FUNC_LEX);\ncanonName = $tp_functionNameToVerify_canon;\nfatalBindingIdentCheck($tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, nameBindingType, bindingFlags);\nif (isFuncDecl === true) {\nSCOPE_addFuncDeclName(lexerFlags, outerScoop, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, canonName, nameBindingType, fdState);\n} else {\nSCOPE_actuallyAddBinding(lexerFlags, innerScoop, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, canonName, BINDING_TYPE_FUNC_VAR);\n}\ninnerScoop = SCOPE_addLayer(innerScoop, SCOPE_LAYER_FUNC_ROOT, 'parseFunctionAfterKeyword_hide_func_name');\nskipToParenOpenOrDie(lexerFlags);\nAST_setIdent('id', $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_line, $tp_functionNameToVerify_column, $tp_functionNameToVerify_canon);\n} else if (((isFuncDecl === true) && (optionalIdent === false))) {\nreturn THROW_RANGE('Function decl missing required ident', tok_getStart(), tok_getStop());\n} else {\nAST_set('id', null);\ninnerScoop = SCOPE_addLayer(innerScoop, SCOPE_LAYER_FUNC_ROOT, 'function_has_no_id_but_whatever');\n}\nlexerFlags = resetLexerFlagsForFuncAndArrow(lexerFlags, $tp_star_type, $tp_async_type, false);\nif (isClassConstructor === true) {\nlexerFlags |= 16;\n} else {\nlexerFlags = (lexerFlags | 16400) ^ 16400;\n}\nif (isMethod === true) lexerFlags |= 32768; else lexerFlags = (lexerFlags | 32768) ^ 32768;\nparseFunctionFromParams(lexerFlags, innerScoop, (($tp_async_type === 0)? 6 : 5), ((isFuncDecl === true)? 2 : 1), $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isMethod, $tp_get_type, $tp_set_type);\nif (((!babelCompat) || (isMethod === false))) {\nAST_close($tp_astRange_start, $tp_astRange_line, $tp_astRange_column);\n}\nreturn canonName;\n}\nfunction getFuncIdentGeneratorState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type) {\nif ((enclosingScopeFlags & 8192) === 8192) return 128;\nif (isRealFuncExpr === true) return (($tp_star_type === 82009)? 128 : 0);\nreturn (((enclosingScopeFlags & 128) !== 0)? 128 : 0);\n}\nfunction getFuncIdentAsyncState(isRealFuncExpr, enclosingScopeFlags, $tp_async_type) {\nif (goalMode === true) return 8;\nif (isRealFuncExpr === true) return (($tp_async_type === 2074)? 8 : 0);\nreturn (((enclosingScopeFlags & 8) !== 0)? 8 : 0);\n}\nfunction getFuncIdentAsyncGenState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type, $tp_async_type) {\nreturn getFuncIdentGeneratorState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type) | getFuncIdentAsyncState(isRealFuncExpr, enclosingScopeFlags, $tp_async_type);\n}\nfunction resetLexerFlagsForFuncAndArrow(lexerFlags, $tp_star_type, $tp_async_type, funcType) {\nlexerFlags = lexerFlags & 59392;\nif ($tp_async_type === 2074) {\nlexerFlags |= 8;\n}\nif ($tp_star_type === 82009) {\nlexerFlags |= 128;\n}\nif (funcType === false) lexerFlags = lexerFlags | 2;\nreturn lexerFlags;\n}\nfunction parseFunctionFromParams(lexerFlags, scoop, bindingFrom, expressionState, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isMethod, $tp_get_type, $tp_set_type) {\nlet paramScoop = SCOPE_addLayer(scoop, SCOPE_LAYER_FUNC_PARAMS, 'parseFunctionFromParams(arg)');\nlet paramsSimple = parseFuncArguments(lexerFlags | 4096, paramScoop, bindingFrom, $tp_get_type, $tp_set_type);\nlet dupeParamErrorStart = paramScoop.dupeParamErrorStart;\nlet dupeParamErrorStop = paramScoop.dupeParamErrorStop;\nif (((isMethod === true) && (dupeParamErrorStart !== 0))) {\nreturn THROW_RANGE('Method had duplicate params', dupeParamErrorStart - 1, dupeParamErrorStop);\n}\nlet finalFuncScope = SCOPE_addLayer(paramScoop, SCOPE_LAYER_FUNC_BODY, 'parseFunctionFromParams(body)');\nif (options_exposeScopes) AST_set('$scope', finalFuncScope);\nparseFunctionBody(lexerFlags, finalFuncScope, expressionState, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, false);\n}\nfunction parseFuncArguments(lexerFlags, scoop, bindingFrom, $tp_get_type, $tp_set_type) {\nlexerFlags = lexerFlags | 64;\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE('Must have func arguments next but did not find `(`', tok_getStart(), tok_getStop());\n}\nskipToBindingStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Setters must have exactly one parameter', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\nreturn 1;\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Getters can not have any parameters', tok_getStart(), tok_getStop());\n}\nlet paramsSimple = parseBindings(lexerFlags, scoop, BINDING_TYPE_ARG, bindingFrom, false, $tp_set_type, undefined, undefined, 'params');\nAST_destruct('params');\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing function param definition closing parenthesis, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\nreturn paramsSimple;\n}\nfunction parseFunctionBody(lexerFlags, scoop, blockType, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isArrow) {\nlet lexerFlagsNoTemplate = (lexerFlags | 7936) ^ 7936;\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nskipToStatementStart(lexerFlagsNoTemplate);\nAST_open('body', {type:'BlockStatement', loc:undefined, body:[]});\nif (options_exposeScopes) AST_set('$scope', scoop);\nparseBodyPartsWithDirectives(lexerFlagsNoTemplate, scoop, undefined, undefined, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, false, 'body');\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Missing function body closing curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nif (isArrow) {\nskipRex(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nASSERT_ASI_REGEX_NEXT = true;\n}\n} else if (blockType === 1) {\nskipDiv(lexerFlags);\n} else {\nskipToStatementStart(lexerFlags);\n}\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (tok_getType() === 49264) {\nreturn THROW_RANGE('Object destructuring is not allowed at the start of statement or arrow body, must wrap the object in parenthesis for that to work', tok_getStart(), tok_getStop());\n}\n}\nfunction parseIdentStatement(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nswitch ($tp_ident_type) {\ncase 2074:\nskipDiv(lexerFlags);\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, 2074, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nparseAsyncStatement(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, false, undefined, isLabelled, fdState, astProp);\nreturn;\ncase 2076:\nparseBreakStatement(lexerFlags, labelSet, astProp);\nreturn;\ncase 2079:\nparseClassDeclaration(lexerFlags, scoop, false, isLabelled, fdState, astProp);\nreturn;\ncase 2080:\nparseConstStatement(lexerFlags, scoop, isLabelled, fdState, astProp);\nreturn;\ncase 2081:\nparseContinueStatement(lexerFlags, labelSet, astProp);\nreturn;\ncase 2082:\nparseDebuggerStatement(lexerFlags, astProp);\nreturn;\ncase 2085:\nparseDoStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2089:\nparseExportStatement(lexerFlags, scoop, exportedNames, exportedBindings, isGlobalToplevel, astProp);\nreturn;\ncase 2093:\nparseForStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2095:\n;\nparseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_start, $tp_ident_stop, false, isLabelled, fdState, astProp);\nreturn;\ncase 2097:\nparseIfStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2099:\nparseImportDeclaration(lexerFlags, scoop, isGlobalToplevel, astProp);\nreturn;\ncase 2103:\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nparseLetExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp);\n} else {\nparseLetDeclaration(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, scoop, labelSet, fdState, nestedLabels, astProp);\n}\nreturn;\ncase 2111:\nparseReturnStatement(lexerFlags, astProp);\nreturn;\ncase 2115:\nparseSwitchStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2118:\nparseThrowStatement(lexerFlags, astProp);\nreturn;\ncase 2120:\nparseTryStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2122:\nparseVarStatement(lexerFlags, scoop, astProp);\nreturn;\ncase 2124:\nparseWhileStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2125:\nparseWithStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\n}\nparseIdentLabelOrExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp);\n}\nfunction parseFromNumberStatement(lexerFlags, astProp) {\nlet $tp_number_type = tok_getType();\nlet $tp_number_line = tok_getLine();\nlet $tp_number_column = tok_getColumn();\nlet $tp_number_start = tok_getStart();\nlet $tp_number_stop = tok_getStop();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column)});\nparseExpressionAfterLiteral(lexerFlags, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_number_start, $tp_number_line, $tp_number_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_number_start, $tp_number_line, $tp_number_column);\n}\nfunction parseFromStringStatement(lexerFlags, astProp) {\nlet $tp_string_line = tok_getLine();\nlet $tp_string_column = tok_getColumn();\nlet $tp_string_start = tok_getStart();\nlet $tp_string_stop = tok_getStop();\nlet $tp_string_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, false)});\nparseExpressionAfterLiteral(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_string_start, $tp_string_line, $tp_string_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_string_start, $tp_string_line, $tp_string_column);\n}\nfunction parseFromRegexStatement(lexerFlags, astProp) {\nlet $tp_regex_line = tok_getLine();\nlet $tp_regex_column = tok_getColumn();\nlet $tp_regex_start = tok_getStart();\nlet $tp_regex_stop = tok_getStop();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column)});\nparseExpressionAfterLiteral(lexerFlags, $tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_regex_start, $tp_regex_line, $tp_regex_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_regex_start, $tp_regex_line, $tp_regex_column);\n}\nfunction parseTickStatement(lexerFlags, astProp) {\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, 'expression');\nparseExpressionAfterLiteral(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_tick_start, $tp_tick_line, $tp_tick_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\n}\nfunction parseAsyncStatement(lexerFlags, scoop, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isExport, exportedBindings, isLabelled, fdState, astProp) {\n_parseAsync(lexerFlags, scoop, 2, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 4, isExport, true, exportedBindings, isLabelled, fdState, false, astProp);\n}\nfunction parseAsyncExpression(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, leftHandSideExpression, astProp) {\nreturn _parseAsync(lexerFlags, null, 1, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, undefined, false, 1, leftHandSideExpression, astProp);\n}\nfunction _parseAsync(lexerFlags, scoop, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, exportedBindings, isLabelled, fdState, leftHandSideExpression, astProp) {\nif (!allowAsyncFunctions) {\nif (((tok_getType() === 2095) && (!tok_getNlwas()))) {\nreturn THROW_RANGE('Async functions are not supported in the currently targeted version, they are >= ES8 / ES2017', $tp_async_start, tok_getStop());\n}\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nlet newlineAfterAsync = tok_getNlwas() === true;\nlet $tp_afterAsync_type = tok_getType();\nif (isIdentToken($tp_afterAsync_type)) {\nlet $tp_ident_stop = tok_getStop();\nif (newlineAfterAsync) {\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nif ($tp_afterAsync_type === 2095) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An async function expression is not allowed here', $tp_async_start, $tp_ident_stop);\n}\nreturn parseAsyncFunctionDecl(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, fromStmtOrExpr, scoop, isExport, exportedBindings, isLabelled, fdState, astProp);\n}\nif ((($tp_afterAsync_type === 67636) || ($tp_afterAsync_type === 67637))) {\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot apply `new` to an (async) arrow', $tp_async_start, $tp_ident_stop);\n}\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An async function expression is not allowed here', $tp_async_start, $tp_ident_stop);\n}\nparseParenlessArrowAfterAsync(lexerFlags, fromStmtOrExpr, allowAssignment, $tp_async_start, $tp_async_line, $tp_async_column, astProp);\nreturn 16;\n}\nif ($tp_afterAsync_type === 16471) {\nif (isNewArg === 3) {\nAST_setIdent('callee', $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon);\nreturn 32;\n}\nif (fromStmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nlet r = parseGroupToplevels(lexerFlags, fromStmtOrExpr, allowAssignment, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, (newlineAfterAsync? true : false), leftHandSideExpression, astProp);\nif (fromStmtOrExpr === 2) {\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\nreturn r;\n}\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nfunction isAssignable(state) {\nreturn (state & 32) === 32;\n}\nfunction notAssignable(state) {\nreturn (state & 16) === 16;\n}\nfunction setAssignable(state) {\nreturn ((state | 32) | 16) ^ 16;\n}\nfunction setNotAssignable(state) {\nreturn ((state | 32) | 16) ^ 32;\n}\nfunction mergeAssignable(override, state) {\nreturn override | (((state | 16) | 32) ^ 48);\n}\nfunction parseAwait(lexerFlags, $tp_await_type, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_canon, isNewArg, allowAssignment, astProp) {\nif ((lexerFlags & 8) !== 0) {\nreturn parseAwaitKeyword(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, isNewArg, astProp);\n}\nif (goalMode === false) {\nreturn parseAwaitVar(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_type, $tp_await_canon, isNewArg, allowAssignment, astProp);\n}\nreturn THROW_RANGE('Cannot use `await` as var when goal=module but found `await` outside an async function', tok_getStart(), tok_getStart() + 1);\n}\nfunction parseAwaitKeyword(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, isNewArg, astProp) {\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot `await` as the arg of `new`', $tp_await_start, $tp_await_stop);\n}\nif ((lexerFlags & 64) === 64) {\nreturn THROW_RANGE('Await is illegal as default arg value', $tp_await_start, $tp_await_stop);\n}\nAST_open(astProp, {type:'AwaitExpression', loc:undefined, argument:undefined});\nparseValue(lexerFlags, false, 4, false, 'argument');\nif (tok_getType() === 82010) {\nreturn THROW_RANGE('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)', tok_getStart(), tok_getStop());\n}\nAST_close($tp_await_start, $tp_await_line, $tp_await_column);\nreturn 80;\n}\nfunction parseAwaitVar(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_type, $tp_await_canon, isNewArg, allowAssignment, astProp) {\nlet assignable = parseIdentOrParenlessArrow(lexerFlags, $tp_await_type, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_canon, 32, allowAssignment, astProp);\nassignable = parseValueTail(lexerFlags, $tp_await_start, $tp_await_line, $tp_await_column, assignable, isNewArg, false, astProp);\nreturn assignable | 64;\n}\nfunction parseBlockStatement(lexerFlags, scoop, labelSet, astProp) {\nlet lexerFlagsNoTemplate = (lexerFlags | 6144) ^ 6144;\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nskipToStatementStart(lexerFlagsNoTemplate);\nif (babelCompat) {\nAST_open(astProp, {type:'BlockStatement', loc:undefined, directives:[], body:[]});\n} else {\nAST_open(astProp, {type:'BlockStatement', loc:undefined, body:[]});\n}\nif (options_exposeScopes) AST_set('$scope', scoop);\nwhile (tok_getType() !== 16517) {\nparseNestedBodyPart(lexerFlagsNoTemplate, scoop, labelSet, false, 3, null, 'body');\n}\nskipToStatementStart(lexerFlags);\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (tok_getType() === 49264) {\nreturn THROW_RANGE('A statement can not start with object destructuring assignment (because block)', tok_getStart(), tok_getStop());\n}\n}\nfunction parseBreakStatement(lexerFlags, labelSet, astProp) {\nlet $tp_break_line = tok_getLine();\nlet $tp_break_column = tok_getColumn();\nlet $tp_break_start = tok_getStart();\nlet $tp_break_stop = tok_getStop();\nskipToStatementStart(lexerFlags);\nlet $tp_afterBreak_type = tok_getType();\nif ((isIdentToken($tp_afterBreak_type) && (tok_getNlwas() === false))) {\nlet $tp_label_line = tok_getLine();\nlet $tp_label_column = tok_getColumn();\nlet $tp_label_start = tok_getStart();\nlet $tp_label_stop = tok_getStop();\nlet $tp_label_canon = tok_getCanoN();\nfindLabelForBreak(labelSet, $tp_label_start, $tp_label_stop, $tp_label_canon);\nskipToStatementStart(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'BreakStatement', loc:AST_getClosedLoc($tp_break_start, $tp_break_line, $tp_break_column), label:AST_getIdentNode($tp_label_start, $tp_label_stop, $tp_label_line, $tp_label_column, $tp_label_canon)});\n} else if ((lexerFlags & 1536) === 0) {\nreturn THROW_RANGE('Can only `break` without label inside a `switch` or loop', $tp_break_start, $tp_break_stop);\n} else {\nif (((tok_getNlwas() === true) && isRegexToken($tp_afterBreak_type))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'BreakStatement', loc:AST_getClosedLoc($tp_break_start, $tp_break_line, $tp_break_column), label:null});\n}\n}\nfunction findLabelForBreak(inputLabelSet, $tp_label_start, $tp_label_stop, $tp_labelName_canon) {\nif (inputLabelSet === null) {\nreturn THROW_RANGE(`The label (\\`${tok_sliceInput($tp_label_start, $tp_label_stop)}\\`) for this \\`break\\` was not defined in the current label set, which is illegal`, $tp_label_start, $tp_label_stop);\n}\nlet labelSet = inputLabelSet;\nlet id = $tp_labelName_canon;\ndo {\nif (labelSet.statementLabels.has(id)) {\nreturn;\n}\n} while (labelSet = labelSet.parentLabels);\nTHROW_RANGE(('The label (`' + $tp_labelName_canon) + '`) for this `break` was not defined in the current label set, which is illegal', $tp_label_start, $tp_label_stop);\n}\nfunction validateLabelForContinue(labelSet, $tp_label_canon, $tp_label_start, $tp_label_stop) {\nif (labelSet === null) {\nreturn THROW_RANGE(('This `continue` had a label (`' + $tp_label_canon) + '`) that was not defined in the current label set as the direct parent of a loop, which would be required', $tp_label_start, $tp_label_stop);\n}\nlet set = labelSet;\ndo {\nif ((set.iterationLabels && set.iterationLabels.has($tp_label_canon))) {\nreturn;\n}\n} while (set = set.parentLabels);\nreturn THROW_RANGE(('This `continue` had a label (`' + $tp_label_canon) + '`) that was not defined in the current label set as the direct parent of a loop, which would be required', $tp_label_start, $tp_label_stop);\n}\nfunction parseConstStatement(lexerFlags, scoop, isLabelled, fdState, astProp) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nlet $tp_const_stop = tok_getStop();\nskipToBindingStart(lexerFlags);\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nreturn THROW_RANGE('Cannot parse a labelled const declaration, only expecting statements here', $tp_const_start, $tp_const_stop);\n}\nparseAnyVarDeclaration(lexerFlags, $tp_const_start, $tp_const_line, $tp_const_column, scoop, BINDING_TYPE_CONST, 1, undefined, undefined, astProp);\n}\nfunction parseContinueStatement(lexerFlags, labelSet, astProp) {\nlet $tp_continue_line = tok_getLine();\nlet $tp_continue_column = tok_getColumn();\nlet $tp_continue_start = tok_getStart();\nif ((lexerFlags & 512) === 0) {\nreturn THROW_RANGE('Can only `continue` inside a loop', $tp_continue_start, $tp_continue_start + 1);\n}\nskipToStatementStart(lexerFlags);\nif ((isIdentToken(tok_getType()) && (tok_getNlwas() === false))) {\nlet $tp_label_line = tok_getLine();\nlet $tp_label_column = tok_getColumn();\nlet $tp_label_start = tok_getStart();\nlet $tp_label_stop = tok_getStop();\nlet $tp_label_canon = tok_getCanoN();\nvalidateLabelForContinue(labelSet, $tp_label_canon, $tp_label_start, $tp_label_stop);\nskipToStatementStart(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'ContinueStatement', loc:AST_getClosedLoc($tp_continue_start, $tp_continue_line, $tp_continue_column), label:AST_getIdentNode($tp_label_start, $tp_label_stop, $tp_label_line, $tp_label_column, $tp_label_canon)});\n} else {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'ContinueStatement', loc:AST_getClosedLoc($tp_continue_start, $tp_continue_line, $tp_continue_column), label:null});\n}\n}\nfunction parseDebuggerStatement(lexerFlags, astProp) {\nlet $tp_debugger_line = tok_getLine();\nlet $tp_debugger_column = tok_getColumn();\nlet $tp_debugger_start = tok_getStart();\nlet $tp_debugger_stop = tok_getStop();\nskipToStatementStart(lexerFlags);\nif (isRegexToken(tok_getType())) {\nif (tok_getNlwas() === false) {\nreturn THROW_RANGE('Missing semi-colon after debugger keyword', $tp_debugger_stop, $tp_debugger_stop);\n}\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'DebuggerStatement', loc:AST_getClosedLoc($tp_debugger_start, $tp_debugger_line, $tp_debugger_column)});\n}\nfunction parseDoStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_do_line = tok_getLine();\nlet $tp_do_column = tok_getColumn();\nlet $tp_do_start = tok_getStart();\nskipToStatementStart(lexerFlags);\nAST_open(astProp, {type:'DoWhileStatement', loc:undefined, body:undefined, test:undefined});\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nif (tok_getType() !== 2124) {\nreturn THROW_RANGE(('A `do` must be followed by a `while`, but found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToParenOpenOrDie(lexerFlags);\nparseStatementHeader(lexerFlags, 'test');\nif (tok_getType() !== 16490) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_do_start, $tp_do_line, $tp_do_column);\n}\nfunction parseExportDefaultAsync(lexerFlags, scoop, exportedBindings) {\nlet $tp_async_line = tok_getLine();\nlet $tp_async_column = tok_getColumn();\nlet $tp_async_start = tok_getStart();\nlet $tp_async_stop = tok_getStop();\nlet $tp_async_canon = tok_getCanoN();\nskipRex(lexerFlags);\nif (tok_getType() === 2095) {\nreturn parseAsyncStatement(lexerFlags, scoop, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, true, exportedBindings, false, 4, 'declaration');\n}\nparseAsyncExpression(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 4, true, true, false, 'declaration');\nparseSemiOrAsi(lexerFlags);\n}\nfunction parseExportDefault(lexerFlags, scoop, $tp_export_start, $tp_export_line, $tp_export_column, $tp_default_start, $tp_default_stop, exportedNames, exportedBindings, astProp) {\nAST_open(astProp, {type:'ExportDefaultDeclaration', loc:undefined, declaration:undefined});\nskipToExpressionStart(lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_default_start, $tp_default_stop, '*default*', BINDING_TYPE_LET, 4);\naddNameToExports(exportedNames, $tp_default_start, $tp_default_stop, 'default');\naddBindingToExports(exportedBindings, '*default*');\nif (tok_getType() === 2079) {\nlet $tp_exportedName_canon = parseClassDeclaration(lexerFlags, scoop, true, false, 3, 'declaration');\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\n} else if (tok_getType() === 2095) {\nlet $tp_function_line = tok_getLine();\nlet $tp_function_column = tok_getColumn();\nlet $tp_function_start = tok_getStart();\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_function_start, $tp_function_line, $tp_function_column, $tp_export_start, $tp_function_stop, true, false, 4, 'declaration');\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\n} else if (tok_getType() === 2074) {\nparseExportDefaultAsync(lexerFlags, scoop, exportedBindings);\n} else {\nparseExpression(lexerFlags, 'declaration');\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_export_start, $tp_export_line, $tp_export_column);\n}\nfunction parseExportStar(lexerFlags, $tp_export_start, $tp_export_line, $tp_export_column, exportedNames, astProp) {\nlet $tp_star_line = tok_getLine();\nlet $tp_star_column = tok_getColumn();\nlet $tp_star_start = tok_getStart();\nskipAny(lexerFlags);\nif (tok_getType() === 2073) {\nif (!allowExportStarAs) {\nreturn THROW_RANGE('The `export * as x from src`, syntax was introduced in ES2020 but currently targeted version is lower', $tp_export_start, tok_getStop());\n}\nskipToIdentOrDie(lexerFlags);\nlet $tp_exportedName_line = tok_getLine();\nlet $tp_exportedName_column = tok_getColumn();\nlet $tp_exportedName_start = tok_getStart();\nlet $tp_exportedName_stop = tok_getStop();\nlet $tp_exportedName_canon = tok_getCanoN();\naddNameToExports(exportedNames, $tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_canon);\nskipAny(lexerFlags);\nlet specifiers = [{type:'ExportNamespaceSpecifier', loc:AST_getClosedLoc($tp_star_start, $tp_star_line, $tp_star_column), exported:AST_getIdentNode($tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_line, $tp_exportedName_column, $tp_exportedName_canon)}];\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Expected to find `as` or `from`, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStringOrDie(lexerFlags);\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nlet source = AST_getStringNode($tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nif (babelCompat) {\nAST_setNode(astProp, {type:'ExportNamedDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), specifiers, source});\n} else {\nAST_setNode(astProp, {type:'ExportNamedDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), specifiers, declaration:null, source});\n}\nreturn;\n}\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Expected to find `as` or `from`, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStringOrDie(lexerFlags);\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nlet source = AST_getStringNode($tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nAST_setNode(astProp, {type:'ExportAllDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), source});\n}\nfunction parseExportNamed(lexerFlags, scoop, $tp_export_start, $tp_export_stop, $tp_export_line, $tp_export_column, exportedNames, exportedBindings, astProp) {\nAST_open(astProp, {type:'ExportNamedDeclaration', loc:undefined, specifiers:[], declaration:undefined, source:undefined});\nlet needsSemi = true;\nlet $tp_exportValueStart_line = tok_getLine();\nlet $tp_exportValueStart_column = tok_getColumn();\nlet $tp_exportValueStart_start = tok_getStart();\nlet $tp_exportValueStart_stop = tok_getStop();\nif (tok_getType() === 16513) {\nAST_set('declaration', null);\nlet tmpExportedNames = new Set();\nlet tmpExportedBindings = new Set();\nparseExportObject(lexerFlags, tmpExportedNames, tmpExportedBindings);\nif (tok_getType() === 2094) {\nskipToStringOrDie(lexerFlags);\nlet $tp_from_line = tok_getLine();\nlet $tp_from_column = tok_getColumn();\nlet $tp_from_start = tok_getStart();\nlet $tp_from_stop = tok_getStop();\nlet $tp_from_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nAST_setStringLiteral('source', $tp_from_start, $tp_from_stop, $tp_from_line, $tp_from_column, $tp_from_canon, false);\n} else {\nAST_set('source', null);\ntmpExportedNames.forEach(name => (addNameToExports(exportedNames, $tp_export_start, $tp_export_stop, name)));\ntmpExportedBindings.forEach(name => (addBindingToExports(exportedBindings, name)));\n}\n} else if (tok_getType() === 2122) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_var_start, $tp_var_line, $tp_var_column, scoop, BINDING_TYPE_VAR, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2103) {\nlet $tp_let_line = tok_getLine();\nlet $tp_let_column = tok_getColumn();\nlet $tp_let_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, BINDING_TYPE_LET, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2080) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_const_start, $tp_const_line, $tp_const_column, scoop, BINDING_TYPE_CONST, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2079) {\nlet $tp_exportedName_canon = parseClassDeclaration(lexerFlags, scoop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_exportValueStart_start, $tp_exportValueStart_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nneedsSemi = false;\nAST_set('source', null);\n} else if (tok_getType() === 2095) {\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_exportValueStart_start, $tp_exportValueStart_line, $tp_exportValueStart_column, $tp_export_start, $tp_function_stop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_exportValueStart_start, $tp_exportValueStart_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2074) {\nlet $tp_async_line = tok_getLine();\nlet $tp_async_column = tok_getColumn();\nlet $tp_async_start = tok_getStart();\nlet $tp_async_stop = tok_getStop();\nskipDiv(lexerFlags);\nif (tok_getType() !== 2095) {\nreturn THROW_RANGE('Can only export async functions (not arrows), did not find a function', $tp_export_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async can not be followed by a newline as it results in `export async;`, which is not valid (and probably not what you wanted)', $tp_export_start, $tp_async_stop);\n}\nlet $tp_function_start = tok_getStart();\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 2074, $tp_async_start, $tp_async_line, $tp_async_column, $tp_export_start, $tp_function_stop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_function_start, $tp_function_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nAST_set('source', null);\nneedsSemi = false;\n} else {\nreturn THROW_RANGE(('Unknown export type `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` (note: you can only export individual vars through `export {foo};`)', tok_getStart(), tok_getStop());\n}\nif (needsSemi) {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\n}\nAST_close($tp_export_start, $tp_export_line, $tp_export_column);\n}\nfunction parseExportStatement(lexerFlags, scoop, exportedNames, exportedBindings, isGlobalToplevel, astProp) {\nlet $tp_export_line = tok_getLine();\nlet $tp_export_column = tok_getColumn();\nlet $tp_export_start = tok_getStart();\nlet $tp_export_stop = tok_getStop();\nif (goalMode !== true) {\nreturn THROW_RANGE('The `export` keyword can only be used with the module goal', $tp_export_start, $tp_export_stop);\n}\nif (isGlobalToplevel === false) {\nreturn THROW_RANGE('The `export` keyword is only supported at the top level', $tp_export_start, $tp_export_stop);\n}\nskipToIdentStarCurlyOpen(lexerFlags);\nif (tok_getType() === 2083) {\nlet $tp_default_start = tok_getStart();\nlet $tp_default_stop = tok_getStop();\nreturn parseExportDefault(lexerFlags, scoop, $tp_export_start, $tp_export_line, $tp_export_column, $tp_default_start, $tp_default_stop, exportedNames, exportedBindings, astProp);\n}\nif (tok_getType() === 82009) {\nreturn parseExportStar(lexerFlags, $tp_export_start, $tp_export_line, $tp_export_column, exportedNames, astProp);\n}\nreturn parseExportNamed(lexerFlags, scoop, $tp_export_start, $tp_export_stop, $tp_export_line, $tp_export_column, exportedNames, exportedBindings, astProp);\n}\nfunction addNameToExports(exportedNames, $tp_exportedName_start, $tp_exportedName_stop, exportedName) {\nif (((exportedNames !== undefined) && (exportedName !== ''))) {\nif (exportedNames.has(exportedName)) {\nreturn THROW_RANGE(('Tried to export the name `' + exportedName) + '` twice', $tp_exportedName_start, $tp_exportedName_stop);\n}\nexportedNames.add(exportedName);\n}\n}\nfunction addBindingToExports(exportedBindings, exportedTokenCanonName) {\nif (((exportedBindings !== undefined) && (exportedTokenCanonName !== ''))) {\nexportedBindings.add(exportedTokenCanonName);\n}\n}\nfunction parseExportObject(lexerFlags, tmpExportedNames, tmpExportedBindings) {\nskipToIdentCurlyClose(lexerFlags);\nwhile (isIdentToken(tok_getType())) {\nparseExportSpecifier(lexerFlags, tmpExportedNames, tmpExportedBindings);\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n}\nif (tok_getType() !== 16517) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Export object cannot have spread', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16489) {\nreturn THROW_RANGE('Export object uses `as` to alias (`{a as y}`), not colon (`{a: y}`)', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Export object can only have \"shorthand\" `{x}` or \"as\" `{x as y}', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\n}\nfunction parseExportSpecifier(lexerFlags, tmpExportedNames, tmpExportedBindings) {\nlet $tp_name_line = tok_getLine();\nlet $tp_name_column = tok_getColumn();\nlet $tp_name_start = tok_getStart();\nlet $tp_name_stop = tok_getStop();\nlet $tp_name_canon = tok_getCanoN();\nlet $tp_exportedName_line = tok_getLine();\nlet $tp_exportedName_column = tok_getColumn();\nlet $tp_exportedName_start = tok_getStart();\nlet $tp_exportedName_stop = tok_getStop();\nlet $tp_exportedName_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 2073) {\nskipToIdentOrDie(lexerFlags);\n$tp_exportedName_line = tok_getLine();\n$tp_exportedName_column = tok_getColumn();\n$tp_exportedName_start = tok_getStart();\n$tp_exportedName_stop = tok_getStop();\n$tp_exportedName_canon = tok_getCanoN();\nskipAny(lexerFlags);\n}\naddNameToExports(tmpExportedNames, $tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_canon);\naddBindingToExports(tmpExportedBindings, $tp_name_canon);\nAST_setNode('specifiers', {type:'ExportSpecifier', loc:AST_getClosedLoc($tp_name_start, $tp_name_line, $tp_name_column), local:AST_getIdentNode($tp_name_start, $tp_name_stop, $tp_name_line, $tp_name_column, $tp_name_canon), exported:AST_getIdentNode($tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_line, $tp_exportedName_column, $tp_exportedName_canon)});\n}\nfunction parseForStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_for_line = tok_getLine();\nlet $tp_for_column = tok_getColumn();\nlet $tp_for_start = tok_getStart();\nlet $tp_for_stop = tok_getStop();\nskipToAwaitParenOpen(lexerFlags);\nlet awaitable = tok_getType() === 2075;\nif (awaitable) {\nlet $tp_await_stop = tok_getStop();\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('`for await` is not supported by the current targeted language version, they were introduced in ES9/ES2018', $tp_for_start, $tp_await_stop);\n}\nif ((lexerFlags & 8) === 0) {\nreturn THROW_RANGE('Can only use `for-await` inside an async function', $tp_for_start, $tp_await_stop);\n}\nskipToParenOpenOrDie(lexerFlags);\n} else if (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Missing opening paren of the `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', $tp_for_start, $tp_for_stop);\n}\nskipToExpressionStartSemi(lexerFlags);\nlet hasOwnScope = false;\nif (((((tok_getType() === 2103) || (tok_getType() === 2080))) || (tok_getType() === 2122))) {\nscoop = SCOPE_addLayer(scoop, SCOPE_LAYER_FOR_HEADER, 'parseForStatement(header)');\nhasOwnScope = true;\n}\nparseForHeader(((lexerFlags | 4096) | 1792) ^ 1792, $tp_for_start, scoop, awaitable, astProp);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren of the `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nif ((hasOwnScope && options_exposeScopes)) AST_set('$scope', scoop);\nAST_close($tp_for_start, $tp_for_line, $tp_for_column);\n}\nfunction parseForHeaderVar(lexerFlags, scoop, astProp) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nlet $tp_var_stop = tok_getStop();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags | 32, $tp_var_start, $tp_var_line, $tp_var_column, scoop, BINDING_TYPE_VAR, 2, undefined, undefined, astProp);\nreturn 32;\n}\nfunction parseForHeaderLet(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp) {\nlet $tp_letIdent_type = tok_getType();\nlet $tp_letIdent_line = tok_getLine();\nlet $tp_letIdent_column = tok_getColumn();\nlet $tp_letIdent_start = tok_getStart();\nlet $tp_letIdent_stop = tok_getStop();\nlet $tp_letIdent_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nlet $tp_letArg_type = tok_getType();\nlet $tp_letArg_stop = tok_getStop();\nif (isIdentToken($tp_letArg_type)) {\nif ($tp_letArg_type === 67636) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let binding missing binding names as `let` cannot be a var name in strict mode', $tp_letIdent_start, $tp_letArg_stop);\n}\nAST_setIdent(astProp, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon);\nreturn 32;\n}\nif ($tp_letArg_type === 2106) {\nreturn THROW_RANGE('A `for (let of ...)` is always illegal', $tp_for_start, $tp_letArg_stop);\n}\nparseAnyVarDeclaration(lexerFlags | 32, $tp_letIdent_start, $tp_letIdent_line, $tp_letIdent_column, scoop, BINDING_TYPE_LET, 2, undefined, undefined, astProp);\nreturn 32;\n}\nif ((($tp_letArg_type === 16509) || ($tp_letArg_type === 16513))) {\nparseAnyVarDeclaration(lexerFlags | 32, $tp_letIdent_start, $tp_letIdent_line, $tp_letIdent_column, scoop, BINDING_TYPE_LET, 2, undefined, undefined, astProp);\nreturn 32;\n}\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let binding missing binding names in strict mode', $tp_letIdent_start, $tp_letIdent_stop);\n}\nif ($tp_letArg_type === 16490) {\nAST_setIdent(astProp, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon);\nreturn 16;\n}\nlet assignable = parseValueAfterIdent(lexerFlags, $tp_letIdent_type, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon, BINDING_TYPE_NONE, true, astProp);\nassignable = parseExpressionFromOp(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, assignable, astProp);\nif (tok_getType() === 2106) {\nreturn THROW_RANGE('Cannot use `let` as a var name on the left side in a `for-of` header', $tp_for_start, tok_getStop());\n}\nreturn assignable;\n}\nfunction parseForHeaderConst(lexerFlags, scoop, astProp) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags | 32, $tp_const_start, $tp_const_line, $tp_const_column, scoop, BINDING_TYPE_CONST, 2, undefined, undefined, astProp);\nreturn 32;\n}\nfunction parseForHeaderCurly(lexerFlags, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nlet $tp_curly_stop = tok_getStop();\nlet destructible = parseObjectOuter(lexerFlags | 32, null, BINDING_TYPE_NONE, false, undefined, undefined, astProp);\nlet $tp_curlyClose_type = tok_getType();\nlet $tp_curlyClose_stop = tok_getStart();\nif ((destructible & 4) === 4) {\nif ((((($tp_curlyClose_type !== 49264) && ($tp_curlyClose_type !== 2106))) && ($tp_curlyClose_type !== 67636))) {\nreturn THROW_RANGE('Cannot use lhs as regular for-loop because it must destruct', $tp_curly_start, $tp_curlyClose_stop);\n}\ndestructible = (destructible | 4) ^ 4;\n}\nreturn parsePatternTailInForHeader(lexerFlags, $tp_curly_start, $tp_curly_stop, $tp_curly_line, $tp_curly_column, 16517, destructible, astProp);\n}\nfunction parseForHeaderBracket(lexerFlags, astProp) {\nlet $tp_square_line = tok_getLine();\nlet $tp_square_column = tok_getColumn();\nlet $tp_square_start = tok_getStart();\nlet $tp_square_stop = tok_getStop();\nlet destructible = parseArrayOuter(lexerFlags | 32, null, BINDING_TYPE_NONE, false, undefined, undefined, astProp);\nlet $tp_bracketClose_type = tok_getType();\nlet $tp_bracketClose_stop = tok_getStart();\nif ((destructible & 4) === 4) {\nif ((((($tp_bracketClose_type !== 49264) && ($tp_bracketClose_type !== 2106))) && ($tp_bracketClose_type !== 67636))) {\nreturn THROW_RANGE('Cannot use lhs as regular for-loop because it must destruct', $tp_square_start, $tp_bracketClose_stop);\n}\ndestructible = (destructible | 4) ^ 4;\n}\nlet assignable = parsePatternTailInForHeader(lexerFlags, $tp_square_start, $tp_square_stop, $tp_square_line, $tp_square_column, 16510, destructible, astProp);\nreturn assignable;\n}\nfunction parseForHeaderOther(lexerFlags, astProp) {\nreturn parseValue(lexerFlags | 32, true, 4, false, astProp);\n}\nfunction parseForHeader(lexerFlags, $tp_for_start, scoop, awaitable, astProp) {\nlet $tp_startOfForHeader_line = tok_getLine();\nlet $tp_startOfForHeader_column = tok_getColumn();\nlet $tp_startOfForHeader_start = tok_getStart();\nlet $tp_startOfForHeader_stop = tok_getStop();\nlet assignable = parseForHeaderLhs(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp);\nreturn parseForHeaderRest(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, awaitable, assignable, astProp);\n}\nfunction parseForHeaderLhs(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp) {\nswitch (tok_getType()) {\ncase 2122:\nreturn parseForHeaderVar(lexerFlags, scoop, astProp);\ncase 2103:\nreturn parseForHeaderLet(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp);\ncase 2080:\nreturn parseForHeaderConst(lexerFlags, scoop, astProp);\ncase 16490:\nAST_setNodeDangerously(astProp, null);\nreturn 16;\ncase 16513:\nreturn parseForHeaderCurly(lexerFlags, astProp);\ncase 16509:\nreturn parseForHeaderBracket(lexerFlags, astProp);\n}\nlet assignable = parseForHeaderOther(lexerFlags, astProp);\nreturn parseExpressionFromOp(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, assignable, astProp);\n}\nfunction parseForHeaderRest(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, awaitable, assignable, astProp) {\nif (tok_getType() === 2106) {\nreturn parseForFromOf(lexerFlags, $tp_for_start, awaitable, assignable, astProp);\n}\nif (awaitable) {\nreturn THROW_RANGE('`for await` only accepts the `for-of` type', $tp_for_start, tok_getStop());\n}\nif (tok_getType() === 67636) {\nreturn parseForFromIn(lexerFlags, $tp_for_start, assignable, astProp);\n}\nAST_wrapClosedCustom(astProp, {type:'ForStatement', loc:undefined, init:undefined, test:undefined, update:undefined, body:undefined}, 'init');\nreturn parseForFromSemi(lexerFlags, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column);\n}\nfunction parseForFromOf(lexerFlags, $tp_for_start, awaitable, assignable, astProp) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Left part of for-of must be assignable', $tp_for_start, tok_getStop());\n}\nAST_wrapClosedCustom(astProp, {type:'ForOfStatement', loc:undefined, left:undefined, right:undefined, await:awaitable, body:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nparseExpression(lexerFlags, 'right');\n}\nfunction parseForFromIn(lexerFlags, $tp_for_start, assignable, astProp) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Left part of for-in must be assignable', $tp_for_start, tok_getStop());\n}\nAST_wrapClosedCustom(astProp, {type:'ForInStatement', loc:undefined, left:undefined, right:undefined, body:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nparseExpressions(lexerFlags, 'right');\n}\nfunction parseForFromSemi(lexerFlags, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column) {\nlet hadComma = tok_getType() === 16480;\nlet potentialCommaStart = tok_getStart();\nif (hadComma) {\n_parseExpressions(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column, 16, 'init');\n}\nif (tok_getType() !== 16490) {\nif ((hadComma && (((tok_getType() === 2106) || (tok_getType() === 67636))))) {\nreturn THROW_RANGE('Comma not allowed in left side of `for-in`/`for-of` header', potentialCommaStart, potentialCommaStart + 1);\n}\nreturn THROW_RANGE(('Missing first semi in `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nreturn _parseForFromSemi(lexerFlags);\n}\nfunction _parseForFromSemi(lexerFlags) {\nskipToExpressionStartSemi(lexerFlags);\nif (tok_getType() === 16490) {\nAST_set('test', null);\n} else {\nparseExpressions(lexerFlags, 'test');\nif (tok_getType() !== 16490) {\nreturn THROW_RANGE(('Missing second semi in `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\n}\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nAST_set('update', null);\n} else {\nparseExpressions(lexerFlags, 'update');\n}\n}\nfunction parsePatternTailInForHeader(lexerFlags, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, closingPuncType, destructible, astProp) {\nlet assignable = (((destructible & 1) !== 0)? 16 : 32);\nlet $tp_patternTailStart_type = tok_getType();\nif ((($tp_patternTailStart_type !== 49264) && isAnyAssignmentOp())) {\nreturn THROW_RANGE('Cannot compound assign to an object or array pattern', tok_getStart(), tok_getStop());\n}\nassignable = parseValueTail(lexerFlags | 32, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, assignable, 4, false, astProp);\nlet $tp_afteLhs_type = tok_getType();\nif ((($tp_afteLhs_type === 2106) || ($tp_afteLhs_type === 67636))) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('The for-header lhs binding pattern is not destructible', tok_getStart(), tok_getStop());\n}\nAST_destruct(astProp);\nreturn assignable;\n}\nif ($tp_afteLhs_type === 16490) {\nreturn assignable;\n}\nif ($tp_afteLhs_type === 49264) {\nlet $tp_eq_start = tok_getStart();\nlet $tp_eq_stop = tok_getStop();\nparseExpressionFromOp(lexerFlags | 32, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, assignable, astProp);\nif (tok_getType() === 16490) {\nreturn 16;\n}\nif (((tok_getType() === 67636) || (tok_getType() === 2106))) {\nreturn THROW_RANGE('The left side of a `for-of` and `for-in` can not be an assignment, even if it is a BindingPattern', $tp_eq_start, $tp_eq_stop);\n}\nreturn THROW_RANGE('Unknown input followed the left side of a for loop header after assignment', tok_getStart(), tok_getStop());\n}\nparseOptionalDestructibleRestOfExpression(lexerFlags, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, assignable, destructible, closingPuncType, astProp);\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, 16, astProp);\n}\nif (tok_getType() === 16490) {\nreturn assignable;\n}\nreturn THROW_RANGE('Unknown input followed the left side of a for loop header', tok_getStart(), tok_getStop());\n}\nfunction parseIfStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_if_line = tok_getLine();\nlet $tp_if_column = tok_getColumn();\nlet $tp_if_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'IfStatement', loc:undefined, test:undefined, consequent:undefined, alternate:undefined});\nparseStatementHeader(lexerFlags, 'test');\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 2, null, 'consequent');\nif (tok_getType() === 2086) {\nskipToStatementStart(lexerFlags);\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 2, null, 'alternate');\n} else {\nAST_set('alternate', null);\n}\nAST_close($tp_if_start, $tp_if_line, $tp_if_column);\n}\nfunction parseImportDeclaration(lexerFlags, scoop, isGlobalToplevel, astProp) {\nlet $tp_import_line = tok_getLine();\nlet $tp_import_column = tok_getColumn();\nlet $tp_import_start = tok_getStart();\nlet $tp_import_stop = tok_getStop();\nskipToIdentStarCurlyOpenParenOpenString(lexerFlags);\nif (tok_getType() === 16471) {\nreturn parseDynamicImportStatement(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp);\n}\nif (goalMode !== true) {\nreturn THROW_RANGE('The `import` keyword can only be used with the module goal', $tp_import_start, $tp_import_stop);\n}\nif (isGlobalToplevel === false) {\nreturn THROW_RANGE('The `import` keyword is only supported at the top level', $tp_import_start, $tp_import_stop);\n}\nAST_open(astProp, {type:'ImportDeclaration', loc:undefined, specifiers:[], source:undefined});\nif (isIdentToken(tok_getType())) {\nparseImportDefault(lexerFlags, scoop);\nif (tok_getType() === 16480) {\nskipToIdentStarCurlyOpen(lexerFlags);\nif (tok_getType() === 82009) {\nparseImportNamespace(lexerFlags, scoop);\n} else if (tok_getType() === 16513) {\nparseImportObject(lexerFlags, scoop);\n} else {\nreturn THROW_RANGE('A default import can only be followed by a star or object specifier', tok_getStart(), tok_getStop());\n}\n} else if (tok_getType() === 2094) {\nskipToStringOrDie(lexerFlags);\n} else {\nreturn THROW_RANGE('The default `import` should be followed by another specifier or `from`', $tp_import_start, tok_getStop());\n}\n} else if (tok_getType() === 82009) {\nparseImportNamespace(lexerFlags, scoop);\n} else if (tok_getType() === 16513) {\nparseImportObject(lexerFlags, scoop);\n} else {\nif (!isStringToken(tok_getType())) {\nreturn THROW_RANGE(('Expected a valid token after the `import` keyword, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\n}\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nAST_setStringLiteral('source', $tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\n}\nfunction parseImportDefault(lexerFlags, scoop) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, BINDING_TYPE_CONST, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, BINDING_TYPE_LET, 3);\nskipToAsCommaFrom(lexerFlags);\nAST_setNode('specifiers', {type:'ImportDefaultSpecifier', loc:AST_getClosedLoc($tp_ident_start, $tp_ident_line, $tp_ident_column), local:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\n}\nfunction parseImportObject(lexerFlags, scoop) {\nskipToIdentCurlyClose(lexerFlags);\nwhile (isIdentToken(tok_getType())) {\nparseImportSpecifier(lexerFlags, scoop);\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n}\nif (tok_getType() !== 16517) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Import object cannot have spread', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16489) {\nreturn THROW_RANGE('Import object uses `as` to alias (`{a as y}`), not colon (`{a: y}`)', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE(('Missing import definition closing curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToFromOrDie(lexerFlags);\nskipToStringOrDie(lexerFlags);\n}\nfunction parseImportSpecifier(lexerFlags, scoop) {\nlet $tp_name_line = tok_getLine();\nlet $tp_name_column = tok_getColumn();\nlet $tp_name_start = tok_getStart();\nlet $tp_name_stop = tok_getStop();\nlet $tp_name_canon = tok_getCanoN();\nlet $tp_local_type = tok_getType();\nlet $tp_local_line = tok_getLine();\nlet $tp_local_column = tok_getColumn();\nlet $tp_local_start = tok_getStart();\nlet $tp_local_stop = tok_getStop();\nlet $tp_local_canon = tok_getCanoN();\nskipToAsCommaCurlyClose(lexerFlags);\nif (tok_getType() === 2073) {\nskipToIdentOrDie(lexerFlags);\n$tp_local_type = tok_getType();\n$tp_local_line = tok_getLine();\n$tp_local_column = tok_getColumn();\n$tp_local_start = tok_getStart();\n$tp_local_stop = tok_getStop();\n$tp_local_canon = tok_getCanoN();\nskipAny(lexerFlags);\n}\nfatalBindingIdentCheck($tp_local_type, $tp_local_start, $tp_local_stop, $tp_local_canon, BINDING_TYPE_CONST, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_local_start, $tp_local_stop, $tp_local_canon, BINDING_TYPE_LET, 1);\nAST_setNode('specifiers', {type:'ImportSpecifier', loc:AST_getClosedLoc($tp_name_start, $tp_name_line, $tp_name_column), imported:AST_getIdentNode($tp_name_start, $tp_name_stop, $tp_name_line, $tp_name_column, $tp_name_canon), local:AST_getIdentNode($tp_local_start, $tp_local_stop, $tp_local_line, $tp_local_column, $tp_local_canon)});\n}\nfunction parseImportNamespace(lexerFlags, scoop) {\nlet $tp_star_line = tok_getLine();\nlet $tp_star_column = tok_getColumn();\nlet $tp_star_start = tok_getStart();\nskipAny(lexerFlags);\nif (tok_getType() !== 2073) {\nreturn THROW_RANGE(('Next token should be `as` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nskipToIdentOrDie(lexerFlags);\nlet $tp_local_type = tok_getType();\nlet $tp_local_line = tok_getLine();\nlet $tp_local_column = tok_getColumn();\nlet $tp_local_start = tok_getStart();\nlet $tp_local_stop = tok_getStop();\nlet $tp_local_canon = tok_getCanoN();\nskipToFromOrDie(lexerFlags);\nfatalBindingIdentCheck($tp_local_type, $tp_local_start, $tp_local_stop, $tp_local_canon, BINDING_TYPE_CONST, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_local_start, $tp_local_stop, $tp_local_canon, BINDING_TYPE_LET, 1);\nAST_setNode('specifiers', {type:'ImportNamespaceSpecifier', loc:AST_getClosedLoc($tp_star_start, $tp_star_line, $tp_star_column), local:AST_getIdentNode($tp_local_start, $tp_local_stop, $tp_local_line, $tp_local_column, $tp_local_canon)});\nskipToStringOrDie(lexerFlags);\n}\nfunction parseLetDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nif (isIdentToken(tok_getType())) {\nlet $tp_binding_type = tok_getType();\nlet $tp_binding_start = tok_getStart();\nlet $tp_binding_stop = tok_getStop();\nlet $tp_binding_canon = tok_getCanoN();\nlet identBindingErrorMsg = ((tok_getNlwas() === true)? nonFatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, BINDING_TYPE_LET, lexerFlags) : '');\nif (identBindingErrorMsg !== '') {\nif ([2075, 2126, 2072, 2088, 2098, 2102, 2103, 2107, 2108, 2109, 2110, 2113].includes(tok_getType())) {\nreturn THROW_RANGE((('Attempted to create a `let` binding on special reserved keyword `' + tok_sliceInput($tp_binding_start, $tp_binding_stop)) + '` but: ') + identBindingErrorMsg, $tp_binding_start, $tp_binding_stop);\n}\nreturn THROW_RANGE(('`let` must be a declaration in strict mode but the next ident is a reserved keyword (`' + tok_sliceInput($tp_binding_start, $tp_binding_stop)) + '`)', $tp_binding_start, $tp_binding_stop);\n}\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, BINDING_TYPE_LET, 1, undefined, undefined, astProp);\n} else if (((tok_getType() === 16509) || (tok_getType() === 16513))) {\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, BINDING_TYPE_LET, 1, undefined, undefined, astProp);\n} else if ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let declaration missing binding names and `let` cannot be a regular var or label name in strict mode', $tp_ident_start, $tp_ident_stop);\n} else {\n_parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\n}\nfunction parseLetExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('`let` declaration not allowed here and `let` cannot be a regular var or label name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nif (tok_getType() === 16509) {\nreturn THROW_RANGE('It is never valid for an expression statement to begin with `let[`, and a `let` declaration would not be valid here', $tp_ident_start, tok_getStop());\n}\n_parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nfunction _parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp) {\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nlet $tp_next_type = tok_getType();\nif ((($tp_next_type === 67636) || ($tp_next_type === 67636))) {\nreturn THROW_RANGE('Cannot use `let` as a regular var name as the lhs of `in` or `instanceof` in a toplevel expression statement', tok_getStart(), tok_getStop());\n}\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nlet assignable = parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, true, 'expression');\nassignable = parseValueTail(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignable, 4, false, 'expression');\nparseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, assignable, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseReturnStatement(lexerFlags, astProp) {\nlet $tp_return_line = tok_getLine();\nlet $tp_return_column = tok_getColumn();\nlet $tp_return_start = tok_getStart();\nif (((!allowGlobalReturn) && ((lexerFlags & 256) === 256))) {\nreturn THROW_RANGE('Not configured to parse `return` statement in global, bailing', $tp_return_start, $tp_return_start + 1);\n}\nskipToStatementStart(lexerFlags);\nAST_open(astProp, {type:'ReturnStatement', loc:undefined, argument:undefined});\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\nAST_set('argument', null);\n} else {\nif (((((((tok_getNlwas() === false) && (tok_getType() !== 2097173))) && (tok_getType() !== 16490))) && (tok_getType() !== 16517))) {\nparseExpressions(lexerFlags, 'argument');\n} else {\nAST_set('argument', null);\n}\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_return_start, $tp_return_line, $tp_return_column);\n}\nfunction parseSwitchStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_switch_line = tok_getLine();\nlet $tp_switch_column = tok_getColumn();\nlet $tp_switch_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'SwitchStatement', loc:undefined, discriminant:undefined, cases:[]});\nlet lexerFlagsForSwitch = (lexerFlags | 6400) ^ 6400;\nparseStatementHeader(lexerFlagsForSwitch, 'discriminant');\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Missing opening curly of `switch` body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToSwitchBody(lexerFlagsForSwitch);\nlet casesScoop = SCOPE_addLayer(scoop, SCOPE_LAYER_SWITCH, 'parseSwitchStatement');\nif (options_exposeScopes) AST_set('$scope', casesScoop);\nparseSwitchCases(lexerFlagsForSwitch | 1024, casesScoop, labelSet, 'cases');\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Missing the closing curly of the switch body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\nAST_close($tp_switch_start, $tp_switch_line, $tp_switch_column);\n}\nfunction parseSwitchCases(lexerFlags, scoop, labelSet, astProp) {\nlet hadDefault = false;\nwhile (true) {\nlet $tp_caseDefault_line = tok_getLine();\nlet $tp_caseDefault_column = tok_getColumn();\nlet $tp_caseDefault_start = tok_getStart();\nif (tok_getType() === 2077) {\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'SwitchCase', loc:undefined, test:undefined, consequent:[]});\nparseExpressions(lexerFlags, 'test');\nif (tok_getType() !== 16489) {\nreturn THROW_RANGE('Missing colon after case expr', tok_getStart(), tok_getStop());\n}\n} else if (tok_getType() === 2083) {\nif (hadDefault) {\nreturn THROW_RANGE('Found second `default` in same switch', tok_getStart(), tok_getStop());\n}\nhadDefault = true;\nskipToColonOrDie(lexerFlags);\nAST_open(astProp, {type:'SwitchCase', loc:undefined, test:null, consequent:[]});\n} else {\nbreak;\n}\nskipToStatementStart(lexerFlags);\nwhile (((((tok_getType() !== 16517) && (tok_getType() !== 2077))) && (tok_getType() !== 2083))) {\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 3, null, 'consequent');\n}\nAST_close($tp_caseDefault_start, $tp_caseDefault_line, $tp_caseDefault_column);\n}\n}\nfunction parseThrowStatement(lexerFlags, astProp) {\nlet $tp_throw_line = tok_getLine();\nlet $tp_throw_column = tok_getColumn();\nlet $tp_throw_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'ThrowStatement', loc:undefined, argument:undefined});\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Found a newline between `throw` and its argument but that is not allowed', $tp_throw_start, tok_getStart());\n}\nlet tmpLexerFlags = (lexerFlags | 1824) ^ 1824;\nparseExpressions(tmpLexerFlags, 'argument');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_throw_start, $tp_throw_line, $tp_throw_column);\n}\nfunction parseTryStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_try_line = tok_getLine();\nlet $tp_try_column = tok_getColumn();\nlet $tp_try_start = tok_getStart();\nlet $tp_try_stop = tok_getStop();\nskipToCurlyOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'TryStatement', loc:undefined, block:undefined, handler:undefined, finalizer:undefined});\nparseBlockStatement(lexerFlags, scoop, labelSet, 'block');\nlet hasEither = false;\nif (tok_getType() === 2078) {\nhasEither = true;\nlet $tp_catch_line = tok_getLine();\nlet $tp_catch_column = tok_getColumn();\nlet $tp_catch_start = tok_getStart();\nskipAny(lexerFlags);\nAST_open('handler', {type:'CatchClause', loc:undefined, param:undefined, body:undefined});\nlet catchHeadScoop = SCOPE_addLayer(scoop, SCOPE_LAYER_CATCH_HEAD, 'parseTryStatement(catch-var)');\nlet catchBodyScoop = SCOPE_addLayer(catchHeadScoop, SCOPE_LAYER_CATCH_BODY, 'parseTryStatement(catch-body)');\nif (options_exposeScopes) AST_set('$scope', catchBodyScoop);\nif (tok_getType() === 16513) {\nif (!allowOptionalCatchBinding) {\nreturn THROW_RANGE('Missing the `catch` clause. Optional catch clause is only supported since ES10  ES2019', tok_getStart(), tok_getStop());\n}\nAST_set('param', null);\n} else if (tok_getType() === 16471) {\nskipToBindingStart(lexerFlags);\nif (tok_getType() === 16472) {\nreturn THROW_RANGE('The catch clause must have a binding', tok_getStart(), tok_getStop());\n}\nlet $tp_binding_line = tok_getLine();\nlet $tp_binding_column = tok_getColumn();\nlet $tp_binding_start = tok_getStart();\nparseBinding(lexerFlags | 4096, $tp_binding_start, $tp_binding_line, $tp_binding_column, catchHeadScoop, BINDING_TYPE_CATCH_OTHER, 4, false, undefined, undefined, 'param');\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Catch clause requires exactly one parameter, not more (and no trailing comma)', tok_getStart(), tok_getStop());\n}\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing right paren for the catch clause, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\n} else {\nreturn THROW_RANGE(('Missing start of catch clause (`(`) or start of catch body (`{`), found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nparseBlockStatement(lexerFlags, catchBodyScoop, labelSet, 'body');\nAST_close($tp_catch_start, $tp_catch_line, $tp_catch_column);\n} else {\nAST_set('handler', null);\n}\nif (tok_getType() === 2092) {\nhasEither = true;\nskipToCurlyOpenOrDie(lexerFlags);\nlet finallyScoop = SCOPE_addLayer(scoop, SCOPE_LAYER_FINALLY, 'parseTryStatement(finally)');\nparseBlockStatement(lexerFlags, finallyScoop, labelSet, 'finalizer');\n} else {\nAST_set('finalizer', null);\n}\nAST_close($tp_try_start, $tp_try_line, $tp_try_column);\nif (!hasEither) {\nreturn THROW_RANGE('Try must have catch or finally', $tp_try_start, $tp_try_stop);\n}\n}\nfunction parseVarStatement(lexerFlags, scoop, astProp) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_var_start, $tp_var_line, $tp_var_column, scoop, BINDING_TYPE_VAR, 1, undefined, undefined, astProp);\n}\nfunction parseWhileStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_while_line = tok_getLine();\nlet $tp_while_column = tok_getColumn();\nlet $tp_while_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'WhileStatement', loc:undefined, test:undefined, body:undefined});\nparseStatementHeader(lexerFlags, 'test');\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nAST_close($tp_while_start, $tp_while_line, $tp_while_column);\n}\nfunction parseIdentLabelOrExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseExpressionsAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp) {\nif ((($tp_ident_type !== 2088) && ($tp_ident_type !== 2072))) {\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, BINDING_TYPE_NONE, lexerFlags);\n}\nlet set = labelSet;\nwhile (set) {\nif (set.statementLabels.has($tp_ident_canon)) {\nreturn THROW_RANGE('Saw the same label twice which is not allowed', $tp_ident_start, $tp_ident_stop);\n}\nset = set.parentLabels;\n}\nlabelSet = wrapLabelSet(labelSet, 'labelled statement');\nlabelSet.statementLabels.add($tp_ident_canon);\nskipToStatementStart(lexerFlags);\nif (fdState === 2) {\nfdState = 1;\n}\nif (nestedLabels === null) {\nnestedLabels = new Set();\n}\nnestedLabels.add($tp_ident_canon);\nif ((isIdentToken(tok_getType()) && (((((tok_getType() === 2093) || (tok_getType() === 2124))) || (tok_getType() === 2085))))) {\nlabelSet.iterationLabels = nestedLabels;\n}\nAST_open(astProp, {type:'LabeledStatement', loc:undefined, label:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon), body:undefined});\nparseNestedBodyPart(lexerFlags, scoop, labelSet, true, fdState, nestedLabels, 'body');\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parsePunctuatorStatement(lexerFlags, scoop, labelSet, astProp) {\nif (tok_getType() === 16513) {\nlet blockScoop = SCOPE_addLayer(scoop, SCOPE_LAYER_BLOCK, 'parsePunctuatorStatement.block');\nparseBlockStatement(lexerFlags, blockScoop, labelSet, astProp);\nreturn;\n}\nif (tok_getType() === 16490) {\nparseEmptyStatement(lexerFlags, astProp);\nreturn;\n}\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseExpressions(lexerFlags, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseEmptyStatement(lexerFlags, astProp) {\nlet $tp_semi_line = tok_getLine();\nlet $tp_semi_column = tok_getColumn();\nlet $tp_semi_start = tok_getStart();\nskipToStatementStart(lexerFlags);\nAST_setNode(astProp, {type:'EmptyStatement', loc:AST_getClosedLoc($tp_semi_start, $tp_semi_line, $tp_semi_column)});\n}\nfunction parseWithStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_with_line = tok_getLine();\nlet $tp_with_column = tok_getColumn();\nlet $tp_with_start = tok_getStart();\nlet $tp_with_stop = tok_getStop();\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('The `with` statement is not allowed in strict mode', $tp_with_start, $tp_with_stop);\n}\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'WithStatement', loc:undefined, object:undefined, body:undefined});\nparseStatementHeader(lexerFlags, 'object');\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 1, null, 'body');\nAST_close($tp_with_start, $tp_with_line, $tp_with_column);\n}\nfunction parseAnyVarDeclaration(lexerFlags, $tp_binding_start, $tp_binding_line, $tp_binding_column, scoop, bindingType, bindingOrigin, exportedNames, exportedBindings, astProp) {\nif (((((!isIdentToken(tok_getType())) && (tok_getType() !== 16509))) && (tok_getType() !== 16513))) {\nreturn THROW_RANGE('Expected identifier, or array/object destructuring', tok_getStart(), tok_getStop());\n}\nlet keyword = ((bindingType === BINDING_TYPE_VAR)? 'var' : (((bindingType === BINDING_TYPE_LET)? 'let' : 'const')));\nAST_open(astProp, {type:'VariableDeclaration', loc:undefined, kind:keyword, declarations:[]});\nparseBindings(lexerFlags, scoop, bindingType, bindingOrigin, true, 0, exportedNames, exportedBindings, 'declarations');\nif (((bindingOrigin === 1) || (bindingOrigin === 3))) {\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_binding_start, $tp_binding_line, $tp_binding_column);\n}\nfunction parseBindings(lexerFlags, scoop, bindingType, bindingOrigin, defaultOptions, $tp_set_type, exportedNames, exportedBindings, astProp) {\nlet many = 0;\nlet inited = false;\nlet startWasObjectOrArray = ((tok_getType() === 16509) || (tok_getType() === 16513));\nlet paramsSimple = 1;\ndo {\n++many;\nlet $tp_bindingStart_type = tok_getType();\nlet $tp_bindingStart_line = tok_getLine();\nlet $tp_bindingStart_column = tok_getColumn();\nlet $tp_bindingStart_start = tok_getStart();\nlet wasRest = $tp_bindingStart_type === 16486;\nlet paramSimple = parseBinding(lexerFlags, $tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column, scoop, bindingType, bindingOrigin, defaultOptions, exportedNames, exportedBindings, astProp);\nif ((wasRest && ($tp_set_type === 2112))) {\nreturn THROW_RANGE('A setter can not have a rest arg (unless inside a pattern)', $tp_bindingStart_start, tok_getStart());\n}\nif (paramSimple === 4) {\ninited = true;\nparamsSimple = 3;\n} else if (paramSimple === 3) {\nparamsSimple = 3;\n} else if (paramSimple === 2) {\nif (paramsSimple === 1) {\nparamsSimple = 2;\n}\n}\nif (wasRest) {\nbreak;\n}\nif (tok_getType() !== 16480) break;\nskipToBindingStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif (bindingType === BINDING_TYPE_ARG) {\nif (allowTrailingFunctionComma) {\nreturn paramsSimple;\n}\nreturn THROW_RANGE('Targeted language version does not support trailing function arg comma', tok_getStart(), tok_getStop());\n}\n}\n} while (true);\nif (((many !== 1) && ($tp_set_type === 2112))) {\nreturn THROW_RANGE('Setters require exactly one parameter', tok_getStart(), tok_getStop());\n}\nif (((bindingOrigin === 2) && (((tok_getType() === 67636) || (tok_getType() === 2106))))) {\nif (many !== 1) {\nreturn THROW_RANGE('For-in and for-of can only have one binding, found ' + many, tok_getStart(), tok_getStop());\n}\nif ((inited && ((((((((startWasObjectOrArray || (options_webCompat === false))) || (bindingType !== BINDING_TYPE_VAR))) || (tok_getType() === 2106))) || ((lexerFlags & 8192) === 8192))))) {\nreturn THROW_RANGE('For-in and for-of binding can not have an init', tok_getStart(), tok_getStop());\n}\n}\nreturn paramsSimple;\n}\nfunction parseBinding(lexerFlags, $tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column, scoop, bindingType, bindingOrigin, defaultsOption, exportedNames, exportedBindings, astProp) {\nlet mustHaveInit = false;\nlet paramSimple = 0;\nif (isIdentToken(tok_getType())) {\nlet $tp_binding_type = tok_getType();\nlet $tp_binding_start = tok_getStart();\nlet $tp_binding_stop = tok_getStop();\nlet $tp_binding_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType, lexerFlags);\nif (bindingType === BINDING_TYPE_CATCH_OTHER) {\nbindingType = BINDING_TYPE_CATCH_IDENT;\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType);\naddNameToExports(exportedNames, $tp_binding_start, $tp_binding_stop, $tp_binding_canon);\naddBindingToExports(exportedBindings, $tp_binding_canon);\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipRex(lexerFlags);\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nif ((((lexerFlags & 8192) === 0) && (nonFatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType, lexerFlags | 8192) !== ''))) {\nparamSimple = 2;\n} else {\nparamSimple = 1;\n}\n} else if (tok_getType() === 16513) {\nlet destructible = parseObjectOuter(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(destructible, bindingType);\nAST_destruct(astProp);\nparamSimple = 3;\nif (((((bindingOrigin !== 4) && (((bindingOrigin !== 2) || (((tok_getType() !== 67636) && (tok_getType() !== 2106))))))) && (((((bindingType === BINDING_TYPE_CONST) || (bindingType === BINDING_TYPE_LET))) || (bindingType === BINDING_TYPE_VAR))))) {\nmustHaveInit = true;\n}\n} else if (tok_getType() === 16509) {\nlet destructible = parseArrayOuter(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(destructible, bindingType);\nAST_destruct(astProp);\nparamSimple = 3;\nif (((((bindingOrigin !== 4) && (((bindingOrigin !== 2) || (((tok_getType() !== 67636) && (tok_getType() !== 2106))))))) && (((((bindingType === BINDING_TYPE_CONST) || (bindingType === BINDING_TYPE_LET))) || (bindingType === BINDING_TYPE_VAR))))) {\nmustHaveInit = true;\n}\n} else if (tok_getType() === 16486) {\nif (bindingType !== BINDING_TYPE_ARG) {\nreturn THROW_RANGE('Rest is not allowed as toplevel for var/let/const declaration binding', tok_getStart(), tok_getStop());\n}\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, 16472, bindingType, 0, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(subDestruct, bindingType);\nparamSimple = 3;\n} else if (tok_getType() !== 16472) {\nreturn THROW_RANGE('Expected to parse a(nother) binding but none was found', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 49264) {\nif (bindingOrigin === 4) {\nreturn THROW_RANGE('Catch clause can not have init / default', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nparamSimple = 4;\nif (defaultsOption === false) {\nAST_wrapClosedCustom(astProp, {type:'AssignmentPattern', loc:undefined, left:undefined, right:undefined}, 'left');\nparseExpression(lexerFlags, 'right');\nAST_close($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column);\n} else {\nAST_wrapClosedCustom('declarations', {type:'VariableDeclarator', loc:undefined, id:undefined, init:undefined}, 'id');\nparseExpression(lexerFlags, 'init');\nAST_close($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column);\n}\n} else if (mustHaveInit) {\nreturn THROW_RANGE('Declaration destructuring must have init', tok_getStart(), tok_getStop());\n} else if (((bindingType === BINDING_TYPE_CONST) && (((bindingOrigin !== 2) || (((tok_getType() === 16490) || (tok_getType() === 16480))))))) {\nreturn THROW_RANGE('Constants must be initialized', tok_getStart(), tok_getStop());\n} else if (defaultsOption === true) {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nif (bindingOrigin === 2) {\nreturn THROW_RANGE('Illegal regex after binding declaration in `for` header', tok_getStart(), tok_getStop());\n}\nASSERT_ASI_REGEX_NEXT = true;\n}\nAST_setNodeDangerously('declarations', {type:'VariableDeclarator', loc:AST_getClosedLoc($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column), id:AST_popNode('declarations'), init:null});\n} else {\n\n}\nreturn paramSimple;\n}\nfunction fatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags) {\nlet str = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (str !== '') THROW_RANGE(`Cannot use this name (\\`${tok_sliceInput($tp_ident_start, $tp_ident_stop)}\\`) as a variable name because: ${str}`, $tp_ident_start, $tp_ident_stop);\n}\nfunction nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags) {\nif (($tp_ident_stop - $tp_ident_start) === $tp_ident_canon.length) {\nif ($tp_ident_type === 2048) return '';\nreturn nonFatalBindingIdentCheckByEnum(lexerFlags, $tp_ident_type, $tp_ident_canon, bindingType);\n}\nreturn nonFatalBindingIdentCheckByString(lexerFlags, $tp_ident_canon, bindingType);\n}\nfunction nonFatalBindingIdentCheckByEnum(lexerFlags, $tp_ident_type, $tp_ident_canon, bindingType) {\nswitch ($tp_ident_type) {\ncase 2076:\n\ncase 2077:\n\ncase 2078:\n\ncase 2079:\n\ncase 2080:\n\ncase 2081:\n\ncase 2082:\n\ncase 2083:\n\ncase 2084:\n\ncase 2085:\n\ncase 2086:\n\ncase 2089:\n\ncase 2090:\n\ncase 2092:\n\ncase 2093:\n\ncase 2095:\n\ncase 2097:\n\ncase 2099:\n\ncase 67636:\n\ncase 67637:\n\ncase 2104:\n\ncase 2111:\n\ncase 2114:\n\ncase 2115:\n\ncase 2117:\n\ncase 2118:\n\ncase 2120:\n\ncase 2121:\n\ncase 2122:\n\ncase 2123:\n\ncase 2124:\n\ncase 2125:\n\ncase 2105:\n\ncase 2119:\n\ncase 2091:\n\ncase 2087:\nreturn 'Cannot never use this reserved word as a variable name';\ncase 2103:\nif (bindingType === BINDING_TYPE_CLASS) return 'Can not use `let` as a class name';\nif (((bindingType === BINDING_TYPE_LET) || (bindingType === BINDING_TYPE_CONST))) return 'Can not use `let` when binding through `let` or `const`';\nif ((lexerFlags & 8192) === 8192) return 'Can not use `let` as variable name in strict mode';\nreturn '';\ncase 2113:\nif ((lexerFlags & 8192) === 8192) return '`static` is a reserved word in strict mode';\nreturn '';\ncase 2088:\n\ncase 2072:\nif ((lexerFlags & 8192) === 8192) return ('Cannot create a binding named `' + $tp_ident_canon) + '` in strict mode';\nreturn '';\ncase 2098:\n\ncase 2107:\n\ncase 2109:\n\ncase 2102:\n\ncase 2108:\n\ncase 2110:\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nreturn '';\ncase 2075:\nif (allowAsyncFunctions) {\nif (goalMode === true) return 'Await is illegal as var name with module goal';\nif ((lexerFlags & 8) !== 0) return 'Await not allowed here';\n}\nreturn '';\ncase 2126:\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nif ((lexerFlags & 128) !== 0) return 'Cannot use this reserved word as a variable name inside a generator';\nreturn '';\n}\nreturn '';\n}\nfunction nonFatalBindingIdentCheckByString(lexerFlags, $tp_ident_canon, bindingType) {\nswitch ($tp_ident_canon) {\ncase 'break':\n\ncase 'case':\n\ncase 'catch':\n\ncase 'class':\n\ncase 'const':\n\ncase 'continue':\n\ncase 'debugger':\n\ncase 'default':\n\ncase 'delete':\n\ncase 'do':\n\ncase 'else':\n\ncase 'export':\n\ncase 'extends':\n\ncase 'finally':\n\ncase 'for':\n\ncase 'function':\n\ncase 'if':\n\ncase 'import':\n\ncase 'in':\n\ncase 'instanceof':\n\ncase 'new':\n\ncase 'return':\n\ncase 'super':\n\ncase 'switch':\n\ncase 'this':\n\ncase 'throw':\n\ncase 'try':\n\ncase 'typeof':\n\ncase 'var':\n\ncase 'void':\n\ncase 'while':\n\ncase 'with':\n\ncase 'null':\n\ncase 'true':\n\ncase 'false':\n\ncase 'enum':\nreturn ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\ncase 'let':\nif (bindingType === BINDING_TYPE_CLASS) return 'Can not use `let` as a class name';\nif (((bindingType === BINDING_TYPE_LET) || (bindingType === BINDING_TYPE_CONST))) return 'Can not use `let` when binding through `let` or `const`';\nif ((lexerFlags & 8192) === 8192) return 'Can not use `let` as variable name in strict mode';\nreturn '';\ncase 'static':\nif ((lexerFlags & 8192) === 8192) return ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\nreturn '';\ncase 'eval':\n\ncase 'arguments':\nif ((lexerFlags & 8192) === 8192) return ('Cannot create a binding named `' + $tp_ident_canon) + '` in strict mode';\nreturn '';\ncase 'implements':\n\ncase 'package':\n\ncase 'protected':\n\ncase 'interface':\n\ncase 'private':\n\ncase 'public':\nif ((lexerFlags & 8192) === 8192) return ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\nreturn '';\ncase 'await':\nif (allowAsyncFunctions) {\nif (goalMode === true) return 'Await is illegal as var name with module goal';\nif ((lexerFlags & 8) !== 0) return 'Await not allowed here';\n}\nreturn '';\ncase 'yield':\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nif ((lexerFlags & 128) !== 0) return 'Cannot use this reserved word as a variable name inside a generator';\nreturn '';\n}\nreturn '';\n}\nfunction parseExpression(lexerFlags, astProp) {\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet $tp_start_stop = tok_getStop();\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nreturn parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, assignable, astProp);\n}\nfunction parseExpressionAfterLiteral(lexerFlags, $tp_literal_start, $tp_literal_stop, $tp_literal_line, $tp_literal_column, astProp) {\nlet assignable = parseValueTail(lexerFlags, $tp_literal_start, $tp_literal_line, $tp_literal_column, 16, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_literal_start, $tp_literal_stop, $tp_literal_line, $tp_literal_column, assignable, astProp);\n}\nfunction parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, astProp) {\nlet assignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, astProp);\nassignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, assignable, astProp);\nreturn assignable;\n}\nfunction parseExpressionAfterAsyncAsVarName(lexerFlags, stmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp) {\nif (stmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nlet assignable = 16;\nif (tok_getType() === 16499) {\nassignable = parseArrowParenlessFromPunc(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, allowAssignment, 1, 0, astProp);\n} else {\nassignable = parseIdentOrParenlessArrow(lexerFlags, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 32, allowAssignment, astProp);\nassignable = parseValueTail(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, assignable, isNewArg, false, astProp);\nif (stmtOrExpr === 2) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, assignable, astProp);\n}\n}\nif (stmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\nreturn assignable;\n}\nfunction parseParenlessArrowAfterAsync(lexerFlags, fromStmtOrExpr, allowAssignment, $tp_async_start, $tp_async_line, $tp_async_column, astProp) {\nif (fromStmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nif (tok_getType() === 2075) {\nreturn THROW_RANGE('Cannot use `await` as an arg name with async arrows', tok_getStart(), tok_getStop());\n}\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nlet isSimple = 1;\nif (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nisSimple = 2;\n}\nskipToArrowOrDie(lexerFlags);\nparseArrowParenlessFromPunc(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, isSimple, 2074, astProp);\nif (fromStmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\n}\nfunction isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon) {\nif ($tp_ident_canon.length === ($tp_ident_stop - $tp_ident_start)) {\nreturn isStrictOnlyKeywordByEnum($tp_ident_type);\n}\nreturn isStrictOnlyKeywordByString($tp_ident_canon);\n}\nfunction isStrictOnlyKeywordByEnum($tp_ident_type) {\nswitch ($tp_ident_type) {\ncase 2088:\n\ncase 2072:\n\ncase 2098:\n\ncase 2102:\n\ncase 2103:\n\ncase 2107:\n\ncase 2108:\n\ncase 2109:\n\ncase 2110:\n\ncase 2113:\n\ncase 2126:\nreturn true;\n}\nreturn false;\n}\nfunction isStrictOnlyKeywordByString($tp_ident_canon) {\nswitch ($tp_ident_canon) {\ncase 'eval':\n\ncase 'arguments':\n\ncase 'implements':\n\ncase 'interface':\n\ncase 'let':\n\ncase 'package':\n\ncase 'private':\n\ncase 'protected':\n\ncase 'public':\n\ncase 'static':\n\ncase 'yield':\nreturn true;\n}\nreturn false;\n}\nfunction parseExpressionFromOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_stop, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp) {\nif (isAnyAssignmentOp()) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE(('Cannot assign to lhs (starting with `' + tok_sliceInput($tp_firstExpr_start, $tp_firstExpr_stop)) + '`) because it is not a valid assignment target', tok_getStart(), tok_getStop());\n}\nreturn parseExpressionFromAssignmentOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp);\n}\nreturn parseExpressionFromBinaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp);\n}\nfunction parseExpressionFromAssignmentOp(lexerFlags, $tp_firstAssignment_start, $tp_firstAssignment_line, $tp_firstAssignment_column, lhsAssignable, astProp) {\nlet $tp_eq_type = tok_getType();\nAST_convertArrayToPattern($tp_eq_type, astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:tok_sliceInput(tok_getStart(), tok_getStop()), right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet rhsAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_firstAssignment_start, $tp_firstAssignment_line, $tp_firstAssignment_column);\nreturn setNotAssignable(mergeAssignable(rhsAssignable, lhsAssignable));\n}\nfunction parseExpressionFromBinaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp) {\nif ((assignable & 1024) === 1024) return assignable;\nlet $tp_next_type = tok_getType();\nlet repeat = false;\ndo {\nrepeat = false;\nif ($tp_next_type === 16506) {\nlet nowAssignable = parseExpressionFromTernaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, astProp);\nassignable = setNotAssignable(nowAssignable | assignable);\nrepeat = true;\n} else if (isNonAssignBinOp($tp_next_type, lexerFlags)) {\nlet nowAssignable = parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, 0, astProp);\nassignable = setNotAssignable(nowAssignable | assignable);\nrepeat = true;\n}\n$tp_next_type = tok_getType();\n} while (repeat);\nif (isAnyAssignmentOp()) {\nreturn THROW_RANGE('Can not have an assignment after a non-assignment operator', tok_getStart(), tok_getStop());\n}\nreturn assignable;\n}\nfunction preventNullishWithLogic($tp_op_type, $tp_op_start, $tp_op_stop, coalSeen) {\nif ((($tp_op_type === 82005) || ($tp_op_type === 82051))) {\nif (coalSeen === 1) {\nreturn THROW_RANGE('Cannot use `??` and `&&`/`||` in the same expression without some grouping', $tp_op_start, $tp_op_stop);\n}\nreturn 2;\n}\nif ($tp_op_type === 82044) {\nif (coalSeen === 2) {\nreturn THROW_RANGE('Cannot use `??` and `&&`/`||` in the same expression without some grouping', $tp_op_start, $tp_op_stop);\n}\nreturn 1;\n}\nreturn coalSeen;\n}\nfunction parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, coalSeen, astProp) {\nlet $tp_op_type = tok_getType();\nlet $tp_op_start = tok_getStart();\nlet $tp_op_stop = tok_getStop();\ncoalSeen = preventNullishWithLogic($tp_op_type, $tp_op_start, $tp_op_stop, coalSeen);\nlet AST_nodeName = (((((($tp_op_type === 82005) || ($tp_op_type === 82051))) || ($tp_op_type === 82044)))? 'LogicalExpression' : 'BinaryExpression');\nAST_wrapClosedCustom(astProp, {type:AST_nodeName, loc:undefined, left:undefined, operator:tok_sliceInput($tp_op_start, $tp_op_stop), right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet $tp_rightExprStart_line = tok_getLine();\nlet $tp_rightExprStart_column = tok_getColumn();\nlet $tp_rightExprStart_start = tok_getStart();\nlet assignable = parseValue(lexerFlags, false, 4, false, 'right');\nlet otherStrength = getStrength($tp_op_type, $tp_op_start, $tp_op_stop);\nwhile (continueParsingBinOp(lexerFlags, otherStrength)) {\nassignable |= parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_rightExprStart_start, $tp_rightExprStart_line, $tp_rightExprStart_column, coalSeen, 'right');\n}\npreventNullishWithLogic(tok_getType(), tok_getStart(), tok_getStop(), coalSeen);\nAST_close($tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column);\nreturn setNotAssignable(assignable);\n}\nfunction parseExpressionFromTernaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, astProp) {\nAST_wrapClosedCustom(astProp, {type:'ConditionalExpression', loc:undefined, test:undefined, consequent:undefined, alternate:undefined}, 'test');\nskipToExpressionStart(lexerFlags);\nlet midAssignable = parseExpression(((lexerFlags | 32) ^ 32) | 4096, 'consequent');\nif (tok_getType() !== 16489) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Can not use comma inside ternary expressions', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Unexpected character inside ternary', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nlet rhsAssignable = parseExpression(lexerFlags, 'alternate');\nAST_close($tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column);\nreturn setNotAssignable(midAssignable | rhsAssignable);\n}\nfunction parseExpressionsAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp) {\nlet assignableForPiggies = parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, BINDING_TYPE_NONE, astProp);\nif (tok_getType() === 16480) {\nassignableForPiggies = _parseExpressions(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignableForPiggies, astProp);\n}\nreturn assignableForPiggies;\n}\nfunction parseExpressions(lexerFlags, astProp) {\nlet $tp_startOfFirstExpr_line = tok_getLine();\nlet $tp_startOfFirstExpr_column = tok_getColumn();\nlet $tp_startOfFirstExpr_start = tok_getStart();\nlet assignableForPiggies = parseExpression(lexerFlags, astProp);\nif (tok_getType() === 16480) {\nassignableForPiggies = _parseExpressions(lexerFlags, $tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_column, assignableForPiggies, astProp);\n}\nreturn assignableForPiggies;\n}\nfunction _parseExpressions(lexerFlags, $tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_colun, assignableForPiggies, astProp) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nassignableForPiggies = __parseExpressions(lexerFlags, assignableForPiggies, 'expressions');\nAST_close($tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_colun);\nreturn assignableForPiggies;\n}\nfunction __parseExpressions(lexerFlags, assignableForPiggies, astProp) {\ndo {\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, astProp);\nassignableForPiggies |= nowAssignable;\n} while (tok_getType() === 16480);\nreturn setNotAssignable(assignableForPiggies);\n}\nfunction isAnyAssignmentOp() {\nif (!((tok_getType() & 32768) === 32768)) return false;\nif (tok_getType() !== 49244) return true;\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nfunction isNonAssignBinOp(type, lexerFlags) {\nif (!((type & 65536) === 65536)) return false;\nif (type === 82010) {\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nif (type === 67636) {\nreturn (lexerFlags & 32) === 0;\n}\nreturn true;\n}\nfunction getStrength(type, $tp_tokenStart, $tp_tokenStop) {\nswitch (type) {\ncase 82010:\nreturn 16;\ncase 82009:\nreturn 15;\ncase 82023:\nreturn 15;\ncase 82002:\nreturn 15;\ncase 82013:\nreturn 14;\ncase 82017:\nreturn 14;\ncase 82028:\nreturn 13;\ncase 82037:\nreturn 13;\ncase 82038:\nreturn 13;\ncase 82027:\nreturn 12;\ncase 82029:\nreturn 12;\ncase 82036:\nreturn 12;\ncase 82039:\nreturn 12;\ncase 67636:\nreturn 12;\ncase 67637:\nreturn 12;\ncase 82033:\nreturn 11;\ncase 82000:\nreturn 11;\ncase 82034:\nreturn 11;\ncase 82001:\nreturn 11;\ncase 82004:\nreturn 10;\ncase 82047:\nreturn 9;\ncase 82050:\nreturn 8;\ncase 82044:\nreturn 7;\ncase 82005:\nreturn 6;\ncase 82051:\nreturn 5;\n}\nTHROW_RANGE('Unknown operator', $tp_tokenStart, $tp_tokenStop);\n}\nfunction continueParsingBinOp(lexerFlags, otherStrength) {\nswitch (tok_getType()) {\ncase 82033:\nreturn 11 > otherStrength;\ncase 82000:\nreturn 11 > otherStrength;\ncase 82034:\nreturn 11 > otherStrength;\ncase 82001:\nreturn 11 > otherStrength;\ncase 82005:\nreturn 6 > otherStrength;\ncase 82051:\nreturn 5 > otherStrength;\ncase 82013:\nreturn 14 > otherStrength;\ncase 82017:\nreturn 14 > otherStrength;\ncase 82027:\nreturn 12 > otherStrength;\ncase 82036:\nreturn 12 > otherStrength;\ncase 82029:\nreturn 12 > otherStrength;\ncase 82039:\nreturn 12 > otherStrength;\ncase 82009:\nreturn 15 > otherStrength;\ncase 82023:\nreturn 15 > otherStrength;\ncase 82002:\nreturn 15 > otherStrength;\ncase 82028:\nreturn 13 > otherStrength;\ncase 82037:\nreturn 13 > otherStrength;\ncase 82038:\nreturn 13 > otherStrength;\ncase 67636:\nif ((lexerFlags & 32) === 32) {\nreturn false;\n}\nreturn 12 > otherStrength;\ncase 67637:\nreturn 12 > otherStrength;\ncase 82004:\nreturn 10 > otherStrength;\ncase 82047:\nreturn 9 > otherStrength;\ncase 82050:\nreturn 8 > otherStrength;\ncase 82044:\nreturn 7 > otherStrength;\ncase 82010:\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nreturn false;\n}\nfunction parseValue(lexerFlags, allowAssignment, isNewArg, leftHandSideExpression, astProp) {\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet assignable = parseValueHeadBody(lexerFlags, false, isNewArg, allowAssignment, leftHandSideExpression, astProp);\nreturn parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, assignable, isNewArg, leftHandSideExpression, astProp);\n}\nfunction parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, allowAssignment, astProp) {\nlet assignable = parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, 4, allowAssignment, false, astProp);\nreturn parseValueTail(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignable, 4, false, astProp);\n}\nfunction parseValueHeadBody(lexerFlags, maybe, isNewArg, allowAssignment, leftHandSideExpression, astProp) {\nlet start_for_assert;\nif (isIdentToken(tok_getType())) {\nreturn parseValueHeadBodyIdent(lexerFlags, isNewArg, BINDING_TYPE_NONE, allowAssignment, leftHandSideExpression, astProp);\n}\nif (isNumberStringRegex(tok_getType())) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nreturn 16;\n}\nif (isTemplateStart(tok_getType())) {\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nparseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, astProp);\nreturn 16;\n}\nif (isPunctuatorToken(tok_getType())) {\nif (tok_getType() === 16513) {\nlet skipInit = ((((((allowAssignment === true) && (leftHandSideExpression === false))) && (isNewArg === 4)))? true : false);\nlet wasDestruct = parseObjectOuter(lexerFlags, null, BINDING_TYPE_NONE, skipInit, undefined, undefined, astProp);\nreturn _parseValueHeadBodyAfterObjArr(wasDestruct);\n}\nif (tok_getType() === 16509) {\nlet skipInit = ((((((allowAssignment === true) && (leftHandSideExpression === false))) && (isNewArg === 4)))? true : false);\nlet wasDestruct = parseArrayOuter(lexerFlags, null, BINDING_TYPE_NONE, skipInit, undefined, undefined, astProp);\nreturn _parseValueHeadBodyAfterObjArr(wasDestruct);\n}\nif (tok_getType() === 16471) {\nreturn parseGroupToplevels(lexerFlags, 2, allowAssignment, 0, 0, 0, 0, 0, '', false, leftHandSideExpression, astProp);\n}\nif (tok_getType() === 16478) {\nreturn parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, '++', astProp);\n}\nif (tok_getType() === 16482) {\nreturn parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, '--', astProp);\n}\nif (tok_getType() === 82013) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '+', astProp);\n}\nif (tok_getType() === 82017) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '-', astProp);\n}\nif (tok_getType() === 16463) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '!', astProp);\n}\nif (tok_getType() === 16518) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '~', astProp);\n}\n}\nif (maybe === false) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Unexpected spread/rest dots', tok_getStart(), tok_getStart() + 1);\n}\nif (tok_getType() === 16485) {\nreturn THROW_RANGE('Unexpected dot', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Expected to parse a value', tok_getStart(), tok_getStop());\n}\nreturn 16;\n}\nfunction _parseValueHeadBodyAfterObjArr(wasDestruct) {\nif ((wasDestruct & 4) === 4) {\nreturn THROW_RANGE('Found a struct that must be destructured but was not', tok_getStart(), tok_getStop());\n}\nlet assignable = copyPiggies(0, wasDestruct);\nif ((wasDestruct & 1) === 0) {\nreturn setAssignable(assignable);\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseValueHeadBodyIdent(lexerFlags, isNewArg, bindingType, allowAssignment, leftHandSideExpression, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, leftHandSideExpression);\nreturn parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, isNewArg, allowAssignment, leftHandSideExpression, astProp);\n}\nfunction parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, isNewArg, allowAssignment, leftHandSideExpression, astProp) {\nswitch ($tp_ident_type) {\ncase 2072:\n{\nif (tok_getType() === 16499) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `arguments` as arg name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, true, 3, 0, astProp);\n}\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn verifyEvalArgumentsVar(lexerFlags);\n}\ncase 2074:\nreturn parseAsyncExpression(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, isNewArg, false, allowAssignment, leftHandSideExpression, astProp);\ncase 2075:\nreturn parseAwait(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, isNewArg, allowAssignment, astProp);\ncase 2079:\nreturn parseClassExpression(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2084:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'delete', isNewArg, astProp);\ncase 2088:\n{\nif (tok_getType() === 16499) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `eval` as arg name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, true, 3, 0, astProp);\n}\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn verifyEvalArgumentsVar(lexerFlags);\n}\ncase 2091:\nreturn parseFalseKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2095:\nparseFunctionExpression(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\nreturn 16;\ncase 2099:\nif (tok_getType() === 16471) {\nreturn parseDynamicImport(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, astProp);\n}\nreturn THROW_RANGE('Import keyword only allowed on toplevel or in a dynamic import', $tp_ident_start, $tp_ident_stop);\ncase 2103:\n;\nif (((bindingType === BINDING_TYPE_LET) || (bindingType === BINDING_TYPE_CONST))) {\nreturn THROW_RANGE('Can not use `let` when binding through `let` or `const`', $tp_ident_start, $tp_ident_stop);\n}\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `let` as variable name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\ncase 2104:\nlet newAssignable = parseNewKeyword(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp);\nreturn setNotAssignable(newAssignable);\ncase 2105:\nreturn parseNullKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2114:\nreturn parseSuperKeyword(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, astProp);\ncase 2119:\nreturn parseTrueKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2117:\nreturn parseThisKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2121:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'typeof', isNewArg, astProp);\ncase 2123:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'void', isNewArg, astProp);\ncase 2126:\nreturn parseYield(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, astProp);\n}\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nreturn parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\n}\nfunction verifyEvalArgumentsVar(lexerFlags) {\nif ((lexerFlags & 8192) === 0) return 32;\nif (isAnyAssignmentOp()) {\nreturn THROW_RANGE('Cannot assign to `eval` and `arguments` in strict mode', tok_getStart(), tok_getStop());\n}\nif (((tok_getType() === 16478) || (tok_getType() === 16482))) {\nreturn THROW_RANGE('Cannot assign to `eval` and `arguments` in strict mode', tok_getStart(), tok_getStop());\n}\nreturn 16;\n}\nfunction parseTrueKeyword($tp_true_start, $tp_true_line, $tp_true_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'BooleanLiteral', loc:AST_getClosedLoc($tp_true_start, $tp_true_line, $tp_true_column), value:true});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_true_start, $tp_true_line, $tp_true_column), value:true, raw:'true'});\n}\nreturn 16;\n}\nfunction parseFalseKeyword($tp_false_start, $tp_false_line, $tp_false_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'BooleanLiteral', loc:AST_getClosedLoc($tp_false_start, $tp_false_line, $tp_false_column), value:false});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_false_start, $tp_false_line, $tp_false_column), value:false, raw:'false'});\n}\nreturn 16;\n}\nfunction parseNullKeyword($tp_null_start, $tp_null_line, $tp_null_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'NullLiteral', loc:AST_getClosedLoc($tp_null_start, $tp_null_line, $tp_null_column)});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_null_start, $tp_null_line, $tp_null_column), value:null, raw:'null'});\n}\nreturn 16;\n}\nfunction parseSuperKeyword(lexerFlags, $tp_super_start, $tp_super_stop, $tp_super_line, $tp_super_column, astProp) {\nAST_setNode(astProp, {type:'Super', loc:AST_getClosedLoc($tp_super_start, $tp_super_line, $tp_super_column)});\nif (tok_getType() === 16471) {\nif ((lexerFlags & 16384) === 0) {\nreturn THROW_RANGE('Can only use `super()` in constructors of classes that extend another class', $tp_super_start, tok_getStop());\n}\nreturn 16;\n}\nif (((tok_getType() === 16509) || (tok_getType() === 16485))) {\nif ((lexerFlags & 32768) === 0) {\nif (tok_getType() === 16509) {\nreturn THROW_RANGE('Can only use `super[foo]` in class or object methods or in arrows nested in those methods/arrows', $tp_super_start, tok_getStop());\n} else {\nreturn THROW_RANGE('Can only use `super.foo` in class or object methods or in arrows nested in those methods/arrows', $tp_super_start, tok_getStop());\n}\n}\nreturn 16;\n}\nreturn THROW_RANGE('The `super` keyword can only be used as call or member expression', $tp_super_start, $tp_super_stop);\n}\nfunction parseNewKeyword(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp) {\nif (tok_getType() === 16485) return parseNewDotTarget(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp);\nreturn parseNewExpression(lexerFlags, $tp_new_start, $tp_new_line, $tp_new_column, astProp);\n}\nfunction parseNewDotTarget(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp) {\nif ((lexerFlags & 2) === 0) {\nreturn THROW_RANGE('Must be inside/nested a regular function to use `new.target`', $tp_new_start, tok_getStop());\n}\nskipToTargetOrDie(lexerFlags);\nlet $tp_property_line = tok_getLine();\nlet $tp_property_column = tok_getColumn();\nlet $tp_property_start = tok_getStart();\nlet $tp_property_stop = tok_getStop();\nlet $tp_property_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'MetaProperty', loc:AST_getClosedLoc($tp_new_start, $tp_new_line, $tp_new_column), meta:AST_getIdentNode($tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon), property:AST_getIdentNode($tp_property_start, $tp_property_stop, $tp_property_line, $tp_property_column, $tp_property_canon)});\nreturn 16;\n}\nfunction parseNewExpression(lexerFlags, $tp_new_start, $tp_new_line, $tp_new_column, astProp) {\nAST_open(astProp, {type:'NewExpression', loc:undefined, arguments:[], callee:undefined});\nif ((isIdentToken(tok_getType()) && (tok_getType() === 2099))) {\nreturn THROW_RANGE('Cannot use dynamic import as an argument to `new`, the spec simply does not allow it', $tp_new_start, tok_getStop());\n}\nlet assignableForPiggies = parseValue(lexerFlags, false, 3, false, 'callee');\nAST_close($tp_new_start, $tp_new_line, $tp_new_column);\nreturn setNotAssignable(assignableForPiggies);\n}\nfunction parseThisKeyword($tp_this_start, $tp_this_line, $tp_this_column, astProp) {\nAST_setNode(astProp, {type:'ThisExpression', loc:AST_getClosedLoc($tp_this_start, $tp_this_line, $tp_this_column)});\nreturn 16;\n}\nfunction parseUnary(lexerFlags, isNewArg, leftHandSideExpression, opName, astProp) {\nlet $tp_unary_line = tok_getLine();\nlet $tp_unary_column = tok_getColumn();\nlet $tp_unary_start = tok_getStart();\nlet $tp_unary_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('The unary expression `' + opName) + '` is not allowed here', $tp_unary_start, $tp_unary_stop);\n}\nskipToExpressionStart(lexerFlags);\nreturn _parseUnary(lexerFlags, $tp_unary_start, $tp_unary_stop, $tp_unary_line, $tp_unary_column, opName, isNewArg, astProp);\n}\nfunction _parseUnary(lexerFlags, $tp_unary_start, $tp_unary_stop, $tp_unary_line, $tp_unary_column, opName, isNewArg, astProp) {\nif (isNewArg === 3) {\nreturn THROW_RANGE(('Cannot `' + opName) + '` inside `new`', $tp_unary_start, $tp_unary_stop);\n}\nAST_open(astProp, {type:'UnaryExpression', loc:undefined, operator:opName, prefix:true, argument:undefined});\nlet assignable = parseValue(lexerFlags, false, 4, false, 'argument');\nif ((lexerFlags & 8192) === 8192) {\nif (((opName === 'delete') && (_path[_path.length - 1].argument.type === 'Identifier'))) {\nreturn THROW_RANGE('Cannot delete an identifier without tail, in strict mode', $tp_unary_start, $tp_unary_stop);\n}\n}\nAST_close($tp_unary_start, $tp_unary_line, $tp_unary_column);\nif (tok_getType() === 82010) {\nreturn THROW_RANGE('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)', tok_getStart(), tok_getStop());\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, opName, astProp) {\nlet $tp_punc_line = tok_getLine();\nlet $tp_punc_column = tok_getColumn();\nlet $tp_punc_start = tok_getStart();\nlet $tp_punc_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('An update expression `' + opName) + '` is not allowed here', $tp_punc_start, $tp_punc_stop);\n}\nif (isNewArg === 3) {\nreturn THROW_RANGE(('Cannot `new` on a `' + opName) + '` expr', $tp_punc_start, $tp_punc_stop);\n}\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'UpdateExpression', loc:undefined, argument:undefined, operator:opName, prefix:true});\nlet assignable = parseValue(lexerFlags, false, 4, false, 'argument');\nAST_throwIfIllegalUpdateArg('argument');\nAST_close($tp_punc_start, $tp_punc_line, $tp_punc_column);\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Cannot inc/dec a non-assignable value as prefix', $tp_punc_start, $tp_punc_stop);\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseYield(lexerFlags, $tp_yieldIdent_type, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, $tp_yieldIdent_canon, allowAssignment, astProp) {\nif ((lexerFlags & 128) !== 0) {\nreturn parseYieldKeyword(lexerFlags, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, allowAssignment, astProp);\n}\nreturn parseYieldVarname(lexerFlags, $tp_yieldIdent_type, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, $tp_yieldIdent_canon, allowAssignment, astProp);\n}\nfunction parseYieldKeyword(lexerFlags, $tp_yield_start, $tp_yield_stop, $tp_yield_line, $tp_yield_column, allowAssignment, astProp) {\nif ((lexerFlags & 64) === 64) {\nreturn THROW_RANGE('The `yield` keyword in arg default must be a var name but that is not allowed inside a generator', $tp_yield_start, $tp_yield_stop);\n}\nif (allowAssignment === false) {\nreturn THROW_RANGE('Did not expect to parse an AssignmentExpression but found `yield`', $tp_yield_start, $tp_yield_stop);\n}\nAST_open(astProp, {type:'YieldExpression', loc:undefined, delegate:undefined, argument:undefined});\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nAST_set('delegate', false);\nAST_set('argument', null);\n} else if (tok_getType() === 82009) {\nAST_set('delegate', true);\nparseYieldStarArgument(lexerFlags, $tp_yield_start, 'argument');\n} else if (tok_getType() === 82010) {\nreturn THROW_RANGE('Cannot use `yield` to the left of the `**` operator', $tp_yield_start, $tp_yield_stop);\n} else {\nAST_set('delegate', false);\nparseYieldArgument(lexerFlags, 'argument');\n}\nAST_close($tp_yield_start, $tp_yield_line, $tp_yield_column);\nif (tok_getType() === 16506) {\nreturn THROW_RANGE('Can not have a `yield` expression on the left side of a ternary', $tp_yield_start, $tp_yield_stop);\n}\nreturn 144;\n}\nfunction parseYieldStarArgument(lexerFlags, $tp_yield_start, astProp) {\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('A newline after `yield` is illegal for `yield *`', $tp_yield_start, tok_getStart());\n}\nskipToExpressionStart(lexerFlags);\nlet $tp_valueStart_line = tok_getLine();\nlet $tp_valueStart_column = tok_getColumn();\nlet $tp_valueStart_start = tok_getStart();\nlet $tp_valueStart_stop = tok_getStop();\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, astProp);\n}\nfunction parseYieldVarname(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, astProp) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Cannot use `yield` outside of generator functions when in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nlet assignableFlags = parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\nreturn copyPiggies(32, assignableFlags);\n}\nfunction parseYieldArgument(lexerFlags, astProp) {\nlet $tp_yieldArgStart_line = tok_getLine();\nlet $tp_yieldArgStart_column = tok_getColumn();\nlet $tp_yieldArgStart_start = tok_getStart();\nlet $tp_yieldArgStart_stop = tok_getStop();\nif (tok_getNlwas() === true) {\nAST_set(astProp, null);\nreturn;\n}\nlet assignable = parseValueHeadBody(lexerFlags, true, 4, true, false, astProp);\nif (tok_getStart() === $tp_yieldArgStart_start) {\nAST_set(astProp, null);\nreturn;\n}\nassignable = parseValueTail(lexerFlags, $tp_yieldArgStart_start, $tp_yieldArgStart_line, $tp_yieldArgStart_column, assignable, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_yieldArgStart_start, $tp_yieldArgStart_stop, $tp_yieldArgStart_line, $tp_yieldArgStart_column, assignable, astProp);\n}\nfunction parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, assignable, allowAssignment, astProp) {\nif (tok_getType() === 16499) {\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, 1, 0, astProp);\n} else {\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn assignable;\n}\n}\nfunction parseArrowParenlessFromPunc(lexerFlags, $tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, wasSimple, $tp_async_type, astProp) {\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif ((((lexerFlags & 128) === 128) && ($tp_ident_type === 2126))) {\nreturn THROW_RANGE('Arrows cannot be generators and parenless `yield` param in a generator would be parsing a yield expression and fail at the arrow', $tp_arrow_start, $tp_arrow_stop);\n}\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, BINDING_TYPE_ARG, lexerFlags);\nif (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nwasSimple = 3;\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow is a restricted production and there can not be a newline before `=>` token', $tp_arrow_start, $tp_arrow_stop);\n}\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, async:$tp_async_type === 2074, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, async:$tp_async_type === 2074, expression:undefined, body:undefined});\n}\nlet arrowScoop = SCOPE_createGlobal('parseArrowParenlessFromPunc');\nlet paramScoop = SCOPE_addLayer(arrowScoop, SCOPE_LAYER_ARROW_PARAMS, 'parseArrowParenlessFromPunc(arg)');\nSCOPE_addLexBinding(paramScoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, BINDING_TYPE_ARG, 1);\nparseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, wasSimple);\nAST_close($tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column);\nreturn 1040;\n}\nfunction parseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, astProp) {\nAST_open(astProp, {type:'TemplateLiteral', loc:undefined, expressions:[], quasis:[]});\nlet awaitYieldFlagsFromAssignable = 8;\nif (tok_getType() === 524308) {\nparseQuasiPart(lexerFlags, true, false);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\nreturn awaitYieldFlagsFromAssignable;\n}\nif (tok_getType() === 524305) {\nparseQuasiPart(lexerFlags, false, false);\nlet tmpLexerFlags = (((lexerFlags | 2048) | 4096) | 1824) ^ 1824;\nlet wasTail = true;\ndo {\nawaitYieldFlagsFromAssignable |= parseExpressions(tmpLexerFlags, 'expressions');\nwasTail = ((((tok_getType() === 524307) || (tok_getType() === 1572883)))? true : false);\nparseQuasiPart(lexerFlags, wasTail, false);\n} while (wasTail === false);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\nreturn awaitYieldFlagsFromAssignable;\n}\nreturn THROW_RANGE('Template contained bad escape, which is only valid in _tagged_ templates (and only since ES9/ES2018)', $tp_tick_start, $tp_tick_stop);\n}\nfunction parseQuasiPart(lexerFlags, wasTail, allowBadEscapes) {\nlet $tp_tick_type = tok_getType();\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nlet $tp_tick_canon = tok_getCanoN();\nlet hasDoubleStart = false;\nlet noCooked = false;\nif (isBadTickToken(tok_getType())) {\nif (!allowBadEscapes) {\nreturn THROW_RANGE('Template contained an illegal escape, these are only allowed in _tagged_ templates in >=ES2018', $tp_tick_start, $tp_tick_stop);\n}\nnoCooked = true;\n}\nif (((((((tok_getType() === 524308) || (tok_getType() === 524307))) || (tok_getType() === 1572884))) || (tok_getType() === 1572883))) {\nskipDiv(lexerFlags);\n} else if (((((((tok_getType() === 524305) || (tok_getType() === 524306))) || (tok_getType() === 1572881))) || (tok_getType() === 1572882))) {\nskipToExpressionStart(lexerFlags);\nhasDoubleStart = true;\n} else {\nreturn THROW_RANGE('The first token after the template expression should be a continuation of the template', $tp_tick_start, $tp_tick_stop);\n}\nlet closeWrapperLen = (((((((($tp_tick_type === 524305) || ($tp_tick_type === 524306))) || ($tp_tick_type === 1572881))) || ($tp_tick_type === 1572882)))? 2 : 1);\nlet quasiValue = tok_sliceInput($tp_tick_start + 1, $tp_tick_stop - closeWrapperLen);\nif ((((acornCompat || babelCompat)) || templateNewlineNormalization)) {\nquasiValue = quasiValue.replace(/\\r\\n?/g, '\\n');\n}\nlet cookedValue = (noCooked? null : $tp_tick_canon);\nAST_open('quasis', {type:'TemplateElement', loc:undefined, tail:wasTail === true, value:{raw:quasiValue, cooked:cookedValue}});\nAST_closeTemplateElement(hasDoubleStart, $tp_tick_start, $tp_tick_line, $tp_tick_column + 1);\n}\nfunction parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, leftHandSideExpression, astProp) {\nif ((assignable & 1024) === 1024) return assignable;\nswitch (tok_getType()) {\ncase 16485:\nreturn _parseValueTailDotProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16509:\nreturn _parseValueTailDynamicProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16471:\nreturn _parseValueTailCall(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 82043:\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot use `?.` in the arg of `new`', tok_getStart(), tok_getStop());\n}\nreturn parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, astProp);\ncase 524308:\n\ncase 524305:\n\ncase 1572884:\n\ncase 1572881:\nreturn _parseValueTailTemplate(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16478:\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn parseValueTailUpdateExpression(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, leftHandSideExpression, '++', astProp);\ncase 16482:\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn parseValueTailUpdateExpression(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, leftHandSideExpression, '--', astProp);\n}\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn assignable;\n}\nfunction parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, astProp) {\ndo {\nlet $tp_next_type = tok_getType();\nswitch ($tp_next_type) {\ncase 82043:\nskipAny(lexerFlags);\nlet $tp_q_type = tok_getType();\nif (isIdentToken($tp_q_type)) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nif (!isIdentToken($tp_ident_type)) THROW_RANGE('Expected ident after dot', $tp_ident_start, $tp_ident_stop);\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'OptionalMemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), optional:true, computed:false, object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\n} else if ($tp_q_type === 16509) {\nskipAny(lexerFlags);\nAST_wrapClosedCustom(astProp, {type:'OptionalMemberExpression', loc:undefined, optional:true, computed:true, object:undefined, property:undefined}, 'object');\nparseExpression(lexerFlags, 'property');\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing `]` char of a dynamic property, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\n} else if ($tp_q_type === 16471) {\nAST_wrapClosedCustom(astProp, {type:'OptionalCallExpression', loc:undefined, optional:true, callee:undefined, arguments:[]}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\n} else if (isTemplateStart($tp_q_type)) {\nreturn THROW_RANGE('An value containing the optional chaining operator cannot be followed by a template', tok_getStart(), tok_getStop());\n} else if ($tp_q_type === 82043) {\nreturn THROW_RANGE('Cannot cannot `?.?.`, must have something in between', tok_getStart(), tok_getStop());\n}\nbreak;\ncase 16485:\nskipAny(lexerFlags);\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nif (!isIdentToken($tp_ident_type)) THROW_RANGE('Expected ident after dot', $tp_ident_start, $tp_ident_stop);\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'OptionalMemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), optional:false, computed:false, object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\nbreak;\ncase 16471:\nAST_wrapClosedCustom(astProp, {type:'OptionalCallExpression', loc:undefined, optional:false, callee:undefined, arguments:undefined}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nbreak;\ncase 16509:\nskipAny(lexerFlags);\nAST_wrapClosedCustom(astProp, {type:'OptionalMemberExpression', loc:undefined, optional:false, computed:true, object:undefined, property:undefined}, 'object');\nparseExpression(lexerFlags, 'property');\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing `]` char of a dynamic property, found`' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nassignable = parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, 'property');\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nbreak;\ndefault:\nif (isTemplateStart($tp_next_type)) {\nreturn THROW_RANGE('An value containing the optional chaining operator cannot be followed by a template', tok_getStart(), tok_getStop());\n}\nreturn setNotAssignable(assignable);\n}\n} while (true);\n}\nfunction _parseValueTailDotProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nskipToIdentOrDie(lexerFlags | 65536);\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'MemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon), computed:false});\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailDynamicProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nAST_wrapClosedCustom(astProp, {type:'MemberExpression', loc:undefined, object:undefined, property:undefined, computed:true}, 'object');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpressions(((lexerFlags | 4096) | 1824) ^ 1824, 'property');\nassignable = mergeAssignable(nowAssignable, assignable);\nassignable = (assignable | 1024) ^ 1024;\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing bracket `]` for a dynamic property, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailCall(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nif (isNewArg === 3) {\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nif (tok_getType() === 16499) {\nreturn THROW_RANGE('The `new` keyword can not be applied to an arrow', tok_getStart(), tok_getStop());\n}\nassignable = mergeAssignable(nowAssignable, assignable);\nassignable = setNotAssignable(assignable);\nreturn assignable;\n}\nAST_wrapClosedCustom(astProp, {type:'CallExpression', loc:undefined, callee:undefined, arguments:[]}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setNotAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailTemplate(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nAST_wrapClosedCustom(astProp, {type:'TaggedTemplateExpression', loc:undefined, tag:undefined, quasi:undefined}, 'tag');\nlet $tp_Quasi_line = tok_getLine();\nlet $tp_Quasi_column = tok_getColumn();\nlet $tp_Quasi_start = tok_getStart();\nAST_open('quasi', {type:'TemplateLiteral', loc:undefined, expressions:[], quasis:[]});\n_parseValueTailTemplateRest(lexerFlags);\nAST_close($tp_Quasi_start, $tp_Quasi_line, $tp_Quasi_column);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setNotAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailTemplateRest(lexerFlags) {\nlet awaitYieldFlagsFromAssignable = 8;\nif (((tok_getType() === 524308) || (tok_getType() === 1572884))) {\nparseQuasiPart(lexerFlags, true, allowBadEscapesInTaggedTemplates);\nreturn;\n}\nparseQuasiPart(lexerFlags, false, allowBadEscapesInTaggedTemplates);\nlet tmpLexerFlags = (((lexerFlags | 2048) | 4096) | 1824) ^ 1824;\nlet wasTail = true;\ndo {\nawaitYieldFlagsFromAssignable |= parseExpressions(tmpLexerFlags, 'expressions');\nwasTail = ((((tok_getType() === 524307) || (tok_getType() === 1572883)))? true : false);\nparseQuasiPart(lexerFlags, wasTail, allowBadEscapesInTaggedTemplates);\n} while (wasTail === false);\n}\nfunction _parseValueTailNewArg(assignable) {\nreturn setNotAssignable(assignable);\n}\nfunction parseValueTailUpdateExpression(lexerFlags, $tp_argStart_start, $tp_argStart_line, $tp_argStart_column, assignable, leftHandSideExpression, opName, astProp) {\nlet $tp_op_start = tok_getStart();\nlet $tp_op_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('A `' + opName) + '` update expression is not allowed here', $tp_op_start, $tp_op_stop);\n}\nif (tok_getNlwas() === true) {\nif ((lexerFlags & 4096) === 4096) {\nreturn THROW_RANGE(('The postfix `' + opName) + '` is a restricted production so ASI must apply but that is not valid in this context', $tp_op_start, $tp_op_stop);\n}\nreturn assignable;\n}\nif (notAssignable(assignable)) {\nreturn THROW_RANGE(('Cannot postfix `' + opName) + '` a non-assignable value', $tp_op_start, $tp_op_stop);\n}\nAST_throwIfIllegalUpdateArg(astProp);\nskipDiv(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'UpdateExpression', loc:AST_getClosedLoc($tp_argStart_start, $tp_argStart_line, $tp_argStart_column), argument:AST_popNode(astProp), operator:opName, prefix:false});\nreturn 16;\n}\nfunction parseCallArgs(lexerFlags, astProp) {\nskipToExpressionStartGrouped(lexerFlags);\nlexerFlags = ((lexerFlags | 4096) | 32) ^ 32;\nlet assignable = 8;\nif (tok_getType() === 16472) {\nskipDiv(lexerFlags);\n} else {\ndo {\nif (tok_getType() === 16486) {\nlet $tp_spread_line = tok_getLine();\nlet $tp_spread_column = tok_getColumn();\nlet $tp_spread_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'SpreadElement', loc:undefined, argument:undefined});\nlet nowAssignable = parseExpression(lexerFlags, 'argument');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_spread_start, $tp_spread_line, $tp_spread_column);\n} else {\nlet nowAssignable = parseExpression(lexerFlags, astProp);\nassignable = mergeAssignable(nowAssignable, assignable);\n}\nif (tok_getType() !== 16480) break;\nlet $tp_comma_start = tok_getStart();\nlet $tp_comma_stop = tok_getStop();\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif (allowTrailingFunctionComma) break;\nreturn THROW_RANGE('Targeted language version does not support trailing call arg comma', $tp_comma_start, $tp_comma_stop);\n}\n} while (true);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Expecting closing paren `)` for the call, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nfunction parseDynamicImportStatement(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseDynamicImport(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, 'expression');\nlet assignable = parseValueTail(lexerFlags, $tp_import_start, $tp_import_line, $tp_import_column, 16, 4, false, 'expression');\nparseExpressionFromOp(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, assignable, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\n}\nfunction parseDynamicImport(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp) {\nif (!allowDynamicImport) {\nreturn THROW_RANGE('Dynamic import syntax not supported. Requires version ES2020+ / ES11+.', $tp_import_start, $tp_import_stop);\n}\nif (acornCompat) {\nAST_open(astProp, {type:'ImportExpression', loc:undefined, source:undefined});\n} else {\nAST_open(astProp, {type:'CallExpression', loc:undefined, callee:undefined, arguments:[]});\nAST_setNode('callee', {type:'Import', loc:AST_getClosedLoc($tp_import_start, $tp_import_line, $tp_import_column)});\n}\nskipToExpressionStart(lexerFlags);\nlet assignable = parseExpression(lexerFlags, (acornCompat? 'source' : 'arguments'));\nif (tok_getType() !== 16472) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Dynamic `import` only expected exactly one argument and does not allow for a trailing comma', $tp_import_start, tok_getStop());\n}\nif (tok_getType() === 67636) {\nreturn THROW_RANGE('The dynamic import syntax explicitly forbids the `in` operator', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('The dynamic `import` argument was followed by unknown content', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\nreturn assignable;\n}\nfunction parseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, paramsSimple) {\nskipToExpressionStart(lexerFlags);\nif (allowAssignment === false) {\nreturn THROW_RANGE('Was parsing a value that could not be AssignmentExpression but found an arrow', tok_getStart(), tok_getStop());\n}\nif (options_exposeScopes) AST_set('$scope', paramScoop);\nif (paramScoop.dupeParamErrorStart !== 0) {\nreturn THROW_RANGE('Arrow had duplicate params', paramScoop.dupeParamErrorStart - 1, paramScoop.dupeParamErrorStop);\n}\nlet insideForLhs = (lexerFlags & 32) === 32;\nlet arrowInheritedFlags = lexerFlags & 18;\nlexerFlags = resetLexerFlagsForFuncAndArrow(lexerFlags, 0, $tp_async_type, true);\nlexerFlags |= arrowInheritedFlags;\nif (tok_getType() === 16513) {\nif (!babelCompat) AST_set('expression', false);\nlet arrowScoop = SCOPE_addLayer(paramScoop, SCOPE_LAYER_FUNC_BODY, 'parseArrowFromPunc');\nparseFunctionBody(lexerFlags, arrowScoop, 1, paramsSimple, 0, 0, 0, 0, 0, '', true);\nif ((isRegexToken(tok_getType()) && (!tok_getNlwas()))) {\nTHROW_RANGE('Found a regex or division after an arrow, that is illegal', tok_getStart(), tok_getStop());\n}\n} else {\nif (insideForLhs) lexerFlags |= 32;\nif (!babelCompat) AST_set('expression', true);\nparseExpression(lexerFlags, 'body');\n}\n{\nlet $tp_error_type = tok_getType();\nlet $tp_error_start = tok_getStart();\nlet $tp_error_stop = tok_getStop();\nlet $tp_error_nl = tok_getNlwas();\nif ((insideForLhs && ($tp_error_type === 67636))) {\nreturn THROW_RANGE('Arrows cannot be lhs to for-in', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_type === 16485) {\nreturn THROW_RANGE('Block body arrows can not be immediately accessed without a group', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_nl) {\nif ($tp_error_type === 82023) {\nreturn THROW_RANGE('An arrow function can not be part of an operator to the right', $tp_error_start, $tp_error_stop);\n}\nreturn 1040;\n}\nif ($tp_error_type === 16471) {\nreturn THROW_RANGE('Block body arrows can not be immediately invoked without a group', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_type === 16509) {\nreturn THROW_RANGE('Block body arrows can not be immediately accessed without a group', $tp_error_start, $tp_error_stop);\n}\nif (isTemplateStart($tp_error_type)) {\nreturn THROW_RANGE('Block body arrows can not be immediately tagged without a group', $tp_error_start, $tp_error_stop);\n}\nif ((isAnyAssignmentOp() || (($tp_error_type & 65536) === 65536))) {\nreturn THROW_RANGE('An arrow function can not be part of an operator to the right', $tp_error_start, $tp_error_stop);\n}\nif ((($tp_error_type === 16478) || ($tp_error_type === 16482))) {\nreturn THROW_RANGE('An arrow function can not have a postfix update operator', $tp_error_start, $tp_error_stop);\n}\n}\nreturn 1040;\n}\nfunction parseGroupToplevels(lexerFlagsBeforeParen, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, $tp_async_type, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, newlineAfterAsync, leftHandSideExpression, astProp) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nskipToExpressionStartGrouped(lexerFlagsBeforeParen);\nlet $tp_firstTokenAfterParen_line = tok_getLine();\nlet $tp_firstTokenAfterParen_column = tok_getColumn();\nlet $tp_firstTokenAfterParen_start = tok_getStart();\nlet lexerFlags = ((lexerFlagsBeforeParen | 4096) | 1824) ^ 1824;\nlet arrowScoop = SCOPE_createGlobal('_parseGroupToplevels');\nlet paramScoop = SCOPE_addLayer(arrowScoop, SCOPE_LAYER_ARROW_PARAMS, '_parseGroupToplevels(arg)');\nif (tok_getType() === 16472) {\nif ($tp_async_type === 2074) {\nskipDiv(lexerFlags);\nreturn parseAfterAsyncGroup(lexerFlagsBeforeParen, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, 1, false, newlineAfterAsync, true, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 8, astProp);\n}\nskipToArrowOrDie(lexerFlags);\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('Arrow not allowed in this position', $tp_paren_start, $tp_arrow_stop);\n}\nlexerFlags = lexerFlagsBeforeParen;\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow token `=>` is a restricted production and cannot have a newline preceding it', $tp_arrow_start, $tp_arrow_stop);\n}\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:false, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:false, expression:undefined, body:undefined});\n}\nlet assignable = parseArrowFromPunc(lexerFlags, paramScoop, 0, allowAssignmentForGroupToBeArrow, 1);\nAST_close($tp_paren_start, $tp_paren_line, $tp_paren_column);\nreturn assignable;\n}\nlet foundSingleIdentWrap = false;\nlet rootAstProp = astProp;\nlet destructible = 0;\nlet assignable = 8;\nlet toplevelComma = false;\nlet wasSimple = 1;\nlet mustBeArrow = false;\nwhile (tok_getType() !== 16472) {\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet wasAssignment = tok_getType() === 49264;\nlet wasCommaOrEnd = ((tok_getType() === 16480) || (tok_getType() === 16472));\nlet exprAssignable = parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, BINDING_TYPE_ARG, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nSCOPE_addLexBinding(paramScoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, BINDING_TYPE_ARG, 1);\nif (wasAssignment) {\nwasSimple = 3;\n} else if (wasCommaOrEnd) {\nif (((!toplevelComma) && (tok_getType() === 16472))) {\nfoundSingleIdentWrap = true;\n}\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else if (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nwasSimple = 3;\n} else {\n\n}\n} else {\ndestructible |= 1;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_startOfPattern_line = tok_getLine();\nlet $tp_startOfPattern_column = tok_getColumn();\nlet $tp_startOfPattern_start = tok_getStart();\nlet $tp_startOfPattern_stop = tok_getStop();\ndestructible |= parseObjectOuter(lexerFlags, paramScoop, BINDING_TYPE_ARG, true, undefined, undefined, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\ndestructible |= 1;\n}\nassignable = parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp);\nwasSimple = 3;\n} else if (tok_getType() === 16509) {\nlet $tp_startOfPattern_line = tok_getLine();\nlet $tp_startOfPattern_column = tok_getColumn();\nlet $tp_startOfPattern_start = tok_getStart();\nlet $tp_startOfPattern_stop = tok_getStop();\ndestructible |= parseArrayOuter(lexerFlags, paramScoop, BINDING_TYPE_ARG, true, undefined, undefined, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\ndestructible |= 1;\n}\nassignable = parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp);\nwasSimple = 3;\n} else if (tok_getType() === 16486) {\nwasSimple = 3;\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, paramScoop, 16472, BINDING_TYPE_ARG, $tp_async_type, undefined, undefined, astProp);\ndestructible |= subDestruct;\nif ($tp_async_type === 2074) {\nif (tok_getType() !== 16472) {\ndestructible |= 1;\n} else {\n\n}\n} else {\nif ((((subDestruct & 1) === 1) || (tok_getType() === 16480))) {\nreturn THROW_RANGE('The ... argument must be destructible in an arrow header, found something that was not destructible', tok_getStart(), tok_getStop());\n}\nmustBeArrow = true;\nbreak;\n}\n} else {\ndestructible |= 1;\nlet exprAssignable = parseExpression(lexerFlags, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nif (tok_getType() === 16480) {\nif (!toplevelComma) {\ntoplevelComma = true;\nAST_wrapClosedIntoArrayCustom(rootAstProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nastProp = 'expressions';\n}\nassignable = __parseExpressions(lexerFlags, assignable, astProp);\n}\nif (toplevelComma) {\nif (babelCompat) AST_set('extra', {parenthesized:true, parenStart:$tp_paren_start});\nAST_close($tp_firstTokenAfterParen_start, $tp_firstTokenAfterParen_line, $tp_firstTokenAfterParen_column);\nassignable = setNotAssignable(assignable);\n}\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Expected the closing paren `)` for the group, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nif ($tp_async_type === 2074) {\nif (tok_getType() === 16499) {\nreturn THROW_RANGE('The header of this async arrow contained something that is not valid a param', tok_getStart(), tok_getStop());\n}\nreturn parseAfterAsyncGroup(lexerFlagsBeforeParen, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, wasSimple, toplevelComma, newlineAfterAsync, false, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, rootAstProp);\n}\nif ((babelCompat && (!toplevelComma))) {\nAST_babelParenthesizesClosed($tp_paren_start, astProp);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nif (tok_getType() !== 16480) break;\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif ($tp_async_type === 0) {\nif (allowTrailingFunctionComma) {\nmustBeArrow = true;\nbreak;\n}\nreturn THROW_RANGE('Encountered trailing comma in the toplevel of a group, this could be valid in arrows but not with the currently targeted language version', tok_getStart(), tok_getStop());\n}\n}\nif (!toplevelComma) {\ntoplevelComma = true;\nAST_wrapClosedIntoArrayCustom(rootAstProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nastProp = 'expressions';\n}\n}\nif (toplevelComma) {\nassignable = setNotAssignable(assignable);\nif (babelCompat) AST_set('extra', {parenthesized:true, parenStart:$tp_paren_start});\nAST_close($tp_firstTokenAfterParen_start, $tp_firstTokenAfterParen_line, $tp_firstTokenAfterParen_column);\n}\ndestructible = copyPiggies(destructible, assignable);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren `)` for group, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nlexerFlags = lexerFlagsBeforeParen;\nverifyDestructible(destructible);\nlet isArrow = tok_getType() === 16499;\nif (isArrow) {\ndestructible |= 1024;\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nlet $tp_errorOffset_start = (($tp_async_type === 2074)? $tp_async_start : $tp_paren_start);\nreturn THROW_RANGE('Arrow not allowed in this position', $tp_errorOffset_start, $tp_arrow_stop);\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Arrow is restricted production; cannot have newline before the arrow token', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 1) === 1) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('The left hand side of the async arrow is not destructible so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nreturn THROW_RANGE('The left hand side of the arrow is not destructible so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 2) === 2) {\nreturn THROW_RANGE('The left hand side of the arrow can only be destructed through assignment so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 64) !== 0) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('The parameter header of an async arrow cannot contain `await` as varname nor as a keyword', $tp_async_start, $tp_async_stop);\n}\nif ((lexerFlags & 8) !== 0) {\nreturn THROW_RANGE('The parameter header of an arrow inside an async function cannot contain `await` as varname nor as a keyword', tok_getStart(), tok_getStop());\n}\n}\nif ((destructible & 128) === 128) {\nreturn THROW_RANGE('The arguments of an arrow cannot contain a yield expression in their defaults', $tp_arrow_start, $tp_arrow_stop);\n}\n} else if ((((destructible & 4) === 4) || mustBeArrow)) {\nreturn THROW_RANGE('Group contained a value that must destruct but this was not an arrow so it is invalid', $tp_paren_start, tok_getStop());\n}\nif ($tp_async_type === 2074) {\ndestructible = copyPiggies(destructible, assignable);\nreturn parseAfterAsyncGroup(lexerFlags, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, wasSimple, toplevelComma, newlineAfterAsync, false, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, rootAstProp);\n}\nif (isArrow) {\nparseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, 0, $tp_paren_start, $tp_paren_line, $tp_paren_column, allowAssignmentForGroupToBeArrow, rootAstProp);\nassignable = copyPiggies(assignable, destructible);\nreturn 1040 | (assignable & 64);\n}\nif ((babelCompat && (!toplevelComma))) {\nAST_babelParenthesizesClosed($tp_paren_start, astProp);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nfunction parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp) {\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\nif ((destructible & 4) === 4) {\nreturn THROW_RANGE('Pattern can not have a tail but did not find a comma or closing paren of the arrow header', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_line, $tp_startOfPattern_column, 16, 4, false, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, astProp);\n}\n} else {\nassignable = setNotAssignable(assignable);\n}\nreturn assignable;\n}\nfunction parseAfterAsyncGroup(lexerFlags, paramScoop, fromStmtOrExpr, allowAssignment, wasSimple, toplevelComma, newlineAfterAsync, zeroArgs, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, astProp) {\nif (tok_getType() === 16499) {\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow is a restricted production an there can not be a newline before `=>` token', $tp_arrow_start, $tp_arrow_stop);\n}\nif (newlineAfterAsync === true) {\nreturn THROW_RANGE('A newline after async is always a syntax error if the rhs turns to be an arrow function', $tp_arrow_start, $tp_arrow_stop);\n}\nif (zeroArgs) {\nparseArrowAfterAsyncNoArgGroup(lexerFlags, paramScoop, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp);\n} else {\nparseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, 2074, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp);\n}\n} else {\nif (zeroArgs) {\nAST_setNode(astProp, {type:'CallExpression', loc:AST_getClosedLoc($tp_async_start, $tp_async_line, $tp_async_column), callee:AST_getIdentNode($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon), arguments:[]});\n} else {\nAST_patchAsyncCall($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, astProp);\n}\nlet assignable = parseValueTail(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, 4, false, astProp);\nif (fromStmtOrExpr === 2) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, assignable, astProp);\nif (tok_getType() === 16480) {\nassignable = _parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, assignable, astProp);\n}\nparseSemiOrAsi(lexerFlags);\n}\nreturn assignable;\n}\nif (fromStmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\n}\nreturn 1040 | (assignable & 64);\n}\nfunction parseArrowAfterAsyncNoArgGroup(lexerFlags, paramScoop, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp) {\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:true, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:true, expression:undefined, body:undefined});\n}\nlet assignable = parseArrowFromPunc(lexerFlags, paramScoop, 2074, allowAssignment, 1);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\nreturn assignable;\n}\nfunction parseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, $tp_async_type, $tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column, allowAssignment, astProp) {\nif (babelCompat) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, async:$tp_async_type === 2074, body:undefined}, 'params');\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, expression:undefined, body:undefined}, 'params');\n} else {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, async:$tp_async_type === 2074, expression:undefined, body:undefined}, 'params');\n}\nlet top = _path[_path.length - 1];\nif (toplevelComma) {\nlet params = top.params[top.params.length - 1];\ntop.params = params.expressions;\n}\nlet params = top.params;\nfor (let i = 0;i < params.length;++i) {\nAST__destruct(params[i], params, i);\n}\nparseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, wasSimple);\nAST_close($tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column);\n}\nfunction parseArrayOuter(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nlet destructible = parseArrayLiteralPattern(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp);\nreturn destructible;\n}\nfunction parseArrayLiteralPattern(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, _astProp) {\nlet lexerFlags = (lexerFlagsBeforeParen | 32) ^ 32;\nlet $tp_arrayOpen_line = tok_getLine();\nlet $tp_arrayOpen_column = tok_getColumn();\nlet $tp_arrayOpen_start = tok_getStart();\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_open(_astProp, {type:'ArrayExpression', loc:undefined, elements:[]});\nlet astProp = 'elements';\nlet destructible = 0;\nwhile (tok_getType() === 16480) {\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_add(astProp, null);\n}\nlet spreadStage = 0;\nlet assignableYieldAwaitState = 8;\nwhile (tok_getType() !== 16510) {\nlet $tp_elementStart_line = tok_getLine();\nlet $tp_elementStart_column = tok_getColumn();\nlet $tp_elementStart_start = tok_getStart();\nlet $tp_elementStart_stop = tok_getStop();\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet nextIsAssignment = tok_getType() === 49264;\nlet nextIsCommaOrEnd = ((tok_getType() === 16480) || (tok_getType() === 16510));\nlet leftAssignable = parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, 4, true, false, astProp);\nassignableYieldAwaitState |= leftAssignable;\nif (nextIsAssignment) {\nif (notAssignable(leftAssignable)) {\nreturn THROW_RANGE(('Cannot assign or destruct to keyword `' + tok_sliceInput($tp_ident_start, $tp_ident_stop)) + '`', $tp_ident_start, $tp_ident_stop);\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet rightAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\nassignableYieldAwaitState |= rightAssignable;\n} else if (nextIsCommaOrEnd) {\nif (notAssignable(leftAssignable)) {\ndestructible |= 1;\n} else {\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\n}\n} else {\nif (bindingType === BINDING_TYPE_ARG) {\ndestructible |= 2;\n} else if (bindingType !== BINDING_TYPE_NONE) {\ndestructible |= 1;\n}\nlet nowDestruct = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, leftAssignable, 1, 16510, astProp);\ndestructible |= nowDestruct;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_objOpen_line = tok_getLine();\nlet $tp_objOpen_column = tok_getColumn();\nlet $tp_objOpen_start = tok_getStart();\nlet $tp_objOpen_stop = tok_getStop();\nlet objDestructible = parseObjectAndAssign(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, astProp);\ndestructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_objOpen_start, $tp_objOpen_stop, $tp_objOpen_line, $tp_objOpen_column, (((objDestructible & 1) === 1)? 16 : 32), objDestructible, 16510, astProp);\n} else if (tok_getType() === 16509) {\nlet $tp_arrOpen_line = tok_getLine();\nlet $tp_arrOpen_column = tok_getColumn();\nlet $tp_arrOpen_start = tok_getStart();\nlet $tp_arrOpen_stop = tok_getStop();\nlet arrDestructible = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, astProp);\ndestructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_arrOpen_start, $tp_arrOpen_stop, $tp_arrOpen_line, $tp_arrOpen_column, (((arrDestructible & 1) === 1)? 16 : 32), arrDestructible, 16510, astProp);\n} else if (tok_getType() === 16486) {\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, 16510, bindingType, 0, exportedNames, exportedBindings, astProp);\ndestructible |= subDestruct;\nif (spreadStage === 0) spreadStage = 1;\n} else {\nlet $tp_exprStart_line = tok_getLine();\nlet $tp_exprStart_column = tok_getColumn();\nlet $tp_exprStart_start = tok_getStart();\nlet $tp_exprStart_stop = tok_getStop();\nlet wasParen = tok_getType() === 16471;\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nif (tok_getType() === 49264) {\nif (isAssignable(assignable)) {\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\ndestructible |= parseExpression(lexerFlags, 'right');\nAST_close($tp_elementStart_start, $tp_elementStart_line, $tp_elementStart_column);\n} else {\nreturn THROW_RANGE(('Cannot assign to lhs (starting with `' + tok_sliceInput($tp_elementStart_start, $tp_elementStart_stop)) + '`)', $tp_elementStart_start, $tp_elementStart_stop);\n}\n}\nif (((tok_getType() !== 16480) && (tok_getType() !== 16510))) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\nassignable = setNotAssignable(assignable);\ndestructible |= 1;\n} else if ((((wasParen && isAssignable(assignable))) && (((bindingType === BINDING_TYPE_NONE) || (bindingType === BINDING_TYPE_ARG))))) {\ndestructible |= 2;\n} else if ((wasParen || notAssignable(assignable))) {\ndestructible |= 1;\n} else {\n\n}\n}\nif (tok_getType() !== 16480) break;\nskipToExpressionStartSquareCloseComma(lexerFlags);\nwhile (tok_getType() === 16480) {\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_add(astProp, null);\n}\nif (spreadStage === 1) {\nspreadStage = 2;\ndestructible |= 1;\n}\n}\nlexerFlags = lexerFlagsBeforeParen;\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing bracket `]` for the array, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_arrayOpen_start, $tp_arrayOpen_line, $tp_arrayOpen_column);\nif (skipInit === true) {\ndestructible = parsePatternAssignMaybe(lexerFlags, $tp_arrayOpen_start, $tp_arrayOpen_line, $tp_arrayOpen_column, destructible, _astProp);\n}\nreturn (copyPiggies(destructible, assignableYieldAwaitState) | 1024) ^ 1024;\n}\nfunction parseObjectOuter(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nreturn parseObjectAndAssign(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp);\n}\nfunction parseObjectAndAssign(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nAST_open(astProp, {type:'ObjectExpression', loc:undefined, properties:[]});\nlet destructible = parseObjectSansAssign(lexerFlags | 4096, scoop, bindingType, exportedNames, exportedBindings, 'properties');\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (skipInit === true) {\ndestructible = parsePatternAssignMaybe(lexerFlags, $tp_curly_start, $tp_curly_line, $tp_curly_column, destructible, astProp);\n}\nreturn destructible;\n}\nfunction parseObjectSansAssign(outerLexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet lexerFlags = (outerLexerFlags | 2080) ^ 2080;\nskipAny(lexerFlags);\nlet destructible = 0;\nlet hasThunderProto = false;\ndo {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Objects cant have comma without something preceding it', tok_getStart(), tok_getStop());\n}\nlet currentDestruct = parseObjectPart(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp);\nif ((currentDestruct & 512) !== 0) {\ncurrentDestruct ^= 512;\nif (hasThunderProto) {\ndestructible |= 4;\n}\nhasThunderProto = true;\n}\ndestructible |= currentDestruct;\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n} while (tok_getType() !== 16517);\nlexerFlags = outerLexerFlags;\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Expected the closing curly `}` for an object, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nreturn destructible;\n}\nfunction parseObjectPart(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet $tp_startOfKey_type = tok_getType();\nlet $tp_startOfKey_line = tok_getLine();\nlet $tp_startOfKey_column = tok_getColumn();\nlet $tp_startOfKey_start = tok_getStart();\nif (isIdentToken($tp_startOfKey_type)) {\nreturn parseObjectPartFromIdent(lexerFlags, $tp_startOfKey_type, scoop, bindingType, exportedNames, exportedBindings, astProp);\n}\nif ($tp_startOfKey_type === 16517) {\nreturn 0;\n}\nif (isNumberStringToken($tp_startOfKey_type)) {\nreturn parseObjectPartFromLiteral(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp);\n}\nif ($tp_startOfKey_type === 16509) {\nreturn parseObjectPartFromComputed(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp);\n}\nif ($tp_startOfKey_type === 16486) {\nreturn parseObjectRestSpread(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp);\n}\nif ($tp_startOfKey_type === 82009) {\nskipAny(lexerFlags);\nreturn parseObjectMethodFromKey(lexerFlags, $tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column, 'init', true, 0, 82009, 0, 0, astProp);\n}\nreturn THROW_RANGE(('Unexpected token, wanted to parse a start of a property in an object literal/pattern, got `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nfunction parseObjectMethodFromKey(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp) {\nlet $tp_keyStart_type = tok_getType();\nlet $tp_keyStart_line = tok_getLine();\nlet $tp_keyStart_column = tok_getColumn();\nlet $tp_keyStart_start = tok_getStart();\nlet $tp_keyStart_stop = tok_getStop();\nlet $tp_keyStart_canon = tok_getCanoN();\nif (isIdentToken($tp_keyStart_type)) {\nskipAny(lexerFlags);\nAST_setIdent(astProp, $tp_keyStart_start, $tp_keyStart_stop, $tp_keyStart_line, $tp_keyStart_column, $tp_keyStart_canon);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, false, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nif (isNumberStringToken($tp_keyStart_type)) {\nskipAny(lexerFlags);\nAST_setLiteral(astProp, $tp_keyStart_type, $tp_keyStart_start, $tp_keyStart_stop, $tp_keyStart_line, $tp_keyStart_column, $tp_keyStart_canon);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, false, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nif ($tp_keyStart_type === 16509) {\nskipRex(lexerFlags);\nparseExpression(lexerFlags, astProp);\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Missing closing square bracket for computed property name, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipAny(lexerFlags);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, true, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nTHROW_RANGE(('Expected to parse an object method key, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nfunction parseObjectPartFromIdent(lexerFlags, $tp_propLeadingIdent_type, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet $tp_propLeadingIdent_line = tok_getLine();\nlet $tp_propLeadingIdent_column = tok_getColumn();\nlet $tp_propLeadingIdent_start = tok_getStart();\nlet $tp_propLeadingIdent_stop = tok_getStop();\nlet $tp_propLeadingIdent_canon = tok_getCanoN();\nskipAny(lexerFlags);\nlet $tp_afterIdent_type = tok_getType();\nif ($tp_afterIdent_type === 16489) {\nAST_setIdent(astProp, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon);\nlet destructible = 0;\nif (((options_webCompat === true) && ($tp_propLeadingIdent_canon === '__proto__'))) {\ndestructible = 512;\n}\nreturn destructible | parseObjectPropertyFromColon(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, scoop, exportedNames, exportedBindings, bindingType, false, astProp);\n}\nif ($tp_afterIdent_type === 16471) {\nAST_setIdent(astProp, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon);\nreturn parseObjectMethod(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', false, true, 0, 0, 0, 0, astProp);\n}\nif ((($tp_afterIdent_type === 16480) || ($tp_afterIdent_type === 16517))) {\nreturn parseObjectShorthand(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp);\n}\nif ($tp_afterIdent_type === 49264) {\nreturn parseObjectShorthandWithInit(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp);\n}\nif ($tp_propLeadingIdent_type === 2074) {\nif (!allowAsyncFunctions) {\nreturn THROW_RANGE('Async functions are not supported in the currently targeted language version', $tp_propLeadingIdent_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async methods are a restricted production and cannot have a newline following it', $tp_propLeadingIdent_start, tok_getStart());\n}\nif (tok_getType() === 82009) {\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('Async generator methods are not supported in the currently targeted language version', $tp_propLeadingIdent_start, tok_getStop());\n}\nskipAny(lexerFlags);\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', true, 2074, 82009, 0, 0, astProp);\n}\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', true, 2074, 0, 0, 0, astProp);\n}\nif ($tp_propLeadingIdent_type === 2096) {\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'get', false, 0, 0, 2096, 0, astProp);\n}\nif ($tp_propLeadingIdent_type === 2112) {\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'set', false, 0, 0, 0, 2112, astProp);\n}\nif ($tp_propLeadingIdent_type === 2113) {\nreturn THROW_RANGE('Object members can not be \"static\"', $tp_propLeadingIdent_start, tok_getStop());\n}\nreturn THROW_RANGE(((('Unexpected token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` after start of property `') + $tp_propLeadingIdent_canon) + '` while trying to parse an object property/method', $tp_propLeadingIdent_start, tok_getStop());\n}\nfunction parseObjectPropertyFromColon(lexerFlags, $tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column, scoop, exportedNames, exportedBindings, bindingType, isComputed, astProp) {\nskipRex(lexerFlags);\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:undefined, method:false, computed:isComputed, value:undefined, shorthand:false}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:undefined, kind:'init', method:false, computed:isComputed, value:undefined, shorthand:false}, 'key');\n}\nlet destructible = _parseObjectPropertyFromColon(lexerFlags, scoop, exportedNames, exportedBindings, bindingType);\nAST_close($tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column);\nreturn destructible;\n}\nfunction _parseObjectPropertyFromColon(lexerFlags, scoop, exportedNames, exportedBindings, bindingType) {\nif (isIdentToken(tok_getType())) {\nreturn parseObjectPropertyValueFromIdent(lexerFlags, scoop, exportedNames, exportedBindings, bindingType);\n}\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet $tp_start_stop = tok_getStop();\nif (tok_getType() === 16513) {\nlet destructible = parseObjectOuter(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, 'value');\nlet objAssignable = ((destructible & 1)? 16 : 32);\nif (((tok_getType() === 16480) || (tok_getType() === 16517))) {\nreturn destructible;\n}\nif (4 & destructible) {\nreturn THROW_RANGE(('Object pattern contained parts cause it not to be valid as a regular object literal so the next token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` is illegal', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, objAssignable, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nexprAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, exprAssignable, 'value');\nif ((wasAssignment || isAssignable(exprAssignable))) {\nreturn copyPiggies(2, exprAssignable);\n}\nreturn copyPiggies(1, exprAssignable);\n}\nif (tok_getType() === 16509) {\nlet destructible = parseArrayOuter(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, 'value');\nlet objAssignable = ((destructible & 1)? 16 : 32);\nif (((tok_getType() === 16480) || (tok_getType() === 16517))) {\nreturn destructible;\n}\nif (4 & destructible) {\nreturn THROW_RANGE(('Object pattern contained parts cause it not to be valid as a regular object literal so the next token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` is illegal', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, objAssignable, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nexprAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, exprAssignable, 'value');\nif ((wasAssignment || isAssignable(exprAssignable))) {\nreturn copyPiggies(2, exprAssignable);\n}\nreturn copyPiggies(1, exprAssignable);\n}\nlet valueAssignable = parseValue(lexerFlags, true, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nvalueAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, valueAssignable, 'value');\nif ((wasAssignment || isAssignable(valueAssignable))) {\nreturn copyPiggies(2, valueAssignable);\n}\nreturn copyPiggies(1, valueAssignable);\n}\nfunction parseObjectPropertyValueFromIdent(lexerFlags, scoop, exportedNames, exportedBindings, bindingType) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet $tp_afterExpr_type = tok_getType();\nif ((($tp_afterExpr_type === 16480) || ($tp_afterExpr_type === 16517))) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\nlet valueAssignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, 'value');\nreturn copyPiggies(1, valueAssignable);\n}\nAST_setIdent('value', $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nreturn 0;\n}\nif ($tp_afterExpr_type === 49264) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\nreturn THROW_RANGE('The lhs was not assignable so this is an error', $tp_ident_start, tok_getStop());\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nAST_setIdent('value', $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 32, 'value');\nreturn copyPiggies(0, rhsAssignable);\n}\nlet valueAssignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, 'value');\nif (notAssignable(valueAssignable)) {\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, valueAssignable, 'value');\nreturn copyPiggies(1, rhsAssignable);\n}\nlet wasAssign = tok_getType() === 49264;\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, valueAssignable, 'value');\nif ((wasAssign || isAssignable(rhsAssignable))) {\nreturn copyPiggies(2, rhsAssignable);\n}\nreturn copyPiggies(1, rhsAssignable);\n}\nfunction parseObjectShorthand(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp) {\nlet report = nonFatalBindingIdentCheck($tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType, lexerFlags);\nif (((((report.length > 0) && ($tp_propLeadingIdent_type !== 2088))) && ($tp_propLeadingIdent_type !== 2072))) {\nreturn THROW_RANGE(report, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop);\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType);\naddNameToExports(exportedNames, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon);\naddBindingToExports(exportedBindings, $tp_propLeadingIdent_canon);\nif (babelCompat) {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true, extra:{shorthand:true}});\n} else {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), kind:'init', method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true});\n}\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nif ($tp_propLeadingIdent_type === 2075) {\nreturn 64;\n}\nreturn ((report.length > 0)? 1 : 0);\n}\nfunction parseObjectShorthandWithInit(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp) {\nfatalBindingIdentCheck($tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType, lexerFlags);\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType);\naddNameToExports(exportedNames, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon);\naddBindingToExports(exportedBindings, $tp_propLeadingIdent_canon);\nif (babelCompat) {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true, extra:{shorthand:true}});\n} else {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), kind:'init', method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true});\n}\nAST_wrapClosedCustom('value', {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nif ($tp_propLeadingIdent_type === 2075) {\nreturn copyPiggies(68, nowAssignable);\n}\nreturn copyPiggies(4, nowAssignable);\n}\nfunction parseObjectPartFromLiteral(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nskipToColonParenOpen(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nif (tok_getType() === 16489) {\nlet destructible_forPiggies = 0;\nif (((options_webCompat === true) && ($tp_lit_canon === '__proto__'))) {\ndestructible_forPiggies |= 512;\n}\nreturn destructible_forPiggies | parseObjectPropertyFromColon(lexerFlags, $tp_lit_start, $tp_lit_line, $tp_lit_column, scoop, exportedNames, exportedBindings, bindingType, false, astProp);\n}\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE('Object literal keys that are strings or numbers must be a method or have a colon', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_lit_start, $tp_lit_line, $tp_lit_column, 'init', false, true, 0, 0, 0, 0, astProp);\n}\nfunction parseObjectPartFromComputed(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp) {\nlet $tp_keyStart_line = tok_getLine();\nlet $tp_keyStart_column = tok_getColumn();\nlet $tp_keyStart_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nlet assignable_forPiggies = parseExpression(lexerFlags, astProp);\nif (tok_getType() !== 16510) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('The expression of a computed property key can not be a comma expression', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE(('Missing closing square bracket for computed property name, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToColonParenOpen(lexerFlags);\nlet $tp_afterKey_type = tok_getType();\nif ($tp_afterKey_type === 16489) {\nlet assignable = parseObjectPropertyFromColon(lexerFlags, $tp_keyStart_start, $tp_keyStart_line, $tp_keyStart_column, scoop, exportedNames, exportedBindings, bindingType, true, astProp);\nreturn copyPiggies(assignable, assignable_forPiggies);\n}\nif ($tp_afterKey_type === 16471) {\nlet assignable = parseObjectMethod(lexerFlags, $tp_keyStart_start, $tp_keyStart_line, $tp_keyStart_column, 'init', true, true, 0, 0, 0, 0, astProp);\nreturn copyPiggies(assignable, assignable_forPiggies);\n}\nTHROW_RANGE(('Object literal; computed property must be followed by a colon (property) paren (method), found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + `' instead'`, tok_getStart(), tok_getStop());\n}\nfunction parseObjectRestSpread(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nif (((targetEsVersion < 9) && (targetEsVersion !== Infinity))) {\nreturn THROW_RANGE('Object spread/rest requires the requested version to be ES9+', tok_getStart(), tok_getStop());\n}\nreturn parseArrowableSpreadOrRest(lexerFlags, scoop, 16517, bindingType, 0, exportedNames, exportedBindings, astProp);\n}\nfunction parseObjectMethod(lexerFlags, $tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column, kind, isComputed, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp) {\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_OBJECT, loc:undefined, key:undefined, method:isRealMethod, generator:undefined, async:undefined, id:undefined, params:[], kind:((kind === 'init')? 'method' : kind), computed:isComputed, body:undefined}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_OBJECT, loc:undefined, key:undefined, kind:kind, method:isRealMethod, computed:isComputed, value:undefined, shorthand:false}, 'key');\n}\nif (acornCompat) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, false, true, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, $tp_paren_start, $tp_paren_line, $tp_paren_column, 1, 'value');\n} else {\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, false, true, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, $tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column, 1, 'value');\n}\nAST_close($tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column);\nreturn 1;\n}\nfunction parsePatternAssignMaybe(lexerFlags, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, destructible, astProp) {\nverifyDestructible(destructible);\nif (!isAnyAssignmentOp()) {\nreturn destructible;\n}\nif (tok_getType() !== 49264) {\nreturn THROW_RANGE('Cannot compound-assign to an array literal', tok_getStart(), tok_getStop());\n}\nif ((destructible & 1) === 1) {\nreturn THROW_RANGE('Tried to destructure something that is not destructible', tok_getStart(), tok_getStop());\n}\ndestructible = (destructible | 4) ^ 4;\nAST_destruct(astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\ndestructible |= parseExpression(lexerFlags, 'right');\nAST_close($tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column);\nreturn destructible;\n}\nfunction parseClassDeclaration(lexerFlags, scoop, optionalIdent, isLabelled, fdState, astProp) {\nlet originalOuterLexerFlags = lexerFlags;\nlet $tp_class_line = tok_getLine();\nlet $tp_class_column = tok_getColumn();\nlet $tp_class_start = tok_getStart();\nlet $tp_class_stop = tok_getStop();\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nreturn THROW_RANGE('Cannot parse a class declaration here, only expecting statements here', $tp_class_start, $tp_class_stop);\n}\nlexerFlags = ((lexerFlags | 8192) | 6176) ^ 6176;\nskipToIdentCurlyOpen(lexerFlags);\nAST_open(astProp, {type:'ClassDeclaration', loc:undefined, id:undefined, superClass:undefined, body:undefined});\nlet $tp_name_canon = parseClassId(lexerFlags, optionalIdent, scoop);\n_parseClass(lexerFlags, originalOuterLexerFlags, 2);\nAST_close($tp_class_start, $tp_class_line, $tp_class_column);\nreturn $tp_name_canon;\n}\nfunction parseClassExpression(lexerFlags, $tp_class_start, $tp_class_line, $tp_class_column, astProp) {\nlet originalOuterLexerFlags = lexerFlags;\nlexerFlags = ((lexerFlags | 8192) | 6176) ^ 6176;\nAST_open(astProp, {type:'ClassExpression', loc:undefined, id:undefined, superClass:undefined, body:undefined});\nparseClassId(lexerFlags, true, null);\nlet assignable = _parseClass(lexerFlags, originalOuterLexerFlags, 1);\nAST_close($tp_class_start, $tp_class_line, $tp_class_column);\nreturn setNotAssignable(assignable);\n}\nfunction parseClassId(lexerFlags, optionalIdent, scoop) {\nlet $tp_bindingName_canon = '';\nif ((isIdentToken(tok_getType()) && (tok_getType() !== 2090))) {\nlet $tp_className_type = tok_getType();\nlet $tp_className_start = tok_getStart();\nlet $tp_className_stop = tok_getStop();\nlet $tp_className_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_className_type, $tp_className_start, $tp_className_stop, $tp_className_canon, BINDING_TYPE_CLASS, lexerFlags);\n$tp_bindingName_canon = $tp_className_canon;\nSCOPE_addLexBinding(scoop, $tp_className_start, $tp_className_stop, $tp_bindingName_canon, BINDING_TYPE_CLASS, 1);\nlet $tp_id_line = tok_getLine();\nlet $tp_id_column = tok_getColumn();\nlet $tp_id_start = tok_getStart();\nlet $tp_id_stop = tok_getStop();\nlet $tp_id_canon = tok_getCanoN();\nskipToIdentCurlyOpen(lexerFlags);\nAST_setIdent('id', $tp_id_start, $tp_id_stop, $tp_id_line, $tp_id_column, $tp_id_canon);\n} else if (optionalIdent === false) {\nreturn THROW_RANGE('Class decl missing required ident, `extends` is not a valid variable name', tok_getStart(), tok_getStop());\n} else {\nAST_set('id', null);\n}\nreturn $tp_bindingName_canon;\n}\nfunction _parseClass(outerLexerFlags, originalOuterLexerFlags, isExpression) {\nlet assignable = 8;\nlet innerLexerFlags = (outerLexerFlags | 16) ^ 16;\nif ((isIdentToken(tok_getType()) && (tok_getType() === 2090))) {\nskipToExpressionStart(outerLexerFlags);\nassignable = parseValue(outerLexerFlags, false, 4, true, 'superClass');\ninnerLexerFlags |= 16384;\n} else {\nAST_set('superClass', null);\ninnerLexerFlags = (innerLexerFlags | 16384) ^ 16384;\n}\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Expected the opening curly `{` of a class body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\ninnerLexerFlags |= 32768;\nassignable |= parseClassBody(innerLexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, 'body');\nreturn assignable;\n}\nfunction parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nAST_open(astProp, {type:'ClassBody', loc:undefined, body:[]});\nlet assignable = _parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, 'body');\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nreturn assignable;\n}\nfunction _parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, astProp) {\nlet destructibleForPiggies = 1;\nskipAny(lexerFlags);\nwhile (tok_getType() === 16490) {\nskipAny(lexerFlags);\n}\nlet hasConstructor = false;\nwhile (tok_getType() !== 16517) {\nlet $tp_memberStart_start = tok_getStart();\nlet $tp_memberStart_stop = tok_getStop();\nlet destructNow = parseClassMethod(lexerFlags, outerLexerFlags, astProp);\nif ((destructNow & 256) !== 0) {\nif (hasConstructor) {\nreturn THROW_RANGE('Classes may only have one constructor', $tp_memberStart_start, $tp_memberStart_stop);\n}\nhasConstructor = true;\ndestructNow = (destructNow | 256) ^ 256;\n}\ndestructibleForPiggies |= destructNow;\nwhile (tok_getType() === 16490) {\nskipAny(lexerFlags);\n}\n}\nif (isExpression === 1) {\nskipDiv(originalOuterLexerFlags);\n} else {\nskipToStatementStart(originalOuterLexerFlags);\n}\nreturn destructibleForPiggies;\n}\nfunction parseClassMethod(lexerFlags, outerLexerFlags, astProp) {\nlet $tp_methodStart_line = tok_getLine();\nlet $tp_methodStart_column = tok_getColumn();\nlet $tp_methodStart_start = tok_getStart();\nlet isStatic = false;\nif (tok_getType() === 2113) {\nisStatic = true;\nlet $tp_static_line = tok_getLine();\nlet $tp_static_column = tok_getColumn();\nlet $tp_static_start = tok_getStart();\nlet $tp_static_stop = tok_getStop();\nlet $tp_static_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 16471) {\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, false, 0, 0, 0, 0, $tp_static_start, $tp_static_stop, $tp_static_line, $tp_static_column, $tp_static_canon, astProp);\n}\n}\nlet $tp_afterStaticMaybe_type = tok_getType();\nif (isIdentToken($tp_afterStaticMaybe_type)) {\nreturn parseClassMethodFromIdent(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, astProp);\n}\nif (isNumberStringToken($tp_afterStaticMaybe_type)) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, astProp);\n}\nif ($tp_afterStaticMaybe_type === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, astProp);\n}\nif ($tp_afterStaticMaybe_type === 82009) {\nskipToIdentStringNumberSquareOpen(lexerFlags);\nif (isIdentToken(tok_getType())) {\nreturn parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nif (isNumberStringToken(tok_getType())) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nif (tok_getType() === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nreturn THROW_RANGE('Invalid objlit key character after generator star', $tp_methodStart_line, tok_getStop());\n}\nreturn THROW_RANGE('Unexpected token, wanted to parse a start of a property in an class literal/pattern', $tp_methodStart_line, tok_getStop());\n}\nfunction parseClassMethodFromIdent(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 16471) {\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp);\n}\nlet $tp_async_type = 0;\nlet $tp_star_type = 0;\nlet $tp_get_type = 0;\nlet $tp_set_type = 0;\nswitch ($tp_ident_type) {\ncase 2096:\n$tp_get_type = 2096;\nbreak;\ncase 2112:\n$tp_set_type = 2112;\nbreak;\ncase 2074:\nif (!allowAsyncFunctions) {\nreturn THROW_RANGE('Async methods are not supported in the currently targeted language version', $tp_methodStart_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async methods are a restricted production and cannot have a newline following it', $tp_methodStart_line, tok_getStart());\n}\n$tp_async_type = 2074;\nif (tok_getType() === 82009) {\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('Async generator methods are not supported in the currently targeted language version', $tp_methodStart_start, tok_getStop());\n}\n$tp_star_type = 82009;\nskipToIdentStringNumberSquareOpen(lexerFlags);\n}\nbreak;\ndefault:\nreturn THROW_RANGE('Either the current modifier is unknown or the input that followed was unexpected', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nif (isNumberStringToken(tok_getType())) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nif (isIdentToken(tok_getType())) {\nreturn parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nreturn THROW_RANGE('Expected to parse the modified key of a class method but could not parse one', tok_getStart(), tok_getStop());\n}\nfunction parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_key_line = tok_getLine();\nlet $tp_key_column = tok_getColumn();\nlet $tp_key_start = tok_getStart();\nlet $tp_key_stop = tok_getStop();\nlet $tp_key_canon = tok_getCanoN();\nskipToParenOpenOrDie(lexerFlags);\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon, astProp);\n}\nfunction _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon, astProp) {\nAST_setIdent(astProp, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon);\nif ((isStatic && ($tp_key_canon === 'prototype'))) {\nreturn THROW_RANGE('Static class methods can not be called `prototype`', $tp_methodStart_line, tok_getStop());\n}\nlet kind = 'method';\nlet isClassConstructor = false;\nif (((!isStatic) && ($tp_key_canon === 'constructor'))) {\nisClassConstructor = true;\nkind = 'constructor';\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('Class constructors can not be async', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('Class constructors can not be generators', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Class constructors can not be getters', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Class constructors can not be setters', $tp_methodStart_line, tok_getStop());\n}\n} else if ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nreturn parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, false, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nfunction parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nif ((isStatic && ($tp_lit_canon === 'prototype'))) {\nreturn THROW_RANGE('Static class methods can not be called `prototype`', $tp_methodStart_line, tok_getStop());\n}\nlet kind = 'method';\nlet isClassConstructor = false;\nif (((!isStatic) && ($tp_lit_canon === 'constructor'))) {\nisClassConstructor = true;\nkind = 'constructor';\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('Class constructors can not be async', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('Class constructors can not be generators', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Class constructors can not be getters', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Class constructors can not be setters', $tp_methodStart_line, tok_getStop());\n}\n} else if ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nskipToParenOpenOrDie(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nreturn parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, false, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nfunction parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nskipToExpressionStart(lexerFlags);\nlet assignable_forPiggies = parseExpression(outerLexerFlags, astProp);\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Missing right square bracket for computed member, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToParenOpenOrDie(lexerFlags);\nlet kind = 'method';\nif ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nparseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, false, true, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\nreturn assignable_forPiggies;\n}\nfunction parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, isComputedKey, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_CLASS, loc:undefined, key:undefined, static:isStatic, computed:isComputedKey, async:undefined, generator:undefined, id:undefined, params:[], kind:kind}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_CLASS, loc:undefined, key:undefined, static:isStatic, computed:isComputedKey, kind:kind, value:undefined}, 'key');\n}\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, isClassConstructor, true, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, (acornCompat? $tp_paren_start : $tp_methodStart_start), (acornCompat? $tp_paren_line : $tp_methodStart_line), (acornCompat? $tp_paren_column : $tp_methodStart_column), 1, 'value');\nAST_close($tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column);\nif (isClassConstructor === true) {\nreturn 256;\n}\nreturn 1;\n}\nfunction verifyDestructible(destructible) {\nif ((((destructible & 1) === 1) && ((destructible & 4) === 4))) {\nreturn THROW_RANGE('Found a part that cant destruct and a part that must destruct so it is not destructible', tok_getStart(), tok_getStop());\n}\n}\nfunction verifyDestructibleForBinding(destructible, bindingType) {\nif ((destructible & 1) !== 0) {\nreturn THROW_RANGE('The binding pattern is not destructible', tok_getStart(), tok_getStop());\n}\nif (((bindingType !== BINDING_TYPE_NONE) && ((destructible & 2) !== 0))) {\nreturn THROW_RANGE('This binding can not be used in function parameters because it is not destructible', tok_getStart(), tok_getStop());\n}\n}\nfunction parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, destructible, closingPuncType, astProp) {\nif (((tok_getType() === 16480) || (tok_getType() === closingPuncType))) {\nif (notAssignable(assignable)) destructible |= 1;\n} else if ((destructible & 4) === 4) {\nreturn THROW_RANGE('Found something that had to be a Pattern but had to parse more, which is an error', $tp_valueStart_start, tok_getStart());\n} else {\nassignable = parseValueTail(lexerFlags, $tp_valueStart_start, $tp_valueStart_line, $tp_valueStart_column, assignable, 4, false, astProp);\nif (isAssignable(assignable)) {\ndestructible = (destructible | 7) ^ 7;\n} else {\ndestructible |= 1;\n}\nlet firstOpNotAssign = tok_getType() !== 49264;\nif (((tok_getType() !== 16480) && (tok_getType() !== closingPuncType))) {\nassignable |= parseExpressionFromOp(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, astProp);\nif (firstOpNotAssign) {\ndestructible |= 1;\n} else {\n\n}\n} else if (firstOpNotAssign) {\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else {\ndestructible |= 2;\n}\n}\n}\nreturn copyPiggies(destructible, assignable);\n}\nfunction parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, exportedNames, exportedBindings, astProp) {\nlet $tp_spread_line = tok_getLine();\nlet $tp_spread_column = tok_getColumn();\nlet $tp_spread_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Can not rest twice', $tp_spread_start, tok_getStop());\n}\nAST_open(astProp, {type:'SpreadElement', loc:undefined, argument:undefined});\nlet destructible = _parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, $tp_spread_start, exportedNames, exportedBindings, 'argument');\nAST_close($tp_spread_start, $tp_spread_line, $tp_spread_column);\nif (((tok_getType() !== closingPuncType) && (tok_getType() !== 16480))) {\nreturn THROW_RANGE('Encountered invalid input after spread/rest argument', tok_getStart(), tok_getStop());\n}\nreturn destructible;\n}\nfunction _parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, $tt_spreadToken_start, exportedNames, exportedBindings, astProp) {\nlet $tp_argStart_line = tok_getLine();\nlet $tp_argStart_column = tok_getColumn();\nlet $tp_argStart_start = tok_getStart();\nlet $tp_argStart_stop = tok_getStop();\nlet destructible = 0;\nlet assignable = 32;\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet assignBefore = tok_getType() === 49264;\nlet willBeSimple = ((((tok_getType() === closingPuncType) || (tok_getType() === 16480))) || assignBefore);\nif (willBeSimple) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\ndestructible |= 1;\n}\n} else {\ndestructible |= 2;\n}\nassignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== closingPuncType))) {\nif (tok_getType() === 49264) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Tried to assign to a value that was not assignable in arr/obj lit/patt', tok_getStart(), tok_getStop());\n}\n}\ndestructible |= 1;\nassignable = parseExpressionFromOp(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, astProp);\n}\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else if (willBeSimple) {\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\n} else {\ndestructible |= 2;\n}\n} else if (tok_getType() === 16509) {\nlet nowDestruct = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nif (((((tok_getType() !== 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\ndestructible = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, nowDestruct, closingPuncType, astProp);\n} else {\nif (((closingPuncType === 16517) && (tok_getType() !== 49264))) {\ndestructible |= nowDestruct | 1;\n} else {\ndestructible |= nowDestruct;\n}\n}\nassignable = (((destructible & 1) === 1)? 16 : 32);\nif (((closingPuncType === 16517) && notAssignable(assignable))) {\ndestructible |= 1;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nlet $tp_curly_stop = tok_getStop();\nlet nowDestruct = parseObjectAndAssign(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nif (((((tok_getType() !== 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\ndestructible = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_curly_start, $tp_curly_stop, $tp_curly_line, $tp_curly_column, assignable, nowDestruct, closingPuncType, astProp);\n} else {\ndestructible |= nowDestruct;\nif (((closingPuncType === 16517) && (tok_getType() !== 49264))) {\ndestructible |= 1;\n}\n}\nassignable = (((destructible & 1) === 1)? 16 : 32);\nif (((closingPuncType === 16517) && notAssignable(assignable))) {\ndestructible |= 1;\n}\n} else if (tok_getType() === closingPuncType) {\nreturn THROW_RANGE('The rest/spread operator is missing an argument', $tt_spreadToken_start, tok_getStop());\n} else {\ndestructible |= 2;\nlet $tp_exprStart_line = tok_getLine();\nlet $tp_exprStart_column = tok_getColumn();\nlet $tp_exprStart_start = tok_getStart();\nlet $tp_exprStart_stop = tok_getStop();\nlet nowAssignable = parseValue(lexerFlags, true, 4, false, astProp);\nif (notAssignable(nowAssignable)) {\ndestructible = 1;\n}\nassignable = mergeAssignable(nowAssignable, assignable);\nif (((((tok_getType() === 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('This `...` arg is invalid; rest only accepts idents, arrays, and objects and as spread the assignment is illegal because the lhs is not assignable', $tt_spreadToken_start, tok_getStop());\n}\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\ndestructible |= 1;\n} else {\nif (tok_getType() === 16480) {\ndestructible |= 1;\n} else if (tok_getType() !== closingPuncType) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\n} else {\n\n}\nif (isAssignable(assignable)) {\ndestructible |= 2;\n} else {\ndestructible |= 1;\n}\n}\nif (((closingPuncType === 16517) && (!isAssignable(assignable)))) destructible |= 1;\nreturn copyPiggies(destructible, assignable);\n}\nif (tok_getType() !== closingPuncType) {\nif (bindingType === BINDING_TYPE_ARG) {\nif ($tp_async_type === 2074) {\ndestructible |= 1;\n} else {\ndestructible |= 2;\n}\n}\nif (tok_getType() === 49264) {\nverifyDestructible(destructible | 4);\ndestructible = 1;\nAST_destruct(astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, 'right');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_argStart_start, $tp_argStart_line, $tp_argStart_column);\n} else {\nassignable = parseValueTail(lexerFlags, $tp_argStart_start, $tp_argStart_line, $tp_argStart_column, assignable, 4, false, astProp);\nassignable = parseExpressionFromOp(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, astProp);\n}\ndestructible |= 1;\n}\nreturn copyPiggies(destructible, assignable);\n}\nlet initialLexerFlags = ((260 | ((((options_strictMode || (goalMode === true)))? 8192 : 0))) | 4) ^ 4;\ninitLexer(initialLexerFlags);\nparseTopLevels(initialLexerFlags);\nif (tok_getType() !== 2097173) {\nreturn THROW_RANGE('Unexpected further input', tok_getStart(), tok_getStop());\n}\n_tree.loc = AST_getCloseLoc(0, 1, 0, tok_prevEndPointer(), tok_getLine(), tok_getColumn());\nreturn {ast:_tree, tokens:tok.tokens, tokenCountSolid:tok.getTokenCountSolid(), tokenCountAny:tok.getTokenCountAny()};\n}\nfunction isTemplateStart(type) {\nreturn ((((((type === 524308) || (type === 524305))) || (type === 1572884))) || (type === 1572881));\n}\nfunction D(d) {\nif (d === 0) {\nreturn 'D=MIGHT_DESTRUCT';\n}\nlet arr = [];\nif (d & 1) {\narr.push('CANT_DESTRUCT');\nd ^= 1;\n}\nif (d & 4) {\narr.push('MUST_DESTRUCT');\nd ^= 4;\n}\nif (d & 2) {\narr.push('DESTRUCT_ASSIGN_ONLY');\nd ^= 2;\n}\nif (d & 8) {\narr.push('(ASSIGNABLE_UNDETERMINED)');\nd ^= 8;\n}\nif (d & 16) {\narr.push('(NOT_ASSIGNABLE)');\nd ^= 16;\n}\nif (d & 32) {\narr.push('(IS_ASSIGNABLE)');\nd ^= 32;\n}\nd = P(d, arr);\nif (d !== 0) {\nconsole.log('Gathered flags so far:', arr.join(', '));\n}\nreturn 'D=' + arr.join(', ');\n}\nfunction A(a) {\nif (a === 0) {\nreturn 'A=ASSIGNABLE_UNDETERMINED';\n}\nlet arr = [];\nif (a & 8) {\narr.push('ASSIGNABLE_UNDETERMINED');\na ^= 8;\n}\nif (a & 16) {\narr.push('NOT_ASSIGNABLE');\na ^= 16;\n}\nif (a & 32) {\narr.push('IS_ASSIGNABLE');\na ^= 32;\n}\nif (a & 1) {\narr.push('(CANT_DESTRUCT)');\na ^= 1;\n}\nif (a & 4) {\narr.push('(MUST_DESTRUCT)');\na ^= 4;\n}\nif (a & 2) {\narr.push('(DESTRUCT_ASSIGN_ONLY)');\na ^= 2;\n}\na = P(a, arr);\nif (a !== 0) {\nconsole.log('Gathered flags so far:', arr.join(', '));\n}\nreturn 'A=' + arr.join(', ');\n}\nfunction B(b) {\nif (b === BINDING_TYPE_NONE) return 'B=BINDING_TYPE_NONE';\nif (b === BINDING_TYPE_ARG) return 'B=BINDING_TYPE_ARG';\nif (b === BINDING_TYPE_VAR) return 'B=BINDING_TYPE_VAR';\nif (b === BINDING_TYPE_LET) return 'B=BINDING_TYPE_LET';\nif (b === BINDING_TYPE_CONST) return 'B=BINDING_TYPE_CONST';\nif (b === BINDING_TYPE_CLASS) return 'B=BINDING_TYPE_CLASS';\nif (b === BINDING_TYPE_CATCH_IDENT) return 'B=BINDING_TYPE_CATCH_IDENT';\nif (b === BINDING_TYPE_CATCH_OTHER) return 'B=BINDING_TYPE_CATCH_OTHER';\nif (b === BINDING_TYPE_FUNC_VAR) return 'B=BINDING_TYPE_FUNC_VAR';\nif (b === BINDING_TYPE_FUNC_LEX) return 'B=BINDING_TYPE_FUNC_LEX';\nif (b === BINDING_TYPE_FUNC_STMT) return 'B=BINDING_TYPE_FUNC_STMT';\n}\nfunction S(s) {\nif (s === SCOPE_LAYER_GLOBAL) return 'SCOPE_LAYER_GLOBAL';\nif (s === SCOPE_LAYER_FOR_HEADER) return 'SCOPE_LAYER_FOR_HEADER';\nif (s === SCOPE_LAYER_BLOCK) return 'SCOPE_LAYER_BLOCK';\nif (s === SCOPE_LAYER_FUNC_PARAMS) return 'SCOPE_LAYER_FUNC_PARAMS';\nif (s === SCOPE_LAYER_CATCH_HEAD) return 'SCOPE_LAYER_CATCH_HEAD';\nif (s === SCOPE_LAYER_CATCH_BODY) return 'SCOPE_LAYER_CATCH_BODY';\nif (s === SCOPE_LAYER_FINALLY) return 'SCOPE_LAYER_FINALLY';\nif (s === SCOPE_LAYER_SWITCH) return 'SCOPE_LAYER_SWITCH';\nif (s === SCOPE_LAYER_FUNC_ROOT) return 'SCOPE_LAYER_FUNC_ROOT';\nif (s === SCOPE_LAYER_FUNC_BODY) return 'SCOPE_LAYER_FUNC_BODY';\nif (s === SCOPE_LAYER_ARROW_PARAMS) return 'SCOPE_LAYER_ARROW_PARAMS';\nif (s === SCOPE_LAYER_FAKE_BLOCK) return 'SCOPE_LAYER_FAKE_BLOCK';\n}\nfunction F(fdState) {\nif (fdState === 1) return 'F=FDS_ILLEGAL'; else if (fdState === 2) return 'F=FDS_IFELSE'; else if (fdState === 3) return 'F=FDS_LEX'; else if (fdState === 4) return 'F=FDS_VAR'; else ;\n}\n// </parser>\n\n\nlet Tenko = Parser;\n\n\nexport default Tenko; // Does dual export make sense? Default and as member. To each their own, eh\nexport {\n\n  Tenko,\n  Lexer,\n\n  COLLECT_TOKENS_NONE,\n  COLLECT_TOKENS_SOLID,\n  COLLECT_TOKENS_ALL,\n  COLLECT_TOKENS_TYPES,\n\n  GOAL_MODULE,\n  GOAL_SCRIPT,\n\n  BINDING_TYPE_NONE,\n  BINDING_TYPE_ARG,\n  BINDING_TYPE_VAR,\n  BINDING_TYPE_LET,\n  BINDING_TYPE_CONST,\n  BINDING_TYPE_CLASS,\n  BINDING_TYPE_FUNC_VAR,\n  BINDING_TYPE_FUNC_LEX,\n  BINDING_TYPE_FUNC_STMT,\n  BINDING_TYPE_CATCH_IDENT,\n  BINDING_TYPE_CATCH_OTHER,\n  HAS_NO_BINDINGS,\n  SCOPE_LAYER_GLOBAL,\n  SCOPE_LAYER_FOR_HEADER,\n  SCOPE_LAYER_BLOCK,\n  SCOPE_LAYER_FUNC_PARAMS,\n  SCOPE_LAYER_CATCH_HEAD,\n  SCOPE_LAYER_CATCH_BODY,\n  SCOPE_LAYER_FINALLY,\n  SCOPE_LAYER_SWITCH,\n  SCOPE_LAYER_FUNC_ROOT,\n  SCOPE_LAYER_FUNC_BODY,\n  SCOPE_LAYER_ARROW_PARAMS,\n  SCOPE_LAYER_FAKE_BLOCK,\n\n  WEB_COMPAT_OFF,\n  WEB_COMPAT_ON,\n\n  VERSION_EXPONENTIATION,\n  VERSION_WHATEVER,\n\n  isWhiteToken,\n  isNewlineToken,\n  isCommentToken,\n  isIdentToken,\n  isNumberToken,\n  isBigintToken,\n  isStringToken,\n  isPunctuatorToken,\n  isRegexToken,\n  isTickToken,\n  isBadTickToken,\n  isNumberStringToken,\n  isNumberStringRegex,\n\n  toktypeToString,\n\n};\n  ","~/proj/zetype/src/globals.mjs":"// A mapping from global symbol to internal type representation of that value\n// All these names ought to be exposed on the global object, even the syntactic keywords (our system does not care)\n// Note: there is no auto-global `arguments` and `super` is not handled through scoping\nexport default new Map([\n  ['clearInterval', 'global.clearInterval'],\n  ['clearTimeout', 'global.clearTimeout'],\n  ['console', 'global.console'],\n  ['false', 'boolean'],\n  ['null', 'null'],\n  ['this', 'undefined'], // true in strict mode\n  ['parseInt', 'global.parseInt'],\n  ['parseFloat', 'global.parseFloat'],\n  ['setInterval', 'global.setInterval'],\n  ['setTimeout', 'global.setTimeout'],\n  ['true', 'boolean'],\n  ['undefined', 'undefined'],\n  ['Array', 'Array'],\n  ['Boolean', 'Boolean'],\n  ['Error', 'Error'],\n  ['Infinity', 'number'],\n  ['JSON', 'JSON'],\n  ['Math', 'Math'],\n  ['Map', 'Map'],\n  ['Number', 'Number'],\n  ['Object', 'Object'],\n  ['RegExp', 'RegExp'],\n  ['Set', 'Set'],\n  ['String', 'String'],\n]);\n","~/proj/zetype/src/walk.mjs":"export default function walk(f, node, prop){\n  let types = [];\n  let nodes = [];\n  let props = [];\n\n  let path = {\n    types,\n    nodes,\n    props,\n  };\n\n  function ww(f, node, prop) {\n    if (node === null) {\n      return;\n    }\n    if (typeof node !== 'object') {\n      console.dir(node);\n      throw new Error('Should only walk nodes or `null` values, from `' + prop + '`, node = ' + node);\n    }\n\n    if (node instanceof Array) {\n      return node.forEach(node => ww(f, node, prop));\n    }\n\n    let t = node.type;\n\n    props.push(prop);\n    types.push(t);\n    nodes.push(node);\n\n    if (f(node, true, t, path) !== true) { // callback can prevent going deeper by explicitly returning true\n      switch (t) {\n        case 'ArrayExpression':\n        case 'ArrayPattern':\n          onlyObjects(node, ['elements']);\n          ww(f, node.elements, 'elements');\n          break;\n\n        case 'ArrowFunctionExpression':\n          onlyObjects(node, ['params', 'id', 'body']);\n          ww(f, node.params, 'params');\n          ww(f, node.body, 'body');\n          break;\n\n        case 'AssignmentExpression':\n        case 'AssignmentPattern':\n          onlyObjects(node, ['left', 'right']);\n          ww(f, node.right, 'right'); // Visit right before left to make sure rhs is resolved\n          ww(f, node.left, 'left');\n          break;\n\n        case 'AwaitExpression':\n          onlyObjects(node, ['argument']);\n          ww(f, node.argument, 'argument');\n          break;\n\n        case 'BinaryExpression':\n          onlyObjects(node, ['left', 'right']);\n          ww(f, node.left, 'left');\n          ww(f, node.right, 'right');\n          break;\n\n        case 'BlockStatement':\n          onlyObjects(node, ['body']);\n          ww(f, node.body, 'body');\n          break;\n\n        case 'BreakStatement':\n          onlyObjects(node, ['label']);\n          ww(f, node.label, 'label');\n          break;\n\n        case 'CallExpression':\n          onlyObjects(node, ['callee', 'arguments']);\n          ww(f, node.callee, 'callee');\n          ww(f, node.arguments, 'arguments');\n          break;\n\n        case 'CatchClause':\n          onlyObjects(node, ['param', 'body']);\n          ww(f, node.param, 'param');\n          ww(f, node.body, 'body');\n          break;\n\n        case 'ClassBody':\n          onlyObjects(node, ['body']);\n          ww(f, node.body, 'body');\n          break;\n\n        case 'ClassDeclaration':\n        case 'ClassExpression':\n          onlyObjects(node, ['id', 'superClass', 'body']);\n          ww(f, node.id ,'id');\n          ww(f, node.superClass, 'superClass');\n          ww(f, node.body, 'body');\n          break;\n\n        case 'ConditionalExpression':\n          onlyObjects(node, ['test', 'consequent', 'alternate']);\n          ww(f, node.test, 'test');\n          ww(f, node.consequent, 'consequent');\n          ww(f, node.alternate, 'alternate');\n          break;\n\n        case 'ContinueStatement':\n          onlyObjects(node, ['label']);\n          ww(f, node.label, 'label');\n          break;\n\n        case 'DebuggerStatement':\n        case 'Directive':\n          onlyObjects(node, []);\n          break;\n\n        case 'DoWhileStatement':\n          onlyObjects(node, ['body', 'test']);\n          ww(f, node.body, 'body');\n          ww(f, node.test, 'test');\n          break;\n\n        case 'EmptyStatement':\n          onlyObjects(node, []);\n          break;\n\n        case 'ExportAllDeclaration':\n          onlyObjects(node, ['source']);\n          ww(f, node.source, 'source');\n          break;\n\n        case 'ExportDefaultDeclaration':\n          onlyObjects(node, ['declaration']);\n          ww(f, node.declaration, 'declaration');\n          break;\n\n        case 'ExportNamedDeclaration':\n          onlyObjects(node, ['specifiers', 'declaration', 'source']);\n          ww(f, node.specifiers, 'specifiers');\n          ww(f, node.declaration, 'declaration');\n          ww(f, node.source, 'source');\n          break;\n\n        case 'ExportSpecifier':\n          onlyObjects(node, ['local', 'exported']);\n          ww(f, node.local, 'local');\n          ww(f, node.exported, 'exported');\n          break;\n\n        case 'ExpressionStatement':\n          onlyObjects(node, ['expression']);\n          ww(f, node.expression, 'expression');\n          break;\n\n        case 'ForInStatement':\n        case 'ForOfStatement':\n          onlyObjects(node, ['left', 'right', 'body']);\n          ww(f, node.left, 'left');\n          ww(f, node.right, 'right');\n          ww(f, node.body, 'body');\n          break;\n\n        case 'ForStatement':\n          onlyObjects(node, ['init', 'test', 'update', 'body']);\n          ww(f, node.init, 'init');\n          ww(f, node.test, 'test');\n          ww(f, node.update, 'update');\n          ww(f, node.body, 'body');\n          break;\n\n        case 'FunctionDeclaration':\n        case 'FunctionExpression':\n          onlyObjects(node, ['id', 'params', 'body']);\n          ww(f, node.id, 'id');\n          ww(f, node.params, 'params');\n          ww(f, node.body, 'body');\n          break;\n\n        case 'Identifier':\n          onlyObjects(node, []);\n          break;\n\n        case 'IfStatement':\n          onlyObjects(node, ['test', 'consequent', 'alternate']);\n          ww(f, node.test, 'test');\n          ww(f, node.consequent, 'consequent');\n          ww(f, node.alternate, 'alternate');\n          break;\n\n        case 'ImportDeclaration':\n          onlyObjects(node, ['specifiers', 'source']);\n          ww(f, node.specifiers, 'specifiers');\n          ww(f, node.source, 'source');\n          break;\n\n        case 'ImportDefaultSpecifier':\n        case 'ImportNamespaceSpecifier':\n          onlyObjects(node, ['local']);\n          ww(f, node.local, 'local');\n          break;\n\n        case 'ImportSpecifier':\n          onlyObjects(node, ['imported', 'local']);\n          ww(f, node.imported, 'imported');\n          ww(f, node.local, 'local');\n          break;\n\n        case 'LabeledStatement':\n          onlyObjects(node, ['label', 'block']);\n          ww(f, node.label, 'label');\n          ww(f, node.block, 'block');\n          break;\n\n        case 'Literal':\n          onlyObjects(node, node.regex ? ['regex'] : []); // regexes will have an object here\n          break;\n\n        case 'LogicalExpression':\n          onlyObjects(node, ['left', 'right']);\n          ww(f, node.left, 'left');\n          ww(f, node.right, 'right');\n          break;\n\n        case 'MemberExpression':\n          onlyObjects(node, ['object', 'property']);\n          ww(f, node.object, 'object');\n          ww(f, node.property, 'property');\n          break;\n\n        case 'MetaProperty':\n          onlyObjects(node, ['meta', 'property']);\n          ww(f, node.meta, 'meta');\n          ww(f, node.property, 'property');\n          break;\n\n        case 'MethodDefinition':\n          onlyObjects(node, ['key', 'value']);\n          ww(f, node.key, 'key');\n          ww(f, node.value, 'value');\n          break;\n\n        case 'NewExpression':\n          onlyObjects(node, ['arguments', 'callee']);\n          ww(f, node.arguments, 'arguments');\n          ww(f, node.callee, 'callee');\n          break;\n\n        case 'ObjectExpression':\n          onlyObjects(node, ['properties']);\n          ww(f, node.properties, 'properties');\n          break;\n\n        case 'ObjectPattern':\n          onlyObjects(node, ['properties']);\n          ww(f, node.properties, 'properties');\n          break;\n\n        case 'Program':\n          onlyObjects(node, ['body']);\n          ww(f, node.body, 'body');\n          break;\n\n        case 'Property':\n          onlyObjects(node, ['key', 'value']);\n          ww(f, node.key, 'key');\n          ww(f, node.value, 'value');\n          break;\n\n        case 'RestElement':\n        case 'ReturnStatement':\n          onlyObjects(node, ['argument']);\n          ww(f, node.argument, 'argument');\n          break;\n\n        case 'SequenceExpression':\n          onlyObjects(node, ['expressions']);\n          ww(f, node.expressions, 'expressions');\n          break;\n\n        case 'SpreadElement':\n          onlyObjects(node, ['argument']);\n          ww(f, node.argument, 'argument');\n          break;\n\n        case 'Super':\n          onlyObjects(node, []);\n          break;\n\n        case 'SwitchCase':\n          onlyObjects(node, ['test', 'consequent']);\n          ww(f, node.test, 'test');\n          ww(f, node.consequent, 'consequent');\n          break;\n\n        case 'SwitchStatement':\n          onlyObjects(node, ['discriminant', 'cases']);\n          ww(f, node.discriminant, 'discriminant');\n          ww(f, node.cases, 'cases');\n          break;\n\n        case 'TaggedTemplateExpression':\n          onlyObjects(node, ['tags', 'quasi']);\n          ww(f, node.tag, 'tags');\n          ww(f, node.quasi, 'quasi');\n          break;\n\n        case 'TemplateElement':\n          onlyObjects(node, ['value']);\n          // walk(f, node.value, 'value'); // not a node\n          break;\n\n        case 'TemplateLiteral':\n          onlyObjects(node, ['expressions', 'quasis']);\n          ww(f, node.expressions, 'expressions');\n          ww(f, node.quasis, 'quasis');\n          break;\n\n        case 'ThisExpression':\n          onlyObjects(node, []);\n          break;\n\n        case 'ThrowStatement':\n          onlyObjects(node, ['argument']);\n          ww(f, node.argument, 'argument');\n          break;\n\n        case 'TryStatement':\n          onlyObjects(node, ['block', 'handler', 'finalizer']);\n          ww(f, node.block, 'block');\n          ww(f, node.handler, 'handler');\n          ww(f, node.finalizer, 'finalizer');\n          break;\n\n        case 'UnaryExpression':\n        case 'UpdateExpression':\n          onlyObjects(node, ['argument']);\n          ww(f, node.argument, 'argument');\n          break;\n\n        case 'VariableDeclaration':\n          onlyObjects(node, ['declarations']);\n          ww(f, node.declarations, 'declarations');\n          break;\n\n        case 'VariableDeclarator':\n          onlyObjects(node, ['id', 'init']);\n          ww(f, node.id, 'id');\n          ww(f, node.init, 'init');\n          break;\n\n        case 'WhileStatement':\n          onlyObjects(node, ['test', 'body']);\n          ww(f, node.test, 'test');\n          ww(f, node.body, 'body');\n          break;\n\n        case 'WithStatement':\n          onlyObjects(node, ['object', 'body']);\n          ww(f, node.object, 'object');\n          ww(f, node.body, 'body');\n          break;\n\n        case 'YieldExpression':\n          onlyObjects(node, ['argument']);\n          ww(f, node.argument, 'argument');\n          break;\n\n        default:\n          throw 'Unknown node type, from `' + prop + '`, node = ' + node;\n      }\n\n      f(node, false, t, path);\n    }\n\n    types.pop();\n    props.pop();\n    nodes.pop();\n  }\n\n  ww(f, node, prop);\n};\n\nfunction onlyObjects(node, props) {\n  // Asserting AST structs\n  for (let p in node) {\n    if (node.hasOwnProperty(p)) {\n      if (node[p] !== null && typeof node[p] === 'object' && !props.includes(p) && p[0] !== '$' && p !== 'loc') {\n        console.log('This is the node for the following `onlyObjects` crash:');\n        console.log(node);\n        console.log('In particular node[p]:');\n        console.log(node[p]);\n        console.log('Known props:', props)\n        throw new Error('onlyObjects: Missing node[prop] with prop = `' + p + '` that is object');\n      }\n    }\n  }\n}\n","~/proj/zetype/src/error_tenko.mjs":"// This error is thrown for errors that are thrown while parsing with Tenko\nexport class TenkoError extends Error {\n  toString() {\n    return 'Tenko' + super.toString();\n  }\n}\n"},"only":false,"skip":false};